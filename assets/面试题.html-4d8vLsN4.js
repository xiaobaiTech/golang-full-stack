import{_ as e}from"./plugin-vue_export-helper-DlAUqK2U.js";import{o as t,c as l,e as r}from"./app-CXuySPgb.js";const o={},a=r(`<h1 id="rocketmq-面试题" tabindex="-1"><a class="header-anchor" href="#rocketmq-面试题"><span>RocketMQ 面试题</span></a></h1><h2 id="多个-mq-如何选型" tabindex="-1"><a class="header-anchor" href="#多个-mq-如何选型"><span>多个 MQ 如何选型？</span></a></h2><table><thead><tr><th>MQ</th><th>描述</th></tr></thead><tbody><tr><td>RabbitMQ</td><td>erlang 开发，对消息堆积的支持并不好，当大量消息积压的时候，会导致 RabbitMQ 的性能急剧下 降。每秒钟可以处理几万到十几万条消息。</td></tr><tr><td>RocketMQ</td><td>Java 开发，面向互联网集群化功能丰富，对在线业务的响应时延做了很多的优化，大多数情况下可以做 到毫秒级的响应，每秒钟大概能处理几十万条消息。</td></tr><tr><td>Kafka</td><td>Scala 开发，面向日志功能丰富，性能最高。当你的业务场景中，每秒钟消息数量没有那么多的时候， Kafka 的时延反而会比较高。所以，Kafka 不太适合在线业务场景。</td></tr><tr><td>ActiveMQ</td><td>Java 开发，简单，稳定，性能不如前面三个。小型系统用也可以，但是不推荐。推荐用互联网主流的。</td></tr></tbody></table><h2 id="为什么要使用-mq" tabindex="-1"><a class="header-anchor" href="#为什么要使用-mq"><span>为什么要使用 MQ？</span></a></h2><p>因为项目比较大，做了分布式系统，所有远程服务调用请求都是同步执行经常出问题，所 以引入了 MQ。</p><table><thead><tr><th style="text-align:left;">作用</th><th style="text-align:left;">描述</th></tr></thead><tbody><tr><td style="text-align:left;">解耦</td><td style="text-align:left;">系统耦合度降低，没有强依赖关系。</td></tr><tr><td style="text-align:left;">异步</td><td style="text-align:left;">不需要同步执行的远程调用可以有效提高响应时间。</td></tr><tr><td style="text-align:left;">削峰</td><td style="text-align:left;">请求达到峰值后，后端 service 还可以保持固定消费速率消费，不会被压垮。</td></tr></tbody></table><h2 id="rocketmq-由哪些角色组成-每个角色作用和特点是什么" tabindex="-1"><a class="header-anchor" href="#rocketmq-由哪些角色组成-每个角色作用和特点是什么"><span>RocketMQ 由哪些角色组成，每个角色作用和特点是什么？</span></a></h2><table><thead><tr><th style="text-align:left;">角色</th><th style="text-align:left;">作用</th></tr></thead><tbody><tr><td style="text-align:left;">Nameserver</td><td style="text-align:left;">无状态，动态列表；这是和 ZooKeeper 的重要区别之一。ZooKeeper 是有状态的。</td></tr><tr><td style="text-align:left;">Producer</td><td style="text-align:left;">消息生产者，负责发消息到 Broker。</td></tr><tr><td style="text-align:left;">Broker</td><td style="text-align:left;">就是 MQ 本身，负责收发消息、持久化消息等。</td></tr><tr><td style="text-align:left;">Consumer</td><td style="text-align:left;">消息消费者，负责从 Broker 上拉取消息进行消费，消费完进行 ack。</td></tr></tbody></table><h2 id="rocketmq-中的-topic-和-jms-的-queue-有什么区别" tabindex="-1"><a class="header-anchor" href="#rocketmq-中的-topic-和-jms-的-queue-有什么区别"><span>RocketMQ 中的 Topic 和 JMS 的 queue 有什么区别？</span></a></h2><p>queue 就是来源于数据结构的 FIFO 队列。而 Topic 是个抽象的概念，每个 Topic 底层对 应 N 个 queue，而数据也真实存在 queue 上的。</p><h2 id="rocketmq-消费模式有几种" tabindex="-1"><a class="header-anchor" href="#rocketmq-消费模式有几种"><span>RocketMQ 消费模式有几种？</span></a></h2><p>消费模型由 Consumer 决定，消费维度为 Topic。</p><ul><li>集群消费</li></ul><p>1.一条消息只会被同 Group 中的一个 Consumer 消费</p><p>2.多个 Group 同时消费一个 Topic 时，每个 Group 都会有一个 Consumer 消费到数据。</p><ul><li>广播消费</li></ul><p>消息将对一个 Consumer Group 下的各个 Consumer 实例都消费一遍。即即使这些Consumer 属于同一个 Consumer Group，消息也会被 Consumer Group 中的每个 Consumer 都消费一次。</p><h2 id="broker-如何处理拉取请求的" tabindex="-1"><a class="header-anchor" href="#broker-如何处理拉取请求的"><span>Broker 如何处理拉取请求的？</span></a></h2><p>Consumer 首次请求 Broker。</p><ul><li><p>Broker 中是否有符合条件的消息</p></li><li><p>有</p><ul><li><p>响应 Consumer。</p></li><li><p>等待下次 Consumer 的请求。</p></li></ul></li><li><p>没有</p><ul><li><p>DefaultMessageStore#ReputMessageService#run 方法。 - PullRequestHoldService 来 Hold 连接，每个 5s 执行一次检查pullRequestTable 有没有消息，有的话立即推送。</p></li><li><p>每隔 1ms 检查 commitLog 中是否有新消息，有的话写入到pullRequestTable。</p></li><li><p>当有新消息的时候返回请求。</p></li><li><p>挂起 consumer 的请求，即不断开连接，也不返回数据。</p></li><li><p>使用 consumer 的 offset。</p></li></ul></li></ul><h2 id="rocketmq-如何做负载均衡" tabindex="-1"><a class="header-anchor" href="#rocketmq-如何做负载均衡"><span>RocketMQ 如何做负载均衡？</span></a></h2><p>通过 Topic 在多 Broker 中分布式存储实现。</p><p><strong>producer 端</strong></p><p>发送端指定 message queue 发送消息到相应的 broker，来达到写入时的负载均衡</p><ul><li>提升写入吞吐量，当多个 producer 同时向一个 broker 写入数据的时候，性能会下降 - 消息分布在多 broker 中，为负载消费做准备</li></ul><p><strong>默认策略是随机选择：</strong></p><ul><li><p>producer 维护一个 index</p></li><li><p>每次取节点会自增</p></li><li><p>index 向所有 broker 个数取余</p></li><li><p>自带容错策略</p></li></ul><p><strong>其他实现：</strong></p><ul><li><p>SelectMessageQueueByHash</p></li><li><p>hash 的是传入的 args</p></li><li><p>SelectMessageQueueByRandom</p></li><li><p>SelectMessageQueueByMachineRoom 没有实现</p></li></ul><p>也可以自定义实现 MessageQueueSelector 接口中的 select 方法</p><div class="language-text line-numbers-mode" data-ext="text" data-title="text"><pre class="language-text"><code>MESSAGEQUEUE SELECT(FINAL LIST&lt;MESSAGEQUEUE&gt; MQS, FINAL MESSAGE MSG, FINAL OBJECT ARG); 
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p><strong>consumer 端</strong> 采用的是平均分配算法来进行负载均衡。</p><p><strong>其他负载均衡算法</strong></p><p>平均分配策略(默认)(AllocateMessageQueueAveragely) 环形分配策略 (AllocateMessageQueueAveragelyByCircle) 手动配置分配策略 (AllocateMessageQueueByConfig) 机房分配策略 (AllocateMessageQueueByMachineRoom) 一致性哈希分配策略 (AllocateMessageQueueConsistentHash) 靠近机房策略 (AllocateMachineRoomNearby)</p><p><strong>追问：当消费负载均衡 consumer 和 queue 不对等的时候会发生什么？</strong></p><p>Consumer 和 queue 会优先平均分配，如果 Consumer 少于 queue 的个数，则会存在部 分 Consumer 消费多个 queue 的情况，如果 Consumer 等于 queue 的个数，那就是一 个 Consumer 消费一个 queue，如果 Consumer 个数大于 queue 的个数，那么会有部分 Consumer 空余出来，白白的浪费了。</p><h2 id="消息重复消费" tabindex="-1"><a class="header-anchor" href="#消息重复消费"><span>消息重复消费</span></a></h2><p>影响消息正常发送和消费的重要原因是网络的不确定性。</p><p>引起重复消费的原因</p><ul><li>ACK</li></ul><p>正常情况下在 consumer 真正消费完消息后应该发送 ack，通知 broker 该消息 已正常消费，从 queue 中剔除</p><p>当 ack 因为网络原因无法发送到 broker，broker 会认为词条消息没有被消费， 此后会开启消息重投机制把消息再次投递到 consumer</p><ul><li>消费模式</li></ul><p>在 CLUSTERING模式下，消息在 broker 中会保证相同 group 的 consumer 消 费一次，但是针对不同 group 的 consumer 会推送多次</p><p><strong>解决方案</strong></p><ul><li>数据库表</li></ul><p>处理消息前，使用消息主键在表中带有约束的字段中 insert</p><ul><li>Map</li></ul><p>单机时可以使用 map ConcurrentHashMap -&gt; putIfAbsent guava cache - Redis</p><p>分布式锁搞起来。</p><h2 id="rocketmq-如何保证消息不丢失" tabindex="-1"><a class="header-anchor" href="#rocketmq-如何保证消息不丢失"><span>RocketMQ 如何保证消息不丢失</span></a></h2><p>首先在如下三个部分都可能会出现丢失消息的情况：</p><ul><li><p>Producer 端</p></li><li><p>Broker 端</p></li><li><p>Consumer 端</p></li></ul><h2 id="producer-端如何保证消息不丢失" tabindex="-1"><a class="header-anchor" href="#producer-端如何保证消息不丢失"><span>Producer 端如何保证消息不丢失</span></a></h2><ul><li><p>采取 send()同步发消息，发送结果是同步感知的。</p></li><li><p>发送失败后可以重试，设置重试次数。默认 3 次。 PRODUCER.SETRETRYTIMESWHENSENDFAILED(10);</p></li></ul><p>集群部署，比如发送失败了的原因可能是当前 Broker 宕机了，重试的时候会发</p><p>送到其他 Broker 上。</p><h2 id="broker-端如何保证消息不丢失" tabindex="-1"><a class="header-anchor" href="#broker-端如何保证消息不丢失"><span>Broker 端如何保证消息不丢失</span></a></h2><ul><li><p>修改刷盘策略为同步刷盘。默认情况下是异步刷盘的。 FLUSHDISKTYPE = SYNC_FLUSH</p></li><li><p>集群部署，主从模式，高可用。</p></li></ul><h2 id="consumer-端如何保证消息不丢失" tabindex="-1"><a class="header-anchor" href="#consumer-端如何保证消息不丢失"><span>Consumer 端如何保证消息不丢失</span></a></h2><ul><li>完全消费正常后在进行手动 ack 确认。</li></ul><h2 id="高吞吐量下如何优化生产者和消费者的性能" tabindex="-1"><a class="header-anchor" href="#高吞吐量下如何优化生产者和消费者的性能"><span>高吞吐量下如何优化生产者和消费者的性能?</span></a></h2><p><strong>开发</strong></p><ul><li><p>同一 group 下，多机部署，并行消费 - 单个 Consumer 提高消费线程个数 - 批量消费</p></li><li><p>消息批量拉取</p></li><li><p>业务逻辑批量处理</p></li></ul><p><strong>运维</strong></p><ul><li><p>网卡调优</p></li><li><p>jvm 调优</p></li><li><p>多线程与 cpu 调优 - Page Cache</p></li></ul>`,66),i=[a];function p(n,s){return t(),l("div",null,i)}const d=e(o,[["render",p],["__file","面试题.html.vue"]]),m=JSON.parse('{"path":"/%E4%B8%AD%E9%97%B4%E4%BB%B6/rocketmq/%E9%9D%A2%E8%AF%95%E9%A2%98.html","title":"RocketMQ  面试题","lang":"zh-CN","frontmatter":{"description":"RocketMQ 面试题 多个 MQ 如何选型？ 为什么要使用 MQ？ 因为项目比较大，做了分布式系统，所有远程服务调用请求都是同步执行经常出问题，所 以引入了 MQ。 RocketMQ 由哪些角色组成，每个角色作用和特点是什么？ RocketMQ 中的 Topic 和 JMS 的 queue 有什么区别？ queue 就是来源于数据结构的 FIFO ...","head":[["meta",{"property":"og:url","content":"https://golangguide.top/%E4%B8%AD%E9%97%B4%E4%BB%B6/rocketmq/%E9%9D%A2%E8%AF%95%E9%A2%98.html"}],["meta",{"property":"og:site_name","content":"golang全栈指南"}],["meta",{"property":"og:title","content":"RocketMQ  面试题"}],["meta",{"property":"og:description","content":"RocketMQ 面试题 多个 MQ 如何选型？ 为什么要使用 MQ？ 因为项目比较大，做了分布式系统，所有远程服务调用请求都是同步执行经常出问题，所 以引入了 MQ。 RocketMQ 由哪些角色组成，每个角色作用和特点是什么？ RocketMQ 中的 Topic 和 JMS 的 queue 有什么区别？ queue 就是来源于数据结构的 FIFO ..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2024-02-19T03:18:48.000Z"}],["meta",{"property":"article:author","content":"小白debug"}],["meta",{"property":"article:modified_time","content":"2024-02-19T03:18:48.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"RocketMQ  面试题\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2024-02-19T03:18:48.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"小白debug\\",\\"url\\":\\"https://xiaobaidebug.top/\\"}]}"],["link",{"rel":"canonical","href":"https://golangguide.top/%E4%B8%AD%E9%97%B4%E4%BB%B6/rocketmq/%E9%9D%A2%E8%AF%95%E9%A2%98.html"}],["meta",{"property":"og:url","content":"https://golangguide.top/%E4%B8%AD%E9%97%B4%E4%BB%B6/rocketmq/%E9%9D%A2%E8%AF%95%E9%A2%98.html"}],["meta",{"property":"og:site_name","content":"golang全栈指南"}],["meta",{"property":"og:title","content":"RocketMQ  面试题"}],["meta",{"property":"og:description","content":"RocketMQ 面试题 多个 MQ 如何选型？ 为什么要使用 MQ？ 因为项目比较大，做了分布式系统，所有远程服务调用请求都是同步执行经常出问题，所 以引入了 MQ。 RocketMQ 由哪些角色组成，每个角色作用和特点是什么？ RocketMQ 中的 Topic 和 JMS 的 queue 有什么区别？ queue 就是来源于数据结构的 FIFO ..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2024-02-19T03:18:48.000Z"}],["meta",{"property":"article:modified_time","content":"2024-02-19T03:18:48.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"RocketMQ  面试题\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2024-02-19T03:18:48.000Z\\",\\"author\\":[]}"]]},"headers":[{"level":2,"title":"多个 MQ 如何选型？","slug":"多个-mq-如何选型","link":"#多个-mq-如何选型","children":[]},{"level":2,"title":"为什么要使用 MQ？","slug":"为什么要使用-mq","link":"#为什么要使用-mq","children":[]},{"level":2,"title":"RocketMQ 由哪些角色组成，每个角色作用和特点是什么？","slug":"rocketmq-由哪些角色组成-每个角色作用和特点是什么","link":"#rocketmq-由哪些角色组成-每个角色作用和特点是什么","children":[]},{"level":2,"title":"RocketMQ 中的 Topic 和 JMS 的 queue 有什么区别？","slug":"rocketmq-中的-topic-和-jms-的-queue-有什么区别","link":"#rocketmq-中的-topic-和-jms-的-queue-有什么区别","children":[]},{"level":2,"title":"RocketMQ 消费模式有几种？","slug":"rocketmq-消费模式有几种","link":"#rocketmq-消费模式有几种","children":[]},{"level":2,"title":"Broker 如何处理拉取请求的？","slug":"broker-如何处理拉取请求的","link":"#broker-如何处理拉取请求的","children":[]},{"level":2,"title":"RocketMQ 如何做负载均衡？","slug":"rocketmq-如何做负载均衡","link":"#rocketmq-如何做负载均衡","children":[]},{"level":2,"title":"消息重复消费","slug":"消息重复消费","link":"#消息重复消费","children":[]},{"level":2,"title":"RocketMQ 如何保证消息不丢失","slug":"rocketmq-如何保证消息不丢失","link":"#rocketmq-如何保证消息不丢失","children":[]},{"level":2,"title":"Producer 端如何保证消息不丢失","slug":"producer-端如何保证消息不丢失","link":"#producer-端如何保证消息不丢失","children":[]},{"level":2,"title":"Broker 端如何保证消息不丢失","slug":"broker-端如何保证消息不丢失","link":"#broker-端如何保证消息不丢失","children":[]},{"level":2,"title":"Consumer 端如何保证消息不丢失","slug":"consumer-端如何保证消息不丢失","link":"#consumer-端如何保证消息不丢失","children":[]},{"level":2,"title":"高吞吐量下如何优化生产者和消费者的性能?","slug":"高吞吐量下如何优化生产者和消费者的性能","link":"#高吞吐量下如何优化生产者和消费者的性能","children":[]}],"git":{"createdTime":1707812321000,"updatedTime":1708312728000,"contributors":[{"name":"xiaobai","email":"xiaobaidebug@gmail.com","commits":2}]},"readingTime":{"minutes":5.39,"words":1618},"filePathRelative":"中间件/rocketmq/面试题.md","localizedDate":"2024年2月13日","autoDesc":true}');export{d as comp,m as data};
