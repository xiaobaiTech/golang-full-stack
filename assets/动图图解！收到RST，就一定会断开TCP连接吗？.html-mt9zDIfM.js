import{_ as o}from"./plugin-vue_export-helper-DlAUqK2U.js";import{r as p,o as c,c as i,a as n,b as s,d as t,e}from"./app-CbjCfMt9.js";const r={},l=e(`<p>想必大家已经知道我的 niao 性，搞个标题，就是不喜欢立马回答。</p><p>就是要搞一大堆<strong>原理性</strong>的东西，再回答标题的问题。</p><p>说这个是因为我这次会把问题的答案就放到开头吗？</p><p>不！</p><p><strong>我就不！</strong></p><p>但是大家可以直接根据目录看自己感兴趣的部分。</p><p>之所以要先铺垫一些原理，还是希望大家能先看些基础的，再慢慢循序渐进，<strong>这样有利于建立知识体系</strong>。多一点上下文，少一点<code>gap</code>。</p><p>好了，进入正题。</p><p>下面是这篇文章的目录。</p><figure><img src="https://cdn.xiaobaidebug.top/image/收到RST就一定会断开连接吗1.png" alt="收到RST就一定会断开连接吗" tabindex="0" loading="lazy"><figcaption>收到RST就一定会断开连接吗</figcaption></figure><br><h2 id="什么是-rst" tabindex="-1"><a class="header-anchor" href="#什么是-rst"><span>什么是 RST</span></a></h2><p>我们都知道 TCP 正常情况下断开连接是用四次挥手，那是<strong>正常时候</strong>的优雅做法。</p><p>但<strong>异常情况</strong>下，收发双方都不一定正常，连挥手这件事本身都可能做不到，所以就需要一个机制去强行关闭连接。</p><p><strong>RST</strong> 就是用于这种情况，一般用来<strong>异常地</strong>关闭一个连接。它是一个 TCP 包头中的<strong>标志位</strong>。</p><p><strong>正常情况下</strong>，不管是<strong>发出</strong>，还是<strong>收到</strong>置了这个标志位的数据包，相应的内存、端口等连接资源都会被释放。从效果上来看就是 TCP 连接被关闭了。</p><p>而接收到 RST 的一方，一般会看到一个 <code>connection reset</code> 或 <code>connection refused</code> 的报错。</p><figure><img src="https://cdn.xiaobaidebug.top/image/tcp报头RST位.png" alt="TCP报头RST位" tabindex="0" loading="lazy"><figcaption>TCP报头RST位</figcaption></figure><br><h2 id="怎么知道收到-rst-了" tabindex="-1"><a class="header-anchor" href="#怎么知道收到-rst-了"><span>怎么知道收到 RST 了？</span></a></h2><p>我们知道<strong>内核</strong>跟<strong>应用层</strong>是分开的两层，网络通信功能在内核，我们的客户端或服务端属于应用层。应用层<strong>只能</strong>通过 <code>send/recv</code> 与内核交互，才能感知到内核是不是收到了<code>RST</code>。</p><p>当本端收到远端发来的<code>RST</code>后，<strong>内核</strong>已经认为此链接已经关闭。</p><p>此时如果本端<strong>应用层</strong>尝试去执行 <strong>读数据</strong>操作，比如<code>recv</code>，应用层就会收到 <strong>Connection reset by peer</strong> 的报错，意思是<strong>远端已经关闭连接</strong>。</p><figure><img src="https://cdn.xiaobaidebug.top/image/resetByPeer1.gif" alt="ResetByPeer" tabindex="0" loading="lazy"><figcaption>ResetByPeer</figcaption></figure><p>如果本端<strong>应用层</strong>尝试去执行<strong>写数据</strong>操作，比如<code>send</code>，那么应用层就会收到 <strong>Broken pipe</strong> 的报错，意思是发送通道已经坏了。</p><figure><img src="https://cdn.xiaobaidebug.top/image/brokenPipe1.gif" alt="BrokenPipe" tabindex="0" loading="lazy"><figcaption>BrokenPipe</figcaption></figure><p>这两个是开发过程中很经常遇到的报错，感觉大家可以<strong>把这篇文章放进收藏夹吃灰</strong>了，等遇到这个问题了，再打开来擦擦灰，说不定对你会有帮助。</p><br><h2 id="出现-rst-的场景有哪些" tabindex="-1"><a class="header-anchor" href="#出现-rst-的场景有哪些"><span>出现 RST 的场景有哪些</span></a></h2><p><strong>RST</strong>一般出现于异常情况，归类为 <strong>对端的端口不可用</strong> 和 <strong>socket 提前关闭</strong>。</p><br><h3 id="端口不可用" tabindex="-1"><a class="header-anchor" href="#端口不可用"><span>端口不可用</span></a></h3><p>端口不可用分为两种情况。要么是这个端口从来就没有&quot;可用&quot;过，比如根本就没监听**（listen）<strong>过；要么就是曾经&quot;可用&quot;，但现在&quot;不可用&quot;了，比如服务</strong>突然崩**了。</p><h4 id="端口未监听" tabindex="-1"><a class="header-anchor" href="#端口未监听"><span>端口未监听</span></a></h4><figure><img src="https://cdn.xiaobaidebug.top/image/TCP连接未监听的端口.png" alt="TCP连接未监听的端口" tabindex="0" loading="lazy"><figcaption>TCP连接未监听的端口</figcaption></figure><p>服务端<code>listen</code> 方法会创建一个<code>sock</code>放入到全局的<code>哈希表</code>中。</p><p>此时客户端发起一个<code>connect</code>请求到服务端。服务端在收到数据包之后，第一时间会根据 IP 和端口从哈希表里去获取<code>sock</code>。</p><figure><img src="https://cdn.xiaobaidebug.top/image/全局hash表.png" alt="全局hash表" tabindex="0" loading="lazy"><figcaption>全局hash表</figcaption></figure><p>如果服务端执行过<code>listen</code>，就能从<code>全局哈希表</code>里拿到<code>sock</code>。</p><p>但如果服务端没有执行过<code>listen</code>，那<code>哈希表</code>里也就不会有对应的<code>sock</code>，结果当然是拿不到。此时，<strong>正常情况下</strong>服务端会发<code>RST</code>给客户端。</p><br><h5 id="端口未监听就一定会发-rst-吗" tabindex="-1"><a class="header-anchor" href="#端口未监听就一定会发-rst-吗"><span>端口未监听就一定会发 RST 吗？</span></a></h5><p><strong>不一定</strong>。上面提到，发 RST 的前提是<strong>正常情况下</strong>，我们看下源码。</p><div class="language-c line-numbers-mode" data-ext="c" data-title="c"><pre class="language-c"><code><span class="token comment">// net/ipv4/tcp_ipv4.c</span>
<span class="token comment">// 代码经过删减</span>
<span class="token keyword">int</span> <span class="token function">tcp_v4_rcv</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">sk_buff</span> <span class="token operator">*</span>skb<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token comment">// 根据ip、端口等信息 获取sock。</span>
	sk <span class="token operator">=</span> <span class="token function">__inet_lookup_skb</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>tcp_hashinfo<span class="token punctuation">,</span> skb<span class="token punctuation">,</span> th<span class="token operator">-&gt;</span>source<span class="token punctuation">,</span> th<span class="token operator">-&gt;</span>dest<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>sk<span class="token punctuation">)</span>
		<span class="token keyword">goto</span> no_tcp_socket<span class="token punctuation">;</span>

no_tcp_socket<span class="token operator">:</span>
    <span class="token comment">// 检查数据包有没有出错</span>
	<span class="token keyword">if</span> <span class="token punctuation">(</span>skb<span class="token operator">-&gt;</span>len <span class="token operator">&lt;</span> <span class="token punctuation">(</span>th<span class="token operator">-&gt;</span>doff <span class="token operator">&lt;&lt;</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token operator">||</span> <span class="token function">tcp_checksum_complete</span><span class="token punctuation">(</span>skb<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// 错误记录</span>
	<span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
        <span class="token comment">// 发送RST</span>
		<span class="token function">tcp_v4_send_reset</span><span class="token punctuation">(</span><span class="token constant">NULL</span><span class="token punctuation">,</span> skb<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>内核在收到数据后会从物理层、数据链路层、网络层、传输层、应用层，一层一层往上传递。到传输层的时候，根据当前数据包的协议是<strong>TCP 还是 UDP</strong>走不一样的函数方法。可以简单认为，<strong>TCP</strong>数据包都会走到 <code>tcp_v4_rcv()</code>。 这个方法会从<code>全局哈希表</code>里获取 <code>sock</code>，如果此时服务端没有<code>listen()</code>过 , 那肯定获取不了<code>sock</code>，会跳转到<code>no_tcp_socket</code>的逻辑。</p><p>注意这里会先走一个 <code>tcp_checksum_complete()</code>，目的是看看数据包的**校验和(Checksum)**是否合法。</p><br><blockquote><p><strong>校验和</strong>可以验证数据从端到端的传输中是否出现异常。由发送端计算，然后由接收端验证。计算范围覆盖数据包里的 TCP 首部和 TCP 数据。</p></blockquote><br><p>如果在发送端到接收端传输过程中，数据发生<strong>任何改动</strong>，比如被第三方篡改，那么接收方能检测到校验和有差错，此时 TCP 段会被直接丢弃。如果校验和没问题，那才会发 RST。</p><p>所以，<strong>只有在数据包没问题的情况下，比如校验和没问题，才会发 RST 包给对端。</strong></p><br><h5 id="为什么数据包异常的情况下-不发-rst" tabindex="-1"><a class="header-anchor" href="#为什么数据包异常的情况下-不发-rst"><span>为什么数据包异常的情况下，不发 RST？</span></a></h5><p>一个数据包连校验都不能通过，那这个包，<strong>多半有问题</strong>。</p><figure><img src="https://cdn.xiaobaidebug.top/image/006cSBLKly1gl6b731molj306405q74a.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>有可能是在发送的过程中被篡改了，又或者，可能只是一个<strong>胡乱伪造</strong>的数据包。</p><p><strong>五层网络，不管是哪一层</strong>，只要遇到了这种数据，<strong>推荐的做法都是默默扔掉</strong>，<strong>而不是</strong>去回复一个消息告诉对方数据有问题。</p><p>如果对方用的是 TCP，是可靠传输协议，发现很久没有<code>ACK</code>响应，自己就会重传。</p><p>如果对方用的是 UDP，说明发送端已经接受了“不可靠会丢包”的事实，那丢了就丢了。</p><p>因此，数据包异常的情况下，默默扔掉，不发<code>RST</code>，非常合理。</p><br><figure><img src="https://cdn.xiaobaidebug.top/image/006i487Uly1fgqbcncf3gj30b40b43z0-20210908211826494.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>还是不能理解？那我<strong>再举个例子</strong>。</p><p>正常人喷你，他说话<strong>条理清晰，主谓宾分明</strong>。此时你喷回去，那你是个充满热情，正直，富有判断力的好人。</p><p>而此时一个憨憨也想喷你，但他<strong>思维混乱，连话都说不清楚，一直阿巴阿巴</strong>的，你虽然听不懂，但<strong>大受震撼</strong>，此时你会？</p><ul><li><p>A：跟他激情互喷</p></li><li><p>B：不跟他一般见识，就当没听过</p></li></ul><p>一般来说<strong>最优选择是 B</strong>，毕竟你理他，他反而来劲。</p><p>这下，应该就懂了。</p><figure><img src="https://cdn.xiaobaidebug.top/image/006m97Kgly1fxtp35bi77j315o15o4qp.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><br><h4 id="程序启动了但是崩了" tabindex="-1"><a class="header-anchor" href="#程序启动了但是崩了"><span>程序启动了但是崩了</span></a></h4><p>端口不可用的场景里，除了端口未监听以外，还有可能是从前监听了，但服务端机器上做监听操作的<strong>应用程序突然崩了</strong>，此时客户端还像往常一样正常发送消息，服务器内核协议栈收到消息后，则会<strong>回一个 RST</strong>。在开发过程中，<strong>这种情况是最常见的</strong>。</p><p>比如你的服务端应用程序里，弄了个<strong>空指针</strong>，或者<strong>数组越界</strong>啥的，程序立马就崩了。</p><figure><img src="https://cdn.xiaobaidebug.top/image/TCP监听了但崩了3.png" alt="TCP监听了但崩了" tabindex="0" loading="lazy"><figcaption>TCP监听了但崩了</figcaption></figure><p>这种情况跟<strong>端口未监听</strong>本质上类似，在服务端的应用程序<strong>崩溃后</strong>，原来监听的端口资源就被释放了，从效果上来看，类似于处于<code>CLOSED</code>状态。</p><p>此时服务端又收到了客户端发来的消息，内核协议栈会根据<strong>IP 端口</strong>，从全局哈希表里查找<code>sock</code>，结果当然是拿不到对应的<code>sock</code>数据，于是走了跟上面**&quot;端口未监听&quot;<strong>时一样的逻辑，回了个<code>RST</code>。客户端在收到 RST 后也</strong>释放了 sock 资源**，从效果上来看，就是<strong>连接断了</strong>。</p><h5 id="rst-和-502-的关系" tabindex="-1"><a class="header-anchor" href="#rst-和-502-的关系"><span>RST 和 502 的关系</span></a></h5><p>上面这张图，服务端程序崩溃后，如果客户端再有数据发送，会出现<code>RST</code>。但如果在客户端和服务端中间再加一个<code>nginx</code>，就像下图一样。</p><figure><img src="https://cdn.xiaobaidebug.top/image/RST与5021.png" alt="RST与502" tabindex="0" loading="lazy"><figcaption>RST与502</figcaption></figure><p><code>nginx</code>会作为客户端和服务端之间的&quot;中间人角色&quot;，负责<strong>转发</strong>请求和响应结果。但当服务端程序<strong>崩溃</strong>，比如出现<strong>野指针或者 OOM</strong>的问题，那转发到服务器的请求，必然得不到响应，后端服务端还会返回一个<code>RST</code>给<code>nginx</code>。<code>nginx</code>在收到这个<code>RST</code>后会断开与服务端的连接，同时返回客户端一个<code>502</code>错误码。</p><p>所以，出现 502 问题，一般情况下都是因为后端程序崩了，基于这一点假设，去看看监控是不是发生了 OOM 或者日志是否有空指针等报错信息。</p><br><h3 id="socket-提前关闭" tabindex="-1"><a class="header-anchor" href="#socket-提前关闭"><span>socket 提前关闭</span></a></h3><p>这种情况分为<strong>本端</strong>提前关闭，和<strong>远端</strong>提前关闭。</p><h4 id="本端提前关闭" tabindex="-1"><a class="header-anchor" href="#本端提前关闭"><span>本端提前关闭</span></a></h4><p>如果本端<code>socket</code>接收缓冲区<strong>还有数据未读</strong>，此时<strong>提前<code>close()</code> socket</strong>。那么本端会先把接收缓冲区的数据清空，然后给远端发一个 RST。</p><figure><img src="https://cdn.xiaobaidebug.top/image/recvbuf非空.gif" alt="recvbuf非空" tabindex="0" loading="lazy"><figcaption>recvbuf非空</figcaption></figure><br><h4 id="远端提前关闭" tabindex="-1"><a class="header-anchor" href="#远端提前关闭"><span>远端提前关闭</span></a></h4><p>远端已经<code>close()</code>了<code>socket</code>，此时本端还尝试发数据给远端。那么远端就会回一个 RST。</p><figure><img src="https://cdn.xiaobaidebug.top/image/close()触发TCP四次挥手5-20210828083457512.png" alt="close()触发TCP四次挥手" tabindex="0" loading="lazy"><figcaption>close()触发TCP四次挥手</figcaption></figure><p>大家知道，TCP 是<strong>全双工通信</strong>，意思是发送数据的同时，还可以接收数据。</p><p><code>Close()</code>的含义是，此时要同时<strong>关闭发送和接收</strong>消息的功能。</p><p>客户端执行<code>close()</code>， 正常情况下，会发出<strong>第一次</strong>挥手 FIN，然后服务端回<strong>第二次</strong>挥手 ACK。如果在<strong>第二次和第三次挥手之间</strong>，如果服务方还尝试传数据给客户端，那么客户端不仅不收这个消息，还会发一个 RST 消息到服务端。直接结束掉这次连接。</p><br><h2 id="对方没收到-rst-会怎么样" tabindex="-1"><a class="header-anchor" href="#对方没收到-rst-会怎么样"><span>对方没收到 RST，会怎么样？</span></a></h2><p>我们知道 TCP 是可靠传输，意味着本端发一个数据，远端在收到这个数据后就会回一个<code>ACK</code>，意思是&quot;我收到这个包了&quot;。</p><p><strong>而 RST，不需要 ACK 确认包</strong>。</p><p>因为<code>RST</code>本来就是设计来处理异常情况的，既然都已经在异常情况下了，还指望对方能正常回你一个<code>ACK</code>吗？<strong>可以幻想，不要妄想。</strong></p><p>但<strong>问题又来了</strong>，网络环境这么复杂，丢包也是分分钟的事情，既然 RST 包不需要 ACK 来确认，那万一对方就是没收到 RST，会怎么样？</p><figure><img src="https://cdn.xiaobaidebug.top/image/RST丢失3.png" alt="RST丢失" tabindex="0" loading="lazy"><figcaption>RST丢失</figcaption></figure><p>RST 丢了，问题不大。比方说上图服务端，发了 RST 之后，服务端就认为连接不可用了。</p><p>如果客户端之前<strong>发送了数据</strong>，一直没等到这个数据的确认 ACK，就会重发，重发的时候，自然就会触发一个新的 RST 包。</p><p>而如果客户端之前<strong>没有发数据</strong>，但服务端的 RST 丢了，TCP 有个 keepalive 机制，会定期发送探活包，这种数据包到了服务端，也会重新触发一个 RST。</p><figure><img src="https://cdn.xiaobaidebug.top/image/RST丢失后keepalive2.png" alt="RST丢失后keepalive" tabindex="0" loading="lazy"><figcaption>RST丢失后keepalive</figcaption></figure><br><h2 id="收到-rst-就一定会断开连接吗" tabindex="-1"><a class="header-anchor" href="#收到-rst-就一定会断开连接吗"><span>收到 RST 就一定会断开连接吗?</span></a></h2><p>先说结论，<strong>不一定会断开</strong>。我们看下源码。</p><div class="language-c line-numbers-mode" data-ext="c" data-title="c"><pre class="language-c"><code><span class="token comment">// net/ipv4/tcp_input.c</span>
<span class="token keyword">static</span> bool <span class="token function">tcp_validate_incoming</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
	<span class="token comment">// 获取sock</span>
	<span class="token keyword">struct</span> <span class="token class-name">tcp_sock</span> <span class="token operator">*</span>tp <span class="token operator">=</span> <span class="token function">tcp_sk</span><span class="token punctuation">(</span>sk<span class="token punctuation">)</span><span class="token punctuation">;</span>

	<span class="token comment">// step 1：先判断seq是否合法（是否在合法接收窗口范围内）</span>
	<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">tcp_sequence</span><span class="token punctuation">(</span>tp<span class="token punctuation">,</span> <span class="token function">TCP_SKB_CB</span><span class="token punctuation">(</span>skb<span class="token punctuation">)</span><span class="token operator">-&gt;</span>seq<span class="token punctuation">,</span> <span class="token function">TCP_SKB_CB</span><span class="token punctuation">(</span>skb<span class="token punctuation">)</span><span class="token operator">-&gt;</span>end_seq<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
		<span class="token keyword">goto</span> discard<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>

	<span class="token comment">// step 2：执行收到 RST 后该干的事情</span>
	<span class="token keyword">if</span> <span class="token punctuation">(</span>th<span class="token operator">-&gt;</span>rst<span class="token punctuation">)</span> <span class="token punctuation">{</span>
		<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">TCP_SKB_CB</span><span class="token punctuation">(</span>skb<span class="token punctuation">)</span><span class="token operator">-&gt;</span>seq <span class="token operator">==</span> tp<span class="token operator">-&gt;</span>rcv_nxt<span class="token punctuation">)</span>
			<span class="token function">tcp_reset</span><span class="token punctuation">(</span>sk<span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token keyword">else</span>
			<span class="token function">tcp_send_challenge_ack</span><span class="token punctuation">(</span>sk<span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token keyword">goto</span> discard<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>收到 RST 包，第一步会通过<code>tcp_sequence</code>先看下这个 seq 是否合法，其实主要是看下这个 seq 是否在合法<strong>接收窗口</strong>范围内。<strong>如果不在范围内，这个 RST 包就会被丢弃。</strong></p><p>至于接收窗口是个啥，我们先看下面这个图。</p><figure><img src="https://cdn.xiaobaidebug.top/image/接收窗口.png" alt="接收窗口" tabindex="0" loading="lazy"><figcaption>接收窗口</figcaption></figure><p>这里<strong>黄色的部分</strong>，就是指接收窗口，只要 RST 包的 seq 不在这个窗口范围内，那就会被丢弃。</p><br><h3 id="为什么要校验是否在窗口范围内" tabindex="-1"><a class="header-anchor" href="#为什么要校验是否在窗口范围内"><span>为什么要校验是否在窗口范围内</span></a></h3><p>正常情况下客户端服务端双方可以通过 RST 来断开连接。假设不做 seq 校验，如果这时候有不怀好意的第三方介入，构造了一个 RST 包，且在 TCP 和 IP 等报头都填上客户端的信息，发到服务端，那么服务端就会断开这个连接。同理也可以伪造服务端的包发给客户端。这就叫<strong>RST 攻击</strong>。</p><figure><img src="https://cdn.xiaobaidebug.top/image/RST攻击.png" alt="RST攻击" tabindex="0" loading="lazy"><figcaption>RST攻击</figcaption></figure><p>受到 RST 攻击时，从现象上看，客户端老感觉服务端崩了，这非常影响用户体验。</p><p>如果这是个游戏，我相信多崩几次，第二天大家就不来玩了。</p><p>实际消息发送过程中，接收窗口是不断移动的，seq 也是在飞快的变动中，此时第三方是<strong>比较难</strong>构造出合法 seq 的 RST 包的，那么通过这个 seq 校验，就可以拦下了很多不合法的消息。</p><br><h3 id="加了窗口校验就不能用-rst-攻击了吗" tabindex="-1"><a class="header-anchor" href="#加了窗口校验就不能用-rst-攻击了吗"><span>加了窗口校验就不能用 RST 攻击了吗</span></a></h3><p>**不是，只是增加了攻击的成本。**但如果想搞，还是可搞的。</p><p>以下是<strong>面向监狱编程</strong>的环节。</p><p>希望大家只<strong>了解原理</strong>就好了，<strong>不建议使用</strong>。</p><p>相信大家都不喜欢穿着蓝白条纹的衣服，拍<strong>纯狱风</strong>的照片。</p><p>从上面可以知道，不是每一个 RST 包都会导致连接重置的，要求是这个 RST 包的 seq 要在窗口范围内，所以，问题就变成了，<strong>我们怎么样才能构造出合法的 seq</strong>。</p><br><h4 id="盲猜-seq" tabindex="-1"><a class="header-anchor" href="#盲猜-seq"><span>盲猜 seq</span></a></h4><p>窗口数值 seq 本质上只是个 uint32 类型。</p><div class="language-c line-numbers-mode" data-ext="c" data-title="c"><pre class="language-c"><code><span class="token keyword">struct</span> <span class="token class-name">tcp_skb_cb</span> <span class="token punctuation">{</span>
	__u32		seq<span class="token punctuation">;</span>		<span class="token comment">/* Starting sequence number	*/</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>如果在这个范围内疯狂猜测 seq 数值，并构造对应的包，发到目的机器，虽然概率低，但是总是能被试出来，从而实现<strong>RST 攻击</strong>。这种乱棍打死老师傅的方式，就是所谓的<strong>合法窗口盲打（blind in-window attacks）</strong>。</p><p>觉得这种方式比较<strong>笨</strong>？那有没有聪明点的方式，还真有，但是在这之前需要先看下面的这个问题。</p><br><h4 id="已连接状态下收到第一次握手包会怎么样" tabindex="-1"><a class="header-anchor" href="#已连接状态下收到第一次握手包会怎么样"><span>已连接状态下收到第一次握手包会怎么样？</span></a></h4><p>我们需要了解一个问题，比如服务端在已连接（<code>ESTABLISHED</code>）状态下，如果收到客户端发来的第一次握手包（<code>SYN</code>），会怎么样？</p><p>以前我以为<strong>服务单会认为客户端憨憨了，直接 RST 连接。</strong></p><p><strong>但实际，并不是</strong>。</p><div class="language-c line-numbers-mode" data-ext="c" data-title="c"><pre class="language-c"><code><span class="token keyword">static</span> bool <span class="token function">tcp_validate_incoming</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
	<span class="token keyword">struct</span> <span class="token class-name">tcp_sock</span> <span class="token operator">*</span>tp <span class="token operator">=</span> <span class="token function">tcp_sk</span><span class="token punctuation">(</span>sk<span class="token punctuation">)</span><span class="token punctuation">;</span>

	<span class="token comment">/* 判断seq是否在合法窗口内 */</span>
	<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">tcp_sequence</span><span class="token punctuation">(</span>tp<span class="token punctuation">,</span> <span class="token function">TCP_SKB_CB</span><span class="token punctuation">(</span>skb<span class="token punctuation">)</span><span class="token operator">-&gt;</span>seq<span class="token punctuation">,</span> <span class="token function">TCP_SKB_CB</span><span class="token punctuation">(</span>skb<span class="token punctuation">)</span><span class="token operator">-&gt;</span>end_seq<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
		<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>th<span class="token operator">-&gt;</span>rst<span class="token punctuation">)</span> <span class="token punctuation">{</span>
			<span class="token comment">// 收到一个不在合法窗口内的SYN包</span>
			<span class="token keyword">if</span> <span class="token punctuation">(</span>th<span class="token operator">-&gt;</span>syn<span class="token punctuation">)</span>
				<span class="token keyword">goto</span> syn_challenge<span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
	<span class="token punctuation">}</span>

	<span class="token comment">/*
	 * RFC 5691 4.2 : 发送 challenge ack
	 */</span>
	<span class="token keyword">if</span> <span class="token punctuation">(</span>th<span class="token operator">-&gt;</span>syn<span class="token punctuation">)</span> <span class="token punctuation">{</span>
syn_challenge<span class="token operator">:</span>
		<span class="token function">tcp_send_challenge_ack</span><span class="token punctuation">(</span>sk<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>当客户端发出一个不在合法窗口内的 SYN 包的时候，服务端会发一个带有正确的 seq 数据 ACK 包出来，这个 ACK 包叫 <code>challenge ack</code>。</p><figure><img src="https://cdn.xiaobaidebug.top/image/image-20210901085509641.png" alt="challenge ack抓包" tabindex="0" loading="lazy"><figcaption>challenge ack抓包</figcaption></figure><p>上图是抓包的结果，用<code>scapy</code>随便伪造一个<code>seq=5</code>的包发到服务端（<code>端口9090</code>），服务端回复一个带有正确 seq 值的<code>challenge ack</code>包给客户端（<code>端口8888</code>）。</p><br><h4 id="利用-challenge-ack-获取-seq" tabindex="-1"><a class="header-anchor" href="#利用-challenge-ack-获取-seq"><span>利用 challenge ack 获取 seq</span></a></h4><p>上面提到的<strong>这个 challenge ack ，仿佛为盲猜 seq 的老哥们打开了一个新世界。</strong></p><p>在获得这个<code>challenge ack</code>后，攻击程序就可以以 ack 值为基础，在一定范围内设置 seq，这样造成 RST 攻击的几率就大大增加了。</p><figure><img src="https://cdn.xiaobaidebug.top/image/利用ChallengeACK的RST攻击.png" alt="利用ChallengeACK的RST攻击" tabindex="0" loading="lazy"><figcaption>利用ChallengeACK的RST攻击</figcaption></figure><br><h2 id="总结" tabindex="-1"><a class="header-anchor" href="#总结"><span>总结</span></a></h2><ul><li>RST 其实是 TCP 包头里的一个标志位，目的是为了在<strong>异常情况</strong>下关闭连接。</li><li>内核收到 RST 后，应用层只能通过调用读/写操作来感知，此时会对应获得 <strong>Connection reset by peer</strong> 和<strong>Broken pipe</strong> 报错。</li><li>发出 RST 后不需要得到对方的 ACK 确认包，因此 RST 丢失后对方不能立刻感知，但是通过下一次<strong>重传</strong>数据或 keepalive<strong>心跳包</strong>可以导致 RST 重传。</li><li>**收到 RST 包，不一定会断开连接，seq 不在合法窗口范围内的数据包会被默默丢弃。**通过构造合法窗口范围内 seq，可以造成 RST 攻击，<strong>这一点大家了解就好，千万别学！</strong></li></ul><br><h2 id="参考资料" tabindex="-1"><a class="header-anchor" href="#参考资料"><span>参考资料</span></a></h2>`,152),d={href:"https://www.cxyzjd.com/article/qq_27446553/52416369",target:"_blank",rel:"noopener noreferrer"},g=e('<br><h2 id="最后" tabindex="-1"><a class="header-anchor" href="#最后"><span>最后</span></a></h2><p>最近想用<code>vscode</code>写小说了，故事梗概都想好了。</p><blockquote><p>十年前，他是大厂最年轻 CTO，闭眼刷 leetcode，敲代码 0 error ，0 warning， 却被诬陷删库跑路，锒铛入狱，众叛亲离……十年后，他重新归来！却看到自己的女儿在仇人公司里修 bug！</p><p>&quot;我要你付出代价！&quot;</p><p>一声令下，十万 <code>p7，p8</code> 应声前来.......</p></blockquote><p><strong>爽否？</strong></p><br><p><strong>如果文章对你有帮助，欢迎.....</strong></p><p>算了。</p><p>兄弟们都是自家人，点不<strong>点赞</strong>，在不<strong>在看</strong>什么的，没关系的，大家看开心了就好。</p><p><strong>在看，点赞</strong>什么的，我不是特别在意，真的，真的，别不信啊。</p><p>不三连也真的没关系的。</p><p>兄弟们不要在意啊。</p><p>我是<strong>虚伪</strong>的小白，我们下期见！</p><br><h5 id="别说了-一起在知识的海洋里呛水吧" tabindex="-1"><a class="header-anchor" href="#别说了-一起在知识的海洋里呛水吧"><span>别说了，一起在知识的海洋里呛水吧</span></a></h5><p><strong>点击</strong>下方名片，关注公众号:【小白 debug】<br><img src="https://cdn.xiaobaidebug.top/1696069689495.png" alt="" loading="lazy"></p><br><p>不满足于在留言区说骚话？</p><p>加我，我们建了个划水吹牛皮群，在群里，你可以跟你下次跳槽可能遇到的同事或面试官聊点阳间的话题。就<strong>超！开！心！</strong></p><img src="https://cdn.xiaobaidebug.top/image-20220522162616202.png" width="50%" align="center"><h2 id="文章推荐" tabindex="-1"><a class="header-anchor" href="#文章推荐"><span>文章推荐：</span></a></h2>',21),u={href:"https://www.xiaobaidebug.top/2022/07/19/%E5%9B%BE%E8%A7%A3%E7%BD%91%E7%BB%9C/%E6%97%A2%E7%84%B6%E6%9C%89HTTP%E5%8D%8F%E8%AE%AE%EF%BC%8C%E4%B8%BA%E4%BB%80%E4%B9%88%E8%BF%98%E8%A6%81%E6%9C%89RPC%E5%8D%8F%E8%AE%AE%EF%BC%9F/",target:"_blank",rel:"noopener noreferrer"},k={href:"https://www.xiaobaidebug.top/2021/03/26/%E5%9B%BE%E8%A7%A3%E7%BD%91%E7%BB%9C/TCP%E7%B2%98%E5%8C%85%EF%BC%81%E6%95%B0%E6%8D%AE%E5%8C%85%EF%BC%9A%E6%88%91%E5%8F%AA%E6%98%AF%E7%8A%AF%E4%BA%86%E6%AF%8F%E4%B8%AA%E6%95%B0%E6%8D%AE%E5%8C%85%E9%83%BD%E4%BC%9A%E7%8A%AF%E7%9A%84%E9%94%99%EF%BC%8C%E7%A1%AC%E6%A0%B8%E5%9B%BE%E8%A7%A3/",target:"_blank",rel:"noopener noreferrer"},b={href:"https://www.xiaobaidebug.top/2021/05/25/%E5%9B%BE%E8%A7%A3%E7%BD%91%E7%BB%9C/%E5%8A%A8%E5%9B%BE%E5%9B%BE%E8%A7%A3%EF%BC%81%E6%97%A2%E7%84%B6IP%E5%B1%82%E4%BC%9A%E5%88%86%E7%89%87%EF%BC%8C%E4%B8%BA%E4%BB%80%E4%B9%88TCP%E5%B1%82%E4%B9%9F%E8%BF%98%E8%A6%81%E5%88%86%E6%AE%B5%EF%BC%9F/",target:"_blank",rel:"noopener noreferrer"};function h(m,E){const a=p("ExternalLinkIcon");return c(),i("div",null,[l,n("p",null,[s("TCP 旁路攻击分析与重现 - "),n("a",d,[s("https://www.cxyzjd.com/article/qq_27446553/52416369"),t(a)])]),g,n("ul",null,[n("li",null,[n("a",u,[s("既然有 HTTP 协议，为什么还要有 RPC"),t(a)])]),n("li",null,[n("a",k,[s("TCP 粘包 数据包：我只是犯了每个数据包都会犯的错 |硬核图解"),t(a)])]),n("li",null,[n("a",b,[s("动图图解！既然 IP 层会分片，为什么 TCP 层也还要分段？"),t(a)])])])])}const B=o(r,[["render",h],["__file","动图图解！收到RST，就一定会断开TCP连接吗？.html.vue"]]),f=JSON.parse('{"path":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/%E6%A0%B8%E5%BF%83%E7%9F%A5%E8%AF%86%E7%82%B9/%E5%8A%A8%E5%9B%BE%E5%9B%BE%E8%A7%A3%EF%BC%81%E6%94%B6%E5%88%B0RST%EF%BC%8C%E5%B0%B1%E4%B8%80%E5%AE%9A%E4%BC%9A%E6%96%AD%E5%BC%80TCP%E8%BF%9E%E6%8E%A5%E5%90%97%EF%BC%9F.html","title":"动图图解！收到RST，就一定会断开TCP连接吗？","lang":"zh-CN","frontmatter":{"title":"动图图解！收到RST，就一定会断开TCP连接吗？","date":"2021-09-01T22:57:55.000Z","tags":null,"categories":"图解网络","description":"想必大家已经知道我的 niao 性，搞个标题，就是不喜欢立马回答。 就是要搞一大堆原理性的东西，再回答标题的问题。 说这个是因为我这次会把问题的答案就放到开头吗？ 不！ 我就不！ 但是大家可以直接根据目录看自己感兴趣的部分。 之所以要先铺垫一些原理，还是希望大家能先看些基础的，再慢慢循序渐进，这样有利于建立知识体系。多一点上下文，少一点gap。 好了，...","head":[["meta",{"property":"og:url","content":"https://golangguide.top/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/%E6%A0%B8%E5%BF%83%E7%9F%A5%E8%AF%86%E7%82%B9/%E5%8A%A8%E5%9B%BE%E5%9B%BE%E8%A7%A3%EF%BC%81%E6%94%B6%E5%88%B0RST%EF%BC%8C%E5%B0%B1%E4%B8%80%E5%AE%9A%E4%BC%9A%E6%96%AD%E5%BC%80TCP%E8%BF%9E%E6%8E%A5%E5%90%97%EF%BC%9F.html"}],["meta",{"property":"og:site_name","content":"golang全栈指南"}],["meta",{"property":"og:title","content":"动图图解！收到RST，就一定会断开TCP连接吗？"}],["meta",{"property":"og:description","content":"想必大家已经知道我的 niao 性，搞个标题，就是不喜欢立马回答。 就是要搞一大堆原理性的东西，再回答标题的问题。 说这个是因为我这次会把问题的答案就放到开头吗？ 不！ 我就不！ 但是大家可以直接根据目录看自己感兴趣的部分。 之所以要先铺垫一些原理，还是希望大家能先看些基础的，再慢慢循序渐进，这样有利于建立知识体系。多一点上下文，少一点gap。 好了，..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:image","content":"https://cdn.xiaobaidebug.top/image/收到RST就一定会断开连接吗1.png"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2024-02-19T03:57:35.000Z"}],["meta",{"name":"twitter:card","content":"summary_large_image"}],["meta",{"name":"twitter:image:alt","content":"动图图解！收到RST，就一定会断开TCP连接吗？"}],["meta",{"property":"article:author","content":"小白debug"}],["meta",{"property":"article:published_time","content":"2021-09-01T22:57:55.000Z"}],["meta",{"property":"article:modified_time","content":"2024-02-19T03:57:35.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"动图图解！收到RST，就一定会断开TCP连接吗？\\",\\"image\\":[\\"https://cdn.xiaobaidebug.top/image/收到RST就一定会断开连接吗1.png\\",\\"https://cdn.xiaobaidebug.top/image/tcp报头RST位.png\\",\\"https://cdn.xiaobaidebug.top/image/resetByPeer1.gif\\",\\"https://cdn.xiaobaidebug.top/image/brokenPipe1.gif\\",\\"https://cdn.xiaobaidebug.top/image/TCP连接未监听的端口.png\\",\\"https://cdn.xiaobaidebug.top/image/全局hash表.png\\",\\"https://cdn.xiaobaidebug.top/image/006cSBLKly1gl6b731molj306405q74a.jpg\\",\\"https://cdn.xiaobaidebug.top/image/006i487Uly1fgqbcncf3gj30b40b43z0-20210908211826494.jpg\\",\\"https://cdn.xiaobaidebug.top/image/006m97Kgly1fxtp35bi77j315o15o4qp.jpg\\",\\"https://cdn.xiaobaidebug.top/image/TCP监听了但崩了3.png\\",\\"https://cdn.xiaobaidebug.top/image/RST与5021.png\\",\\"https://cdn.xiaobaidebug.top/image/recvbuf非空.gif\\",\\"https://cdn.xiaobaidebug.top/image/RST丢失3.png\\",\\"https://cdn.xiaobaidebug.top/image/RST丢失后keepalive2.png\\",\\"https://cdn.xiaobaidebug.top/image/接收窗口.png\\",\\"https://cdn.xiaobaidebug.top/image/RST攻击.png\\",\\"https://cdn.xiaobaidebug.top/image/image-20210901085509641.png\\",\\"https://cdn.xiaobaidebug.top/image/利用ChallengeACK的RST攻击.png\\",\\"https://cdn.xiaobaidebug.top/1696069689495.png\\"],\\"datePublished\\":\\"2021-09-01T22:57:55.000Z\\",\\"dateModified\\":\\"2024-02-19T03:57:35.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"小白debug\\",\\"url\\":\\"https://xiaobaidebug.top/\\"}]}"],["link",{"rel":"canonical","href":"https://golangguide.top/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/%E6%A0%B8%E5%BF%83%E7%9F%A5%E8%AF%86%E7%82%B9/%E5%8A%A8%E5%9B%BE%E5%9B%BE%E8%A7%A3%EF%BC%81%E6%94%B6%E5%88%B0RST%EF%BC%8C%E5%B0%B1%E4%B8%80%E5%AE%9A%E4%BC%9A%E6%96%AD%E5%BC%80TCP%E8%BF%9E%E6%8E%A5%E5%90%97%EF%BC%9F.html"}],["meta",{"property":"og:url","content":"https://golangguide.top/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/%E6%A0%B8%E5%BF%83%E7%9F%A5%E8%AF%86%E7%82%B9/%E5%8A%A8%E5%9B%BE%E5%9B%BE%E8%A7%A3%EF%BC%81%E6%94%B6%E5%88%B0RST%EF%BC%8C%E5%B0%B1%E4%B8%80%E5%AE%9A%E4%BC%9A%E6%96%AD%E5%BC%80TCP%E8%BF%9E%E6%8E%A5%E5%90%97%EF%BC%9F.html"}],["meta",{"property":"og:site_name","content":"golang全栈指南"}],["meta",{"property":"og:title","content":"动图图解！收到RST，就一定会断开TCP连接吗？"}],["meta",{"property":"og:description","content":"想必大家已经知道我的 niao 性，搞个标题，就是不喜欢立马回答。 就是要搞一大堆原理性的东西，再回答标题的问题。 说这个是因为我这次会把问题的答案就放到开头吗？ 不！ 我就不！ 但是大家可以直接根据目录看自己感兴趣的部分。 之所以要先铺垫一些原理，还是希望大家能先看些基础的，再慢慢循序渐进，这样有利于建立知识体系。多一点上下文，少一点gap。 好了，..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2024-02-19T03:57:35.000Z"}],["meta",{"property":"article:published_time","content":"2021-09-01T22:57:55.000Z"}],["meta",{"property":"article:modified_time","content":"2024-02-19T03:57:35.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"动图图解！收到RST，就一定会断开TCP连接吗？\\",\\"image\\":[\\"\\"],\\"datePublished\\":\\"2021-09-01T22:57:55.000Z\\",\\"dateModified\\":\\"2024-02-19T03:57:35.000Z\\",\\"author\\":[]}"]]},"headers":[{"level":2,"title":"什么是 RST","slug":"什么是-rst","link":"#什么是-rst","children":[]},{"level":2,"title":"怎么知道收到 RST 了？","slug":"怎么知道收到-rst-了","link":"#怎么知道收到-rst-了","children":[]},{"level":2,"title":"出现 RST 的场景有哪些","slug":"出现-rst-的场景有哪些","link":"#出现-rst-的场景有哪些","children":[{"level":3,"title":"端口不可用","slug":"端口不可用","link":"#端口不可用","children":[]},{"level":3,"title":"socket 提前关闭","slug":"socket-提前关闭","link":"#socket-提前关闭","children":[]}]},{"level":2,"title":"对方没收到 RST，会怎么样？","slug":"对方没收到-rst-会怎么样","link":"#对方没收到-rst-会怎么样","children":[]},{"level":2,"title":"收到 RST 就一定会断开连接吗?","slug":"收到-rst-就一定会断开连接吗","link":"#收到-rst-就一定会断开连接吗","children":[{"level":3,"title":"为什么要校验是否在窗口范围内","slug":"为什么要校验是否在窗口范围内","link":"#为什么要校验是否在窗口范围内","children":[]},{"level":3,"title":"加了窗口校验就不能用 RST 攻击了吗","slug":"加了窗口校验就不能用-rst-攻击了吗","link":"#加了窗口校验就不能用-rst-攻击了吗","children":[]}]},{"level":2,"title":"总结","slug":"总结","link":"#总结","children":[]},{"level":2,"title":"参考资料","slug":"参考资料","link":"#参考资料","children":[]},{"level":2,"title":"最后","slug":"最后","link":"#最后","children":[]},{"level":2,"title":"文章推荐：","slug":"文章推荐","link":"#文章推荐","children":[]}],"git":{"createdTime":1708315055000,"updatedTime":1708315055000,"contributors":[{"name":"xiaobai","email":"xiaobaidebug@gmail.com","commits":1}]},"readingTime":{"minutes":16.18,"words":4853},"filePathRelative":"计算机基础/网络基础/核心知识点/动图图解！收到RST，就一定会断开TCP连接吗？.md","localizedDate":"2021年9月1日","autoDesc":true}');export{B as comp,f as data};
