import{_ as t}from"./plugin-vue_export-helper-DlAUqK2U.js";import{r as a,o,c as e,a as n,b as p,d as i,e as l}from"./app-B4HQHnMG.js";const r={},c=l('<h1 id="为什么mysql的count-方法这么慢" tabindex="-1"><a class="header-anchor" href="#为什么mysql的count-方法这么慢"><span>为什么mysql的count()方法这么慢？</span></a></h1><figure><img src="https://cdn.xiaobaidebug.top/9a9f7046fbb668643c3466b50354a569.gif" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>兄弟们。</p><p>浅浅的<strong>炫个富</strong>吧。</p><p>说出来你们可能不信。</p><p>手机你们有吗？我有。</p><p><strong>短信</strong>，知道吧？一条一毛钱，<strong>我天天发</strong>。</p><p>你敢想吗？</p><p>所以说，年轻人，有钱是真的好。</p><p>今天，我们就以短信为话题聊起。</p><p>短信，它又叫SMS。</p><br><p>比如说，你有一张<strong>短信表(sms)</strong>，里面放了各种需要发送的短信信息。</p><figure><img src="https://cdn.xiaobaidebug.top/sms建表sql.png" alt="sms建表sql" tabindex="0" loading="lazy"><figcaption>sms建表sql</figcaption></figure><figure><img src="https://cdn.xiaobaidebug.top/sms表.drawio.png" alt="sms表" tabindex="0" loading="lazy"><figcaption>sms表</figcaption></figure><p>需要注意的是<strong>state字段，为0的时候说明这时候短信还未发送。</strong></p><p>此时还会有一个<strong>异步线程</strong>不断的捞起<strong>未发送（state=0）<strong>的短信数据，执行发短信操作，发送成功之后state字段会被</strong>置为1（已发送）</strong>。也就是说<strong>未发送的数据会不断变少</strong>。</p><figure><img src="https://cdn.xiaobaidebug.top/异步线程发送短信.drawio.png" alt="异步线程发送短信" tabindex="0" loading="lazy"><figcaption>异步线程发送短信</figcaption></figure><br><p>假设由于某些原因，你现在需要做一些监控，比如监控的内容是，<strong>你的sms数据表里还有没有state=0（未发送）的短信，方便判断一下堆积的未发送短信大概在什么样的一个量级。</strong></p><p>为了获取<strong>满足某些条件的行数是多少</strong>，我们一般会使用<strong>count()方法</strong>。</p><p>这时候为了获取未发送的短信数据，我们很自然就想到了使用下面的sql语句进行查询。</p><div class="language-sql line-numbers-mode" data-ext="sql" data-title="sql"><pre class="language-sql"><code><span class="token keyword">select</span> <span class="token function">count</span><span class="token punctuation">(</span><span class="token operator">*</span><span class="token punctuation">)</span> <span class="token keyword">from</span> sms <span class="token keyword">where</span> state <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>然后再把获得数据作为打点发给监控服务。</p><br><p>当数据表小的时候，这是没问题的，但当数据量大的时候，比如未发送的短信到了<strong>百万量级</strong>的时候，你就会发现，<strong>上面的sql查询时间会变得很长，最后timeout报错，查不出结果了</strong>。</p><br><p>为什么？</p><br><p>我们先从<strong>count()方法的原理</strong>聊起。</p><br><h2 id="count-的原理" tabindex="-1"><a class="header-anchor" href="#count-的原理"><span>count()的原理</span></a></h2><p>count()方法的目的是计算当前sql语句查询得到的<strong>非NULL的行数</strong>。</p><p>我们知道mysql是分为<strong>server层和存储引擎层的</strong>。</p><figure><img src="https://cdn.xiaobaidebug.top/Mysql架构56.drawio-20220613163829373.png" alt="Mysql架构" tabindex="0" loading="lazy"><figcaption>Mysql架构</figcaption></figure><p>存储引擎层里可以选择各种引擎进行存储，最常见的是innodb、myisam。具体使用哪个存储引擎，可以通过建表sql里的<code>ENGINE</code>字段进行指定。比如这篇文章开头的建表sql里用了<code>ENGINE=InnoDB</code>，那这张表用的就是innodb引擎。</p><p><strong>虽然在server层都叫count()方法，但在不同的存储引擎下，它们的实现方式是有区别的。</strong></p><p>比如同样是<strong>读全表数据</strong> <code>select count(*) from sms；</code>语句。</p><p>使用 <strong>myisam引擎</strong>的数据表里有个记录当前表里有几行数据的字段，直接读这个字段返回就好了，因此速度快得飞起。</p><p>而使用<strong>innodb引擎</strong>的数据表，则会选择<strong>体积最小的索引树</strong>，然后通过遍历叶子节点的个数挨个加起来，这样也能得到全表数据。</p><p>因此回到文章开头的问题里，当数据表行数变大后，<strong>单次count就需要扫描大量的数据</strong>，因此很可能就会出现超时报错。</p><br><p>那么问题就来了。</p><br><h3 id="为什么innodb不能像myisam那样实现count-方法" tabindex="-1"><a class="header-anchor" href="#为什么innodb不能像myisam那样实现count-方法"><span><strong>为什么innodb不能像myisam那样实现count()方法</strong></span></a></h3><p>myisam和innodb这两个引擎，有几个比较明显的区别，这个是八股文常考了。</p><p>其中<strong>最大的区别在于myisam不支持事务，而innodb支持事务。</strong></p><p>而事务，有四层隔离级别，其中<strong>默认隔离级别就是可重复读隔离级别（RR）</strong>。</p><figure><img src="https://cdn.xiaobaidebug.top/四层隔离级别.png" alt="四层隔离级别" tabindex="0" loading="lazy"><figcaption>四层隔离级别</figcaption></figure><p>innodb引擎通过MVCC实现了<strong>可重复隔离级别</strong>，事务开启后，多次执行同样的<strong>select快照读</strong>，要能读到同样的数据。</p><p>于是我们看个例子。</p><figure><img src="https://cdn.xiaobaidebug.top/为什么innodb不单独记录表行数.drawio.png" alt="为什么innodb不单独记录表行数" tabindex="0" loading="lazy"><figcaption>为什么innodb不单独记录表行数</figcaption></figure><p>对于两个事务A和B，一开始sms表假设就<strong>2条</strong>数据，那事务A一开始确实是读到2条数据。事务B在这期间插入了1条数据，按道理数据库其实有3条数据了，但由于可重复读的隔离级别，事务A依然还是只能读到2条数据。</p><p>因此由于事务隔离级别的存在，<strong>不同的事务在同一时间下，看到的表内数据行数是不一致的</strong>，因此innodb，没办法，也没必要像myisam那样单纯的加个count字段信息在数据表上。</p><p>那如果不可避免要使用count()，有没有办法让它快一点？</p><br><h2 id="各种count-方法的原理" tabindex="-1"><a class="header-anchor" href="#各种count-方法的原理"><span>各种count()方法的原理</span></a></h2><p>count()的括号里，可以放各种奇奇怪怪的东西，想必大家应该看过，比如放个星号*，放个1，放个索引列啥的。</p><p>我们来分析下他们的执行流程。</p><p><strong>count方法的大原则是server层会从innodb存储引擎里读来一行行数据，并且只累计非null的值</strong>。但这个过程，根据count()方法括号内的传参，有略有不同。</p><br><h3 id="count" tabindex="-1"><a class="header-anchor" href="#count"><span>count(*)</span></a></h3><p>server层拿到innodb返回的行数据，<strong>不对里面的行数据做任何解析和判断</strong>，默认取出的值肯定都不是null，直接行数+1。</p><br><h3 id="count-1" tabindex="-1"><a class="header-anchor" href="#count-1"><span>count(1)</span></a></h3><p>server层拿到innodb返回的行数据，每行放个1进去，默认不可能为null，直接行数+1.</p><br><h3 id="count-某个列字段" tabindex="-1"><a class="header-anchor" href="#count-某个列字段"><span>count(某个列字段)</span></a></h3><p>由于指明了要count某个字段，innodb在取数据的时候，会把这个字段<strong>解析出来</strong>返回给server层，所以会<strong>比count(1)和count(*)多了个解析字段出来的流程。</strong></p><ul><li>如果这个列字段是<strong>主键id</strong>，主键是不可能为null的，所以server层也不用判断是否为null，innodb每返回一行，行数结果就+1.</li><li>如果这个列是<strong>普通索引字段</strong>，innodb一般会<strong>走普通索引</strong>，每返回一行数据，server层就会判断这个字段是否为null，不是null的情况下+1。当然如果建表sql里字段定义为not null的话，那就不用做这一步判断直接+1。</li><li>如果这个列<strong>没有加过索引</strong>，那innodb可能会全表扫描，返回的每一行数据，server层都会判断这个字段是否为null，不是null的情况下+1。同上面的情况一样，字段加了not null也就省下这一步判断了。</li></ul><p>理解了原理后我们大概可以知道他们的性能排序是</p><div class="language-sql line-numbers-mode" data-ext="sql" data-title="sql"><pre class="language-sql"><code><span class="token function">count</span><span class="token punctuation">(</span><span class="token operator">*</span><span class="token punctuation">)</span> ≈ <span class="token function">count</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">&gt;</span> <span class="token function">count</span><span class="token punctuation">(</span>主键id<span class="token punctuation">)</span> <span class="token operator">&gt;</span> <span class="token function">count</span><span class="token punctuation">(</span>普通索引列<span class="token punctuation">)</span> <span class="token operator">&gt;</span> <span class="token function">count</span><span class="token punctuation">(</span>未加索引列<span class="token punctuation">)</span>\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p><strong>所以说count(*)，已经是最快的了。</strong></p><br><p>知道真相的我眼泪掉下来。</p><img src="https://cdn.xiaobaidebug.top/u=3123397807,3516361318&amp;fm=253&amp;fmt=auto&amp;app=138&amp;f=JPEG.jpeg" style="zoom:50%;"><p>那有没有其他更好的办法？</p><br><h2 id="允许粗略估计行数的场景" tabindex="-1"><a class="header-anchor" href="#允许粗略估计行数的场景"><span>允许粗略估计行数的场景</span></a></h2><p>我们回过头来细品下文章开头的需求，我们只是希望知道数据库里还有多少短信是堆积在那没发的，具体是1k还是2k其实都是差不多量级，等到了百万以上，具体数值已经不重要了，我们知道它现在堆积得很离谱，就够了。 因此这个场景，其实是允许使用<strong>比较粗略</strong>的估计的。</p><p><strong>那怎么样才能获得粗略的数值呢？</strong></p><p>还记得我们平时为了查看sql执行计划用的<strong>explain命令</strong>不。</p><p>其中有个<strong>rows</strong>，会用来<strong>估计</strong>接下来执行这条sql需要扫描和检查多少行。它是通过采样的方式计算出来的，虽然会有一定的偏差，但它能反映一定的数量级。</p><figure><img src="https://cdn.xiaobaidebug.top/explain里的rows.png" alt="explain里的rows" tabindex="0" loading="lazy"><figcaption>explain里的rows</figcaption></figure><p>有些语言的orm里可能没有专门的explain语法，但是肯定有执行raw sql的功能，你<strong>可以把explain语句当做raw sql传入，从返回的结果里将rows那一列读出来使用。</strong></p><p>一般情况下，explain的sql如果能走索引，那会比不走索引的情况更准 。单个字段的索引会比多个字段组成的复合索引要准。索引区分度越高，rows的值也会越准。</p><p>这种情况几乎满足大部分的监控场景。但总有一些场景，它要求必须得到精确的行数，这种情况该怎么办呢？</p><br><h2 id="必须精确估计行数的场景" tabindex="-1"><a class="header-anchor" href="#必须精确估计行数的场景"><span>必须精确估计行数的场景</span></a></h2><p>这种场景就比较头疼了，但也不是不能做。</p><p>我们可以单独拉一张新的数据库表，只为保存各种场景下的count。</p><div class="language-sql line-numbers-mode" data-ext="sql" data-title="sql"><pre class="language-sql"><code><span class="token keyword">CREATE</span> <span class="token keyword">TABLE</span> <span class="token identifier"><span class="token punctuation">`</span>count_table<span class="token punctuation">`</span></span> <span class="token punctuation">(</span>\n  <span class="token identifier"><span class="token punctuation">`</span>id<span class="token punctuation">`</span></span> <span class="token keyword">int</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span> <span class="token keyword">AUTO_INCREMENT</span> <span class="token keyword">COMMENT</span> <span class="token string">&#39;主键&#39;</span><span class="token punctuation">,</span>\n  <span class="token identifier"><span class="token punctuation">`</span>cnt_what<span class="token punctuation">`</span></span> <span class="token keyword">char</span><span class="token punctuation">(</span><span class="token number">20</span><span class="token punctuation">)</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span> <span class="token keyword">DEFAULT</span> <span class="token string">&#39;&#39;</span> <span class="token keyword">COMMENT</span> <span class="token string">&#39;各种需要计算的指标&#39;</span><span class="token punctuation">,</span>\n  <span class="token identifier"><span class="token punctuation">`</span>cnt<span class="token punctuation">`</span></span> <span class="token keyword">tinyint</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span> <span class="token keyword">COMMENT</span> <span class="token string">&#39;cnt指标值&#39;</span><span class="token punctuation">,</span>\n  <span class="token keyword">PRIMARY</span> <span class="token keyword">KEY</span> <span class="token punctuation">(</span><span class="token identifier"><span class="token punctuation">`</span>id<span class="token punctuation">`</span></span><span class="token punctuation">)</span><span class="token punctuation">,</span>\n  <span class="token keyword">KEY</span> <span class="token identifier"><span class="token punctuation">`</span>idx_cnt_what<span class="token punctuation">`</span></span> <span class="token punctuation">(</span><span class="token identifier"><span class="token punctuation">`</span>cnt_what<span class="token punctuation">`</span></span><span class="token punctuation">)</span>\n<span class="token punctuation">)</span> <span class="token keyword">ENGINE</span><span class="token operator">=</span><span class="token keyword">InnoDB</span>  <span class="token keyword">DEFAULT</span> <span class="token keyword">CHARSET</span><span class="token operator">=</span>utf8mb4<span class="token punctuation">;</span>\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><figure><img src="https://cdn.xiaobaidebug.top/保存各种场景下的count.drawio.png" alt="count_table表保存各种场景下的count" tabindex="0" loading="lazy"><figcaption>count_table表保存各种场景下的count</figcaption></figure><p>当需要获取某个场景下的cout值时，可以使用下面的sql进行直接读取，<strong>快得飞起</strong>。</p><div class="language-sql line-numbers-mode" data-ext="sql" data-title="sql"><pre class="language-sql"><code><span class="token keyword">select</span> cnt <span class="token keyword">from</span> count_table <span class="token keyword">where</span> cnt_what <span class="token operator">=</span> <span class="token string">&quot;未发送的短信数量&quot;</span><span class="token punctuation">;</span> \n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><br><p><strong>那这些count的结果值从哪来呢？</strong></p><p>这里分成两种情况。</p><br><h3 id="实时性要求较高的场景" tabindex="-1"><a class="header-anchor" href="#实时性要求较高的场景"><span>实时性要求较高的场景</span></a></h3><p>如果你对这个cnt计算结果的实时性要求很高，那你需要<strong>将更新cnt的sql加入到对应变更行数的事务中</strong>。</p><p>比如我们有两个事务A和B，分别是增加未发送短信和减少未发送短信。</p><figure><img src="https://cdn.xiaobaidebug.top/将更改表行数的操作放入到事务里.drawio.png" alt="将更改表行数的操作放入到事务里" tabindex="0" loading="lazy"><figcaption>将更改表行数的操作放入到事务里</figcaption></figure><p>这样做的<strong>好处</strong>是事务内的cnt行数依然符合隔离级别，事务回滚的时候，cnt的值也会跟着回滚。</p><p><strong>坏处</strong>也比较明显，多个线程对同一个cnt进行写操作，会触发悲观锁，多个线程之间需要互相等待。对于<strong>高频写的场景</strong>，性能会有折损。</p><br><h3 id="实时性没那么高的场景" tabindex="-1"><a class="header-anchor" href="#实时性没那么高的场景"><span>实时性没那么高的场景</span></a></h3><p>如果实时性要求不高的话，比如可以一天一次，那你可以通过全表扫描后做计算。</p><p>举个例子，比如上面的短信表，可以<strong>按id排序</strong>，每次取出1w条数据，<strong>记下这一批里最大的id，然后下次从最大id开始再拿1w条数据出来，不断循环。</strong></p><p>对于未发送的短信，就只需要在捞出的那1w条数据里，筛选出state=0的条数。</p><figure><img src="https://cdn.xiaobaidebug.top/batch分批获取短信表.drawio.png" alt="batch分批获取短信表" tabindex="0" loading="lazy"><figcaption>batch分批获取短信表</figcaption></figure><p>当然如果有条件，这种场景最好的方式还是<strong>消费binlog将数据导入到hive里</strong>，然后在hive里做查询，不少公司也已经有现成的组件可以做这种事情，不用自己写脚本，岂不美哉。</p><figure><img src="https://cdn.xiaobaidebug.top/mysql同步hive.drawio.png" alt="mysql同步hive" tabindex="0" loading="lazy"><figcaption>mysql同步hive</figcaption></figure><br><h2 id="总结" tabindex="-1"><a class="header-anchor" href="#总结"><span>总结</span></a></h2><ul><li><p>mysql用count方法<strong>查全表数据</strong>，在不同的存储引擎里实现不同，myisam有专门字段记录全表的行数，直接读这个字段就好了。而innodb则需要一行行去算。</p></li><li><p>性能方面 <code>count(*) ≈ count(1) &gt; count(主键id) &gt; count(普通索引列) &gt; count(未加索引列)</code>，但哪怕是性能最好的count(*)，由于实现上就需要一行行去算，所以数据量大的时候就是不给力。</p></li><li><p>如果确实需要获取行数，且**可以接受不那么精确的行数（只需要判断大概的量级）**的话，那可以用explain里的rows，这可以满足大部分的监控场景，实现简单。</p></li><li><p><strong>如果要求行数准确</strong>，可以建个新表，里面专门放表行数的信息。</p><ul><li>如果对<strong>实时性要求比较高</strong>的话，可以将更新行数的sql放入到对应事务里，这样既能满足事务隔离性，还能快速读取到行数信息。</li><li>如果对<strong>实时性要求不高</strong>，接受一小时或者一天的更新频率，那既可以自己写脚本遍历全表后更新行数信息。也可以将通过监听binlog将数据导入hive，需要数据时直接通过hive计算得出。</li></ul></li></ul><br><h2 id="参考资料" tabindex="-1"><a class="header-anchor" href="#参考资料"><span>参考资料</span></a></h2><p>《丁奇mysql45讲》</p><br><h2 id="最后" tabindex="-1"><a class="header-anchor" href="#最后"><span>最后</span></a></h2><p>兄弟们，最近有点没出息，沉迷在刘亦菲的新剧里，都快忘了写文这件事了。</p><p>按照惯例，我应该在这里唯唯诺诺的求大家叫我两声<strong>靓仔</strong>的。</p><p>但今天，我感觉我不配。</p><p>所以先这样。</p><br><p>但右下角的点赞和再看还是可以走一波的。</p><p>我是小白，我们下期见。</p><br><h5 id="别说了-一起在知识的海洋里呛水吧" tabindex="-1"><a class="header-anchor" href="#别说了-一起在知识的海洋里呛水吧"><span>别说了，一起在知识的海洋里呛水吧</span></a></h5><p><strong>点击</strong>下方名片，关注公众号:【小白debug】<br><img src="https://cdn.xiaobaidebug.top/扫码_搜索联合传播样式-标准色版.png" alt="" loading="lazy"></p><br><p>不满足于在留言区说骚话？</p><p>加我，我们建了个划水吹牛皮群，在群里，你可以跟你下次跳槽可能遇到的同事或面试官聊点有意思的话题。就<strong>超！开！心！</strong></p><img src="https://cdn.xiaobaidebug.top/image-20220522162616202.png" alt="" style="zoom:50%;"><figure><img src="https://cdn.xiaobaidebug.top/006APoFYly1g5q9gn2jipg308w08wqdi.gif" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><br><h2 id="文章推荐" tabindex="-1"><a class="header-anchor" href="#文章推荐"><span>文章推荐：</span></a></h2>',138),g={href:"https://mp.weixin.qq.com/s/PP80aD-GQp7VtgyfHj392g",target:"_blank",rel:"noopener noreferrer"},d=n("li",null,[n("a",{href:"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/%E6%A0%B8%E5%BF%83%E7%9F%A5%E8%AF%86%E7%82%B9/TCP%E7%B2%98%E5%8C%85%EF%BC%81%E6%95%B0%E6%8D%AE%E5%8C%85%EF%BC%9A%E6%88%91%E5%8F%AA%E6%98%AF%E7%8A%AF%E4%BA%86%E6%AF%8F%E4%B8%AA%E6%95%B0%E6%8D%AE%E5%8C%85%E9%83%BD%E4%BC%9A%E7%8A%AF%E7%9A%84%E9%94%99%EF%BC%8C%E7%A1%AC%E6%A0%B8%E5%9B%BE%E8%A7%A3"},"TCP粘包 数据包：我只是犯了每个数据包都会犯的错 |硬核图解")],-1),u=n("li",null,[n("a",{href:"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/%E6%A0%B8%E5%BF%83%E7%9F%A5%E8%AF%86%E7%82%B9/%E5%8A%A8%E5%9B%BE%E5%9B%BE%E8%A7%A3%EF%BC%81%E6%97%A2%E7%84%B6IP%E5%B1%82%E4%BC%9A%E5%88%86%E7%89%87%EF%BC%8C%E4%B8%BA%E4%BB%80%E4%B9%88TCP%E5%B1%82%E4%B9%9F%E8%BF%98%E8%A6%81%E5%88%86%E6%AE%B5%EF%BC%9F"},"动图图解！既然IP层会分片，为什么TCP层也还要分段？")],-1);function E(m,b){const s=a("ExternalLinkIcon");return o(),e("div",null,[c,n("ul",null,[n("li",null,[n("a",g,[p("程序员防猝死指南"),i(s)])]),d,u])])}const k=t(r,[["render",E],["__file","为什么mysql的count()方法这么慢？.html.vue"]]),A=JSON.parse('{"path":"/%E4%B8%AD%E9%97%B4%E4%BB%B6/mysql/%E6%A0%B8%E5%BF%83%E7%9F%A5%E8%AF%86%E7%82%B9/%E4%B8%BA%E4%BB%80%E4%B9%88mysql%E7%9A%84count()%E6%96%B9%E6%B3%95%E8%BF%99%E4%B9%88%E6%85%A2%EF%BC%9F.html","title":"为什么mysql的count()方法这么慢？","lang":"zh-CN","frontmatter":{"description":"为什么mysql的count()方法这么慢？ 兄弟们。 浅浅的炫个富吧。 说出来你们可能不信。 手机你们有吗？我有。 短信，知道吧？一条一毛钱，我天天发。 你敢想吗？ 所以说，年轻人，有钱是真的好。 今天，我们就以短信为话题聊起。 短信，它又叫SMS。 比如说，你有一张短信表(sms)，里面放了各种需要发送的短信信息。 sms建表sqlsms建表sql...","head":[["meta",{"property":"og:url","content":"https://golangguide.top/%E4%B8%AD%E9%97%B4%E4%BB%B6/mysql/%E6%A0%B8%E5%BF%83%E7%9F%A5%E8%AF%86%E7%82%B9/%E4%B8%BA%E4%BB%80%E4%B9%88mysql%E7%9A%84count()%E6%96%B9%E6%B3%95%E8%BF%99%E4%B9%88%E6%85%A2%EF%BC%9F.html"}],["meta",{"property":"og:site_name","content":"golang全栈指南"}],["meta",{"property":"og:title","content":"为什么mysql的count()方法这么慢？"}],["meta",{"property":"og:description","content":"为什么mysql的count()方法这么慢？ 兄弟们。 浅浅的炫个富吧。 说出来你们可能不信。 手机你们有吗？我有。 短信，知道吧？一条一毛钱，我天天发。 你敢想吗？ 所以说，年轻人，有钱是真的好。 今天，我们就以短信为话题聊起。 短信，它又叫SMS。 比如说，你有一张短信表(sms)，里面放了各种需要发送的短信信息。 sms建表sqlsms建表sql..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:image","content":"https://cdn.xiaobaidebug.top/9a9f7046fbb668643c3466b50354a569.gif"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2024-03-04T07:59:24.000Z"}],["meta",{"name":"twitter:card","content":"summary_large_image"}],["meta",{"name":"twitter:image:alt","content":"为什么mysql的count()方法这么慢？"}],["meta",{"property":"article:author","content":"小白debug"}],["meta",{"property":"article:modified_time","content":"2024-03-04T07:59:24.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"为什么mysql的count()方法这么慢？\\",\\"image\\":[\\"https://cdn.xiaobaidebug.top/9a9f7046fbb668643c3466b50354a569.gif\\",\\"https://cdn.xiaobaidebug.top/sms%E5%BB%BA%E8%A1%A8sql.png\\",\\"https://cdn.xiaobaidebug.top/sms%E8%A1%A8.drawio.png\\",\\"https://cdn.xiaobaidebug.top/%E5%BC%82%E6%AD%A5%E7%BA%BF%E7%A8%8B%E5%8F%91%E9%80%81%E7%9F%AD%E4%BF%A1.drawio.png\\",\\"https://cdn.xiaobaidebug.top/Mysql%E6%9E%B6%E6%9E%8456.drawio-20220613163829373.png\\",\\"https://cdn.xiaobaidebug.top/%E5%9B%9B%E5%B1%82%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB.png\\",\\"https://cdn.xiaobaidebug.top/%E4%B8%BA%E4%BB%80%E4%B9%88innodb%E4%B8%8D%E5%8D%95%E7%8B%AC%E8%AE%B0%E5%BD%95%E8%A1%A8%E8%A1%8C%E6%95%B0.drawio.png\\",\\"https://cdn.xiaobaidebug.top/explain%E9%87%8C%E7%9A%84rows.png\\",\\"https://cdn.xiaobaidebug.top/%E4%BF%9D%E5%AD%98%E5%90%84%E7%A7%8D%E5%9C%BA%E6%99%AF%E4%B8%8B%E7%9A%84count.drawio.png\\",\\"https://cdn.xiaobaidebug.top/%E5%B0%86%E6%9B%B4%E6%94%B9%E8%A1%A8%E8%A1%8C%E6%95%B0%E7%9A%84%E6%93%8D%E4%BD%9C%E6%94%BE%E5%85%A5%E5%88%B0%E4%BA%8B%E5%8A%A1%E9%87%8C.drawio.png\\",\\"https://cdn.xiaobaidebug.top/batch%E5%88%86%E6%89%B9%E8%8E%B7%E5%8F%96%E7%9F%AD%E4%BF%A1%E8%A1%A8.drawio.png\\",\\"https://cdn.xiaobaidebug.top/mysql%E5%90%8C%E6%AD%A5hive.drawio.png\\",\\"https://cdn.xiaobaidebug.top/%E6%89%AB%E7%A0%81_%E6%90%9C%E7%B4%A2%E8%81%94%E5%90%88%E4%BC%A0%E6%92%AD%E6%A0%B7%E5%BC%8F-%E6%A0%87%E5%87%86%E8%89%B2%E7%89%88.png\\",\\"https://cdn.xiaobaidebug.top/006APoFYly1g5q9gn2jipg308w08wqdi.gif\\"],\\"dateModified\\":\\"2024-03-04T07:59:24.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"小白debug\\",\\"url\\":\\"https://xiaobaidebug.top/\\"}]}"],["link",{"rel":"canonical","href":"https://golangguide.top/%E4%B8%AD%E9%97%B4%E4%BB%B6/mysql/%E6%A0%B8%E5%BF%83%E7%9F%A5%E8%AF%86%E7%82%B9/%E4%B8%BA%E4%BB%80%E4%B9%88mysql%E7%9A%84count()%E6%96%B9%E6%B3%95%E8%BF%99%E4%B9%88%E6%85%A2%EF%BC%9F.html"}],["meta",{"property":"og:url","content":"https://golangguide.top/%E4%B8%AD%E9%97%B4%E4%BB%B6/mysql/%E6%A0%B8%E5%BF%83%E7%9F%A5%E8%AF%86%E7%82%B9/%E4%B8%BA%E4%BB%80%E4%B9%88mysql%E7%9A%84count()%E6%96%B9%E6%B3%95%E8%BF%99%E4%B9%88%E6%85%A2%EF%BC%9F.html"}],["meta",{"property":"og:site_name","content":"golang全栈指南"}],["meta",{"property":"og:title","content":"为什么mysql的count()方法这么慢？"}],["meta",{"property":"og:description","content":"为什么mysql的count()方法这么慢？ 兄弟们。 浅浅的炫个富吧。 说出来你们可能不信。 手机你们有吗？我有。 短信，知道吧？一条一毛钱，我天天发。 你敢想吗？ 所以说，年轻人，有钱是真的好。 今天，我们就以短信为话题聊起。 短信，它又叫SMS。 比如说，你有一张短信表(sms)，里面放了各种需要发送的短信信息。 sms建表sqlsms建表sql..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2024-03-04T07:59:24.000Z"}],["meta",{"property":"article:modified_time","content":"2024-03-04T07:59:24.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"为什么mysql的count()方法这么慢？\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2024-03-04T07:59:24.000Z\\",\\"author\\":[]}"]]},"headers":[{"level":2,"title":"count()的原理","slug":"count-的原理","link":"#count-的原理","children":[{"level":3,"title":"为什么innodb不能像myisam那样实现count()方法","slug":"为什么innodb不能像myisam那样实现count-方法","link":"#为什么innodb不能像myisam那样实现count-方法","children":[]}]},{"level":2,"title":"各种count()方法的原理","slug":"各种count-方法的原理","link":"#各种count-方法的原理","children":[{"level":3,"title":"count(*)","slug":"count","link":"#count","children":[]},{"level":3,"title":"count(1)","slug":"count-1","link":"#count-1","children":[]},{"level":3,"title":"count(某个列字段)","slug":"count-某个列字段","link":"#count-某个列字段","children":[]}]},{"level":2,"title":"允许粗略估计行数的场景","slug":"允许粗略估计行数的场景","link":"#允许粗略估计行数的场景","children":[]},{"level":2,"title":"必须精确估计行数的场景","slug":"必须精确估计行数的场景","link":"#必须精确估计行数的场景","children":[{"level":3,"title":"实时性要求较高的场景","slug":"实时性要求较高的场景","link":"#实时性要求较高的场景","children":[]},{"level":3,"title":"实时性没那么高的场景","slug":"实时性没那么高的场景","link":"#实时性没那么高的场景","children":[]}]},{"level":2,"title":"总结","slug":"总结","link":"#总结","children":[]},{"level":2,"title":"参考资料","slug":"参考资料","link":"#参考资料","children":[]},{"level":2,"title":"最后","slug":"最后","link":"#最后","children":[]},{"level":2,"title":"文章推荐：","slug":"文章推荐","link":"#文章推荐","children":[]}],"git":{"createdTime":1708315055000,"updatedTime":1709539164000,"contributors":[{"name":"xiaobai","email":"xiaobaidebug@gmail.com","commits":2}]},"readingTime":{"minutes":12,"words":3600},"filePathRelative":"中间件/mysql/核心知识点/为什么mysql的count()方法这么慢？.md","localizedDate":"2024年2月19日","autoDesc":true}');export{k as comp,A as data};
