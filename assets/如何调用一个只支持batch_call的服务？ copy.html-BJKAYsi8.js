import{_ as p}from"./plugin-vue_export-helper-DlAUqK2U.js";import{r as o,o as e,c as i,a as n,b as a,d as s,e as c}from"./app-FMink38A.js";const l={},r=c(`<h1 id="如何调用一个只支持batch-call的服务" tabindex="-1"><a class="header-anchor" href="#如何调用一个只支持batch-call的服务"><span>如何调用一个只支持batch_call的服务？</span></a></h1><p>我们先来说下标题是什么意思。</p><br><p>为了更好的理解我说的是啥，我们来举个例子。</p><p>假设你现在在做一个<strong>类似B站</strong>的系统，里面放了各种视频。</p><figure><img src="https://cdn.xiaobaidebug.top/image-20220529201338638.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>用户每天在里头上传各种视频。</p><p>按理说每个视频都要去<strong>审查</strong>一下有没有搞颜色，但总不能人眼挨个看吧。</p><p>毕竟唐老哥表示这玩意看多了，看太阳都是绿色的，所以会有专门训练过的<strong>算法服务</strong>去做检测。</p><p>但也不能上来就整个视频每一帧都拿去做审查吧，所以会在每个视频里根据<strong>时长</strong>和<strong>视频类型</strong>随机抽出好几张图片去做审查，比如视频标签是美女的，算法爱看，那多抽几张。标签是编程的，狗都不看，就少抽几张。</p><p>将这些抽出来的图片，送去审查。</p><br><p>为了实现这个功能，我们会以<strong>视频为维度</strong>去做审核，而每个视频里都会有N张<strong>数量不定的图片</strong>，下游服务是个使用<strong>GPU</strong>去检测图片的<strong>算法服务</strong>。</p><p><strong>现在问题来了</strong>，下游服务的算法开发告诉你，这些个下游服务，它<strong>不支持很高的并发</strong>，但请求传参里给你加了个数组，你可以<strong>批量（batch）传入</strong>一个比较大的图片数组，通过这个方式可以提升点图片处理量。</p><br><p>于是，我们的场景就变成。</p><p><strong>上游服务</strong>的<strong>入参</strong>是<strong>一个</strong>视频和它的N张图片，<strong>出参</strong>是这个视频是否审核通过。</p><p><strong>下游服务</strong>的<strong>入参</strong>是N张图片的，<strong>出参</strong>是这个视频是否审核通过。</p><figure><img src="https://cdn.xiaobaidebug.top/batch_call上下游.drawio.png" alt="batch_call上下游" tabindex="0" loading="lazy"><figcaption>batch_call上下游</figcaption></figure><br><p>**现在我们想要用上游服务接入下游服务。**该怎么办？</p><p>看上去挺好办的，一把梭不就完事了吗？</p><p>当一个视频进来，就拿着视频的十多张图片作为一个batch去进行调用。</p><p><strong>有几个视频进来，就开几个这样的并发。</strong></p><p>这么做的结果就是，当并发大一点时，你会发现性能很差，并且性能非常不稳定，比如像下面的监控图一样一会3qps，一会15qps。处理的图片也只支持20qps左右。</p><p><strong>狗看了都得摇头。</strong></p><figure><img src="https://cdn.xiaobaidebug.top/image-20220528224806387.png" alt="图1-直接调用时qps很低" tabindex="0" loading="lazy"><figcaption>图1-直接调用时qps很低</figcaption></figure><figure><img src="https://cdn.xiaobaidebug.top/image-20220528225037987.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>这可如何是好？</p><br><h2 id="为什么下游需要batch-call" tabindex="-1"><a class="header-anchor" href="#为什么下游需要batch-call"><span>为什么下游需要batch call</span></a></h2><p>本着<strong>先问是不是，再问为什么</strong>的精神，我们先看看为啥下游的要求会如此别致。</p><p>为什么同样都是处理多张图片，下游不搞成支持并发而要搞成批量调用（batch call）？</p><p>这个设定有点奇怪？</p><p>其实不奇怪，在算法服务中<strong>甚至很常见</strong>，举个例子你就明白了。</p><p>同样是处理多张图片，为了简单，我就假设是三张吧。如果是用<strong>单个cpu</strong>去处理的话。那不管是并发还是batch进来，由于cpu内部的<strong>计算单元有限</strong>，所以你可以简单理解为，这三张图片，就是<strong>串行</strong>去计算的。</p><figure><img src="https://cdn.xiaobaidebug.top/cpu处理图片时的流程2.drawio.png" alt="cpu处理图片时的流程" tabindex="0" loading="lazy"><figcaption>cpu处理图片时的流程</figcaption></figure><p>我计算第一张图片是否能审核通过，跟第二张图片是否能审核通过，这两者没有逻辑关联，因此按道理两张图片是可以<strong>并行</strong>计算。</p><p>奈何我CPU计算单元有限啊，做不到啊。</p><p>但是。</p><p><strong>如果我打破计算单元有限的这个条件，给CPU加入超多计算单元，并且弱化一些对于计算没啥用处的组件，比如cache和控制单元。<strong>那我们就有足够的算力可以让这些图片的计算</strong>并行</strong>起来了。</p><figure><img src="https://cdn.xiaobaidebug.top/并行处理图片.drawio.png" alt="并行处理图片" tabindex="0" loading="lazy"><figcaption>并行处理图片</figcaption></figure><p>是的，把CPU这么一整，它其实就变成了GPU。</p><figure><img src="https://cdn.xiaobaidebug.top/GPU和CPU的区别2.drawio.png" alt="GPU和CPU的区别" tabindex="0" loading="lazy"><figcaption>GPU和CPU的区别</figcaption></figure><p>上面的讲解只是为了方便理解，实际上，gpu会以更细的粒度去做并发计算，比如可以细到图片里的<strong>像素</strong>级别。</p><p>这也是为什么如果我们跑一些3d游戏的时候，需要用到显卡，因为它可以快速的并行计算画面里每个地方的光影，远近效果啥的，然后渲染出画面。</p><br><p><strong>回到为什么要搞成batch call的问题中。</strong></p><p>其实一次算法服务调用中，在数据真正进入GPU前，其实也使用了CPU做一些前置处理。</p><p>因此，我们可以简单的将一次调用的时间理解成做了下面这些事情。</p><figure><img src="https://cdn.xiaobaidebug.top/GPU处理图片时的流程.drawio.png" alt="GPU处理图片时的流程" tabindex="0" loading="lazy"><figcaption>GPU处理图片时的流程</figcaption></figure><p>服务由CPU逻辑和GPU处理逻辑组成，调用进入服务后，会有一些前置逻辑，它需要CPU来完成，然后才使用GPU去进行并行计算，将结果返回后又有一些后置的CPU处理逻辑。中间的GPU部分，管是计算1张图，还是计算100张图，只要算力支持，那它们都是并行计算的，耗时都差不多。</p><p>如果把这多张图片拆开，<strong>并发去调用</strong>这个算法服务，那就有 N组这样的CPU+GPU的消耗，而中间的并行计算，其实没有利用到位。</p><p>并且还会多了前置和后置的CPU逻辑部分，算法服务一般都是python服务，主流的一些web框架几乎都是以<strong>多进程</strong>，<strong>而不是多线程</strong>的方式去处理外部请求，这就有可能导致额外的<strong>进程间切换消耗</strong>。</p><p>当并发的请求多了，请求处理不过来，后边来的请求就需要等前边的处理完才能被处理，后面的请求耗时看起来就会变得特别大。这也是上面图1里，接口延时（latency）像过山车那样往上涨的原因。</p><figure><img src="https://cdn.xiaobaidebug.top/image-20220602225740411.png" alt="还是上面的图1的截图，一张图用两次哈哈" tabindex="0" loading="lazy"><figcaption>还是上面的图1的截图，一张图用两次哈哈</figcaption></figure><p>按理说<strong>减少并发，增大每次调用时的图片数量</strong>，就可以解决这个问题。</p><p>这就是推荐batch call的原因。</p><p>但问题又来了。</p><p>每次调用，上游服务输入的是一个视频以及它的几张图片，调用下游时，batch的数量按道理就只能是这几张图片的数量，<strong>怎么才能增大batch的数量呢？</strong></p><p>这里的调用，就需要分为<strong>同步调用和异步调用</strong>了。</p><br><h2 id="同步调用和异步调用的区别" tabindex="-1"><a class="header-anchor" href="#同步调用和异步调用的区别"><span>同步调用和异步调用的区别</span></a></h2><p>同步调用，意思是上游发起请求后，<strong>阻塞等待</strong>，下游处理逻辑后返回结果给上游。常见的形式就像我们平时做的http调用一样。</p><figure><img src="https://cdn.xiaobaidebug.top/同步请求.png" alt="同步调用" tabindex="0" loading="lazy"><figcaption>同步调用</figcaption></figure><p>异步调用，意思是上游发起请求后<strong>立马返回</strong>，下游收到消息后慢慢处理，处理完之后再通过某个形式通知上游。常见的形式是使用消息队列，也就是mq。将消息发给mq后，下游消费mq消息，触发处理逻辑，然后再把处理结果发到mq，上游消费mq的结果。</p><figure><img src="https://cdn.xiaobaidebug.top/异步请求.png" alt="异步调用" tabindex="0" loading="lazy"><figcaption>异步调用</figcaption></figure><br><h2 id="异步调用的形式接入" tabindex="-1"><a class="header-anchor" href="#异步调用的形式接入"><span>异步调用的形式接入</span></a></h2><figure><img src="https://cdn.xiaobaidebug.top/异步调用的实现方式.drawio.png" alt="异步调用的实现方式" tabindex="0" loading="lazy"><figcaption>异步调用的实现方式</figcaption></figure><p>回到我们文章开头提到的例子，当上游服务收到一个请求（一个视频和它对应的图片），这时候上游服务作为生产者将这个数据写入到mq中，请求返回。然后新造一个C服务，负责批量消费mq里的消息。这时候服务C就可以根据下游服务的性能控制自己的消费速度，比如一次性消费10条数据（视频），每个数据下面挂了10个图片，那我一次batch的图片数量就是10*10=100张，原来的10次请求就变为了1次请求。这对下游就相当的友好了。</p><p>下游返回结果后，服务C将结果写入到mq的另外一个topic下，由上游去做消费，这样就结束了整个调用流程。</p><br><p>当然上面的方案，如果你把mq换成数据库，一样是ok的，这时候服务C就可以不断的定时轮询数据库表，看下哪些请求没处理，把没处理的请求批量捞出来再batch call下游。不管是mq还是数据库，它们的作用无非就是<strong>作为中转，暂存数据，让服务C根据下游的消费能力，去消费这些数据。</strong></p><p>这样不管后续要加入多少个新服务，它们都可以在原来的基础上做扩展，如果是mq，加topic，如果是数据库，则加数据表，每个新服务都可以根据自己的消费能力去调整消费速度。</p><figure><img src="https://cdn.xiaobaidebug.top/mq串联多个不同性能的服务.drawio.png" alt="mq串联多个不同性能的服务" tabindex="0" loading="lazy"><figcaption>mq串联多个不同性能的服务</figcaption></figure><p><strong>其实对于这种上下游服务处理性能不一致的场景，最适合用的就是异步调用。而且涉及到的服务性能差距越大，服务个数越多，这个方案的优势就越明显。</strong></p><br><h2 id="同步调用的方式接入" tabindex="-1"><a class="header-anchor" href="#同步调用的方式接入"><span>同步调用的方式接入</span></a></h2><p>虽然异步调用在这种场景下的优势很明显，但也有个缺点，就是它需要最上游的调用方能接受用异步的方式去消费结果。其实涉及到算法的服务调用链，都是比较耗时的，用异步接口非常合理。但合理归合理，有些最上游他不一定听你的，就是不能接受异步调用。</p><p>这就需要采用同步调用的方案，但怎么才能把同步接口改造得更适合这种调用场景，这也是这篇文章的重点。</p><br><h3 id="限流" tabindex="-1"><a class="header-anchor" href="#限流"><span>限流</span></a></h3><p>如果直接将请求打到下游算法服务，下游根本吃不消，因此首先需要做的就是给在上游调用下游的地方，加入一个速率限制（rate limit）。</p><p><strong>这样的组件一般也不需要你自己写，几乎任何一个语言里都会有现成的。</strong></p><p>比如golang里可以用<code>golang.org/x/time/rate</code>库，它其实是用令牌桶算法实现的限流器。如果不知道令牌桶是啥也没关系，不影响理解。</p><figure><img src="https://cdn.xiaobaidebug.top/限流器逻辑.png" alt="限流器逻辑" tabindex="0" loading="lazy"><figcaption>限流器逻辑</figcaption></figure><p>当然，这个限制的是<strong>当前这个服务</strong>调用下游的qps，也就是所谓的<strong>单节点限流</strong>。如果是多个服务的话，网上也有不少现成的<strong>分布式限流</strong>框架。但是，还是那句话，<strong>够用就好</strong>。</p><p>限流只能保证下游算法服务不被压垮，并不能提升单次调用batch的图片数量，有没有什么办法可以解决这个问题呢？</p><br><h3 id="参考nagle算法的做法" tabindex="-1"><a class="header-anchor" href="#参考nagle算法的做法"><span>参考Nagle算法的做法</span></a></h3><p>我们熟悉的TCP协议里，有个算法叫Nagle算法，设计它的目的，就是为了避免一次传过少数据，提高数据包的有效数据负载。</p><p>当我们想要发送一些数据包时，数据包会被放入到一个缓冲区中，不立刻发送，那什么时候会发送呢？</p><p>数据包会在以下两个情况被发送：</p><ul><li>缓冲区的数据包长度达到某个长度（MSS）时。</li><li>或者等待超时（一般为<code>200ms</code>）。在超时之前，来的那么多个数据包，就是凑不齐MSS长度，现在超时了，不等了，立即发送。</li></ul><p>这个思路就非常值得我们参考。我们完全可以自己在代码层实现一波，实现也非常简单。</p><p>1.我们定义一个带锁的全局队列（链表）。</p><p>2.当上游服务输入一个视频和它对应的N张图片时，就加锁将这N张<strong>图片数据</strong>和一个<strong>用来存放返回结果的结构体</strong>放入到全局队列中。然后死循环读这个结构体，直到它有结果。就有点像阻塞等待了。</p><p>3.同时在服务启动时就起一个<strong>线程A</strong>专门用于<strong>收集</strong>这个全局队列的图片数据。<strong>线程A</strong>负责发起调用下游服务的请求，但只有在下面两个情况下会发起请求</p><ul><li>当收集的图片数量达到xx张的时候</li><li>距离上次发起请求过了xx毫秒（超时）</li></ul><p>4.调用下游结束后，再根据一开始传入的数据，将调用结果拆开来，送回到刚刚提到的<strong>用于存放结果的结构体</strong>中。</p><p>5.第2步里的死循环因为<strong>存放返回结果的结构体</strong>，有值了，就可以跳出死循环，继续执行后面的逻辑。</p><figure><img src="https://cdn.xiaobaidebug.top/batch_call同步调用改造.drawio (1).png" alt="batch_call同步调用改造" tabindex="0" loading="lazy"><figcaption>batch_call同步调用改造</figcaption></figure><p>这就像公交车站一样，公交车站不可能每来一个顾客就发一辆公交车，当然是希望车里顾客越多越好。上游每来一个请求，就把请求里的图片，也就是乘客，塞到公交车里，公交车要么到点发车（向下游服务发起请求），要么车满了，也没必要等了，直接发车。这样就保证了每次发车的时候公交车里的顾客数量足够多，发车的次数尽量少。</p><br><p>大体思路就跟上面一样，如果是用go来实现的话，就会更加简单。</p><p>比如第1步里的<strong>加锁全局队列</strong>可以改成<strong>有缓冲长度的channel</strong>。第2步里的&quot;<strong>用来存放结果的结构体</strong>&quot;，也可以改成<strong>另一个无缓冲channel</strong>。执行 res := &lt;-ch， 就可以做到<strong>阻塞等待</strong>的效果。</p><p>而核心的仿Nagle的代码也大概长下面这样。当然<strong>不看也没关系，反正你已经知道思路了</strong>。</p><div class="language-go line-numbers-mode" data-ext="go" data-title="go"><pre class="language-go"><code><span class="token keyword">func</span> <span class="token function">CallAPI</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token builtin">error</span> <span class="token punctuation">{</span>
	size <span class="token operator">:=</span> <span class="token number">100</span>
	<span class="token comment">// 这个数组用于收集视频里的图片，每个 IVideoInfo 下都有N张图片</span>
	videoInfos <span class="token operator">:=</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span>IVideoInfo<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> size<span class="token punctuation">)</span>
	<span class="token comment">// 设置一个200ms定时器</span>
	tick <span class="token operator">:=</span> time<span class="token punctuation">.</span><span class="token function">NewTicker</span><span class="token punctuation">(</span><span class="token number">200</span> <span class="token operator">*</span> time<span class="token punctuation">.</span>Microsecond<span class="token punctuation">)</span>
	<span class="token keyword">defer</span> tick<span class="token punctuation">.</span><span class="token function">Stop</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
  <span class="token comment">// 死循环</span>
	<span class="token keyword">for</span> <span class="token punctuation">{</span>
		<span class="token keyword">select</span> <span class="token punctuation">{</span>
		<span class="token comment">// 由于定时器，每200ms，都会执行到这一行</span>
		<span class="token keyword">case</span> <span class="token operator">&lt;-</span>tick<span class="token punctuation">.</span>C<span class="token punctuation">:</span>
			<span class="token keyword">if</span> <span class="token function">len</span><span class="token punctuation">(</span>videoInfos<span class="token punctuation">)</span> <span class="token operator">&gt;</span> <span class="token number">0</span> <span class="token punctuation">{</span>
				<span class="token comment">// 200ms超时，去请求下游</span>
				<span class="token function">limitStartFunc</span><span class="token punctuation">(</span>videoInfos<span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">)</span>
				<span class="token comment">// 请求结束后把之前收集的数据清空，重新开始收集。</span>
				videoInfos <span class="token operator">=</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span>IVideoInfo<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> size<span class="token punctuation">)</span>
			<span class="token punctuation">}</span>
		<span class="token comment">// AddChan就是所谓的全局队列</span>
		<span class="token keyword">case</span> videoInfo<span class="token punctuation">,</span> ok <span class="token operator">:=</span> <span class="token operator">&lt;-</span>AddChan<span class="token punctuation">:</span>
			<span class="token keyword">if</span> <span class="token operator">!</span>ok <span class="token punctuation">{</span>
				<span class="token comment">// 通道关闭时，如果还有数据没有去发起请求，就请求一波下游服务</span>
				<span class="token function">limitStartFunc</span><span class="token punctuation">(</span>videoInfos<span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">)</span>
				videoInfos <span class="token operator">=</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span>IVideoInfo<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> size<span class="token punctuation">)</span>
				<span class="token keyword">return</span> <span class="token boolean">nil</span>
			<span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
				videoInfos <span class="token operator">=</span> <span class="token function">append</span><span class="token punctuation">(</span>videoInfos<span class="token punctuation">,</span> videoInfo<span class="token punctuation">)</span>
				<span class="token keyword">if</span> videoInfos 内的图片满足xx数量 <span class="token punctuation">{</span>
					<span class="token function">limitStartFunc</span><span class="token punctuation">(</span>videoInfos<span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">)</span>
					videoInfos <span class="token operator">=</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span>IVideoInfo<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> size<span class="token punctuation">)</span>
					<span class="token comment">// 重置定时器</span>
					tick<span class="token punctuation">.</span><span class="token function">Reset</span><span class="token punctuation">(</span><span class="token number">200</span> <span class="token operator">*</span> time<span class="token punctuation">.</span>Microsecond<span class="token punctuation">)</span>
				<span class="token punctuation">}</span>
			<span class="token punctuation">}</span>
		<span class="token punctuation">}</span>
	<span class="token punctuation">}</span>
	<span class="token keyword">return</span> <span class="token boolean">nil</span>
<span class="token punctuation">}</span>

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><br><p>通过这一操作，上游每来一个请求，都会将视频里的图片收集起来，堆到一定张数的时候再统一请求，大大提升了每次batch call的图片数量，同时也减少了调用下游服务的次数。<strong>真·一举两得</strong>。</p><p>优化的效果也比较明显，上游服务支持的qps从原来不稳定的3q~15q变成稳定的90q。下游的接口耗时也变得稳定多了，从原来的过山车似的飙到15s变成稳定的500ms左右。处理的图片的速度也从原来20qps提升到350qps。</p><p>到这里就已经大大超过业务需求的预期（40qps）了，够用就好，多一个qps都是浪费。</p><p>可以了，下班吧。</p><figure><img src="https://cdn.xiaobaidebug.top/image-20220528215806920.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><figure><img src="https://cdn.xiaobaidebug.top/image-20220529171810510.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><br><h2 id="总结" tabindex="-1"><a class="header-anchor" href="#总结"><span>总结</span></a></h2><ul><li>为了充分利用<strong>GPU</strong>并行计算的能力，不少算法服务会希望上游通过加大<strong>batch</strong>的同时减少并发的方式进行接口调用。</li><li>对于上下游性能差距明显的服务，建议配合<strong>mq</strong>采用<strong>异步调用</strong>的方式将服务串联起来。</li><li>如果非得使用<strong>同步调用</strong>的方式进行调用，建议模仿<strong>Nagle算法</strong>的形式，攒一批数据再发起请求，这样既可以增大batch，同时减少并发，真·一举两得，<strong>亲测有效</strong>。</li></ul><br><h2 id="最后" tabindex="-1"><a class="header-anchor" href="#最后"><span>最后</span></a></h2><p>讲了那么多可以提升性能的方式，现在需求来了，如果你资源充足，但时间不充足，那还是直接同步调用一把梭吧。</p><p>性能不够？<strong>下游加机器，gpu卡，买！</strong></p><p>然后下个季度再提起一个技术优化，<strong>性能提升xx%，cpu，gpu减少xx%。</strong></p><p>有没有闻到？</p><p>这是kpi的味道。</p><p>又是一个小细节，学到了的兄弟们评论区打个【<strong>学到了</strong>】。</p><br><hr><p>最近原创更文的阅读量稳步下跌，思前想后，夜里辗转反侧。</p><p>我有个不成熟的请求。</p><img src="https://cdn.xiaobaidebug.top/image-20220522162506224.png" alt="" style="zoom:20%;"><br><p><strong>离开广东好长时间了，好久没人叫我靓仔了。</strong></p><p>大家可以在<strong>评论区</strong>里，叫我一靓仔吗？</p><p>我这么善良质朴的愿望，能被满足吗？</p><p>如果实在叫不出口的话，能帮我点下右下角的<strong>点赞和在看</strong>吗？</p><br><h5 id="别说了-一起在知识的海洋里呛水吧" tabindex="-1"><a class="header-anchor" href="#别说了-一起在知识的海洋里呛水吧"><span>别说了，一起在知识的海洋里呛水吧</span></a></h5><p><strong>点击</strong>下方名片，关注公众号:【小白debug】<br><img src="https://cdn.xiaobaidebug.top/扫码_搜索联合传播样式-标准色版.png" alt="" loading="lazy"></p><br><p>不满足于在留言区说骚话？</p><p>加我，我们建了个划水吹牛皮群，在群里，你可以跟你下次跳槽可能遇到的同事或面试官聊点有意思的话题。就<strong>超！开！心！</strong></p><img src="https://cdn.xiaobaidebug.top/image-20220522162616202.png" alt="" style="zoom:50%;"><figure><img src="https://cdn.xiaobaidebug.top/006APoFYly1g5q9gn2jipg308w08wqdi.gif" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><h2 id="文章推荐" tabindex="-1"><a class="header-anchor" href="#文章推荐"><span>文章推荐：</span></a></h2>`,146),g={href:"https://mp.weixin.qq.com/s/PP80aD-GQp7VtgyfHj392g",target:"_blank",rel:"noopener noreferrer"},d={href:"https://mp.weixin.qq.com/s/0-YBxU1cSbDdzcZEZjmQYA",target:"_blank",rel:"noopener noreferrer"},u={href:"https://mp.weixin.qq.com/s/YpQGsRyyrGNDu1cOuMy83w",target:"_blank",rel:"noopener noreferrer"};function b(m,h){const t=o("ExternalLinkIcon");return e(),i("div",null,[r,n("ul",null,[n("li",null,[n("a",g,[a("程序员防猝死指南"),s(t)])]),n("li",null,[n("a",d,[a("TCP粘包 数据包：我只是犯了每个数据包都会犯的错 |硬核图解"),s(t)])]),n("li",null,[n("a",u,[a("动图图解！既然IP层会分片，为什么TCP层也还要分段？"),s(t)])])])])}const f=p(l,[["render",b],["__file","如何调用一个只支持batch_call的服务？ copy.html.vue"]]),v=JSON.parse('{"path":"/golang/%E6%A0%B8%E5%BF%83%E7%9F%A5%E8%AF%86%E7%82%B9/%E5%A6%82%E4%BD%95%E8%B0%83%E7%94%A8%E4%B8%80%E4%B8%AA%E5%8F%AA%E6%94%AF%E6%8C%81batch_call%E7%9A%84%E6%9C%8D%E5%8A%A1%EF%BC%9F%20copy.html","title":"如何调用一个只支持batch_call的服务？","lang":"zh-CN","frontmatter":{"description":"如何调用一个只支持batch_call的服务？ 我们先来说下标题是什么意思。 为了更好的理解我说的是啥，我们来举个例子。 假设你现在在做一个类似B站的系统，里面放了各种视频。 用户每天在里头上传各种视频。 按理说每个视频都要去审查一下有没有搞颜色，但总不能人眼挨个看吧。 毕竟唐老哥表示这玩意看多了，看太阳都是绿色的，所以会有专门训练过的算法服务去做检测...","head":[["meta",{"property":"og:url","content":"https://golangguide.top/golang/%E6%A0%B8%E5%BF%83%E7%9F%A5%E8%AF%86%E7%82%B9/%E5%A6%82%E4%BD%95%E8%B0%83%E7%94%A8%E4%B8%80%E4%B8%AA%E5%8F%AA%E6%94%AF%E6%8C%81batch_call%E7%9A%84%E6%9C%8D%E5%8A%A1%EF%BC%9F%20copy.html"}],["meta",{"property":"og:site_name","content":"golang全栈指南"}],["meta",{"property":"og:title","content":"如何调用一个只支持batch_call的服务？"}],["meta",{"property":"og:description","content":"如何调用一个只支持batch_call的服务？ 我们先来说下标题是什么意思。 为了更好的理解我说的是啥，我们来举个例子。 假设你现在在做一个类似B站的系统，里面放了各种视频。 用户每天在里头上传各种视频。 按理说每个视频都要去审查一下有没有搞颜色，但总不能人眼挨个看吧。 毕竟唐老哥表示这玩意看多了，看太阳都是绿色的，所以会有专门训练过的算法服务去做检测..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:image","content":"https://cdn.xiaobaidebug.top/image-20220529201338638.png"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2024-02-26T01:57:44.000Z"}],["meta",{"name":"twitter:card","content":"summary_large_image"}],["meta",{"name":"twitter:image:alt","content":"如何调用一个只支持batch_call的服务？"}],["meta",{"property":"article:author","content":"小白debug"}],["meta",{"property":"article:modified_time","content":"2024-02-26T01:57:44.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"如何调用一个只支持batch_call的服务？\\",\\"image\\":[\\"https://cdn.xiaobaidebug.top/image-20220529201338638.png\\",\\"https://cdn.xiaobaidebug.top/batch_call%E4%B8%8A%E4%B8%8B%E6%B8%B8.drawio.png\\",\\"https://cdn.xiaobaidebug.top/image-20220528224806387.png\\",\\"https://cdn.xiaobaidebug.top/image-20220528225037987.png\\",\\"https://cdn.xiaobaidebug.top/cpu%E5%A4%84%E7%90%86%E5%9B%BE%E7%89%87%E6%97%B6%E7%9A%84%E6%B5%81%E7%A8%8B2.drawio.png\\",\\"https://cdn.xiaobaidebug.top/%E5%B9%B6%E8%A1%8C%E5%A4%84%E7%90%86%E5%9B%BE%E7%89%87.drawio.png\\",\\"https://cdn.xiaobaidebug.top/GPU%E5%92%8CCPU%E7%9A%84%E5%8C%BA%E5%88%AB2.drawio.png\\",\\"https://cdn.xiaobaidebug.top/GPU%E5%A4%84%E7%90%86%E5%9B%BE%E7%89%87%E6%97%B6%E7%9A%84%E6%B5%81%E7%A8%8B.drawio.png\\",\\"https://cdn.xiaobaidebug.top/image-20220602225740411.png\\",\\"https://cdn.xiaobaidebug.top/%E5%90%8C%E6%AD%A5%E8%AF%B7%E6%B1%82.png\\",\\"https://cdn.xiaobaidebug.top/%E5%BC%82%E6%AD%A5%E8%AF%B7%E6%B1%82.png\\",\\"https://cdn.xiaobaidebug.top/%E5%BC%82%E6%AD%A5%E8%B0%83%E7%94%A8%E7%9A%84%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F.drawio.png\\",\\"https://cdn.xiaobaidebug.top/mq%E4%B8%B2%E8%81%94%E5%A4%9A%E4%B8%AA%E4%B8%8D%E5%90%8C%E6%80%A7%E8%83%BD%E7%9A%84%E6%9C%8D%E5%8A%A1.drawio.png\\",\\"https://cdn.xiaobaidebug.top/%E9%99%90%E6%B5%81%E5%99%A8%E9%80%BB%E8%BE%91.png\\",\\"https://cdn.xiaobaidebug.top/batch_call%E5%90%8C%E6%AD%A5%E8%B0%83%E7%94%A8%E6%94%B9%E9%80%A0.drawio%20(1\\",\\"https://cdn.xiaobaidebug.top/image-20220528215806920.png\\",\\"https://cdn.xiaobaidebug.top/image-20220529171810510.png\\",\\"https://cdn.xiaobaidebug.top/%E6%89%AB%E7%A0%81_%E6%90%9C%E7%B4%A2%E8%81%94%E5%90%88%E4%BC%A0%E6%92%AD%E6%A0%B7%E5%BC%8F-%E6%A0%87%E5%87%86%E8%89%B2%E7%89%88.png\\",\\"https://cdn.xiaobaidebug.top/006APoFYly1g5q9gn2jipg308w08wqdi.gif\\"],\\"dateModified\\":\\"2024-02-26T01:57:44.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"小白debug\\",\\"url\\":\\"https://xiaobaidebug.top/\\"}]}"],["link",{"rel":"canonical","href":"https://golangguide.top/golang/%E6%A0%B8%E5%BF%83%E7%9F%A5%E8%AF%86%E7%82%B9/%E5%A6%82%E4%BD%95%E8%B0%83%E7%94%A8%E4%B8%80%E4%B8%AA%E5%8F%AA%E6%94%AF%E6%8C%81batch_call%E7%9A%84%E6%9C%8D%E5%8A%A1%EF%BC%9F%20copy.html"}],["meta",{"property":"og:url","content":"https://golangguide.top/golang/%E6%A0%B8%E5%BF%83%E7%9F%A5%E8%AF%86%E7%82%B9/%E5%A6%82%E4%BD%95%E8%B0%83%E7%94%A8%E4%B8%80%E4%B8%AA%E5%8F%AA%E6%94%AF%E6%8C%81batch_call%E7%9A%84%E6%9C%8D%E5%8A%A1%EF%BC%9F%20copy.html"}],["meta",{"property":"og:site_name","content":"golang全栈指南"}],["meta",{"property":"og:title","content":"如何调用一个只支持batch_call的服务？"}],["meta",{"property":"og:description","content":"如何调用一个只支持batch_call的服务？ 我们先来说下标题是什么意思。 为了更好的理解我说的是啥，我们来举个例子。 假设你现在在做一个类似B站的系统，里面放了各种视频。 用户每天在里头上传各种视频。 按理说每个视频都要去审查一下有没有搞颜色，但总不能人眼挨个看吧。 毕竟唐老哥表示这玩意看多了，看太阳都是绿色的，所以会有专门训练过的算法服务去做检测..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2024-02-26T01:57:44.000Z"}],["meta",{"property":"article:modified_time","content":"2024-02-26T01:57:44.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"如何调用一个只支持batch_call的服务？\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2024-02-26T01:57:44.000Z\\",\\"author\\":[]}"]]},"headers":[{"level":2,"title":"为什么下游需要batch call","slug":"为什么下游需要batch-call","link":"#为什么下游需要batch-call","children":[]},{"level":2,"title":"同步调用和异步调用的区别","slug":"同步调用和异步调用的区别","link":"#同步调用和异步调用的区别","children":[]},{"level":2,"title":"异步调用的形式接入","slug":"异步调用的形式接入","link":"#异步调用的形式接入","children":[]},{"level":2,"title":"同步调用的方式接入","slug":"同步调用的方式接入","link":"#同步调用的方式接入","children":[{"level":3,"title":"限流","slug":"限流","link":"#限流","children":[]},{"level":3,"title":"参考Nagle算法的做法","slug":"参考nagle算法的做法","link":"#参考nagle算法的做法","children":[]}]},{"level":2,"title":"总结","slug":"总结","link":"#总结","children":[]},{"level":2,"title":"最后","slug":"最后","link":"#最后","children":[]},{"level":2,"title":"文章推荐：","slug":"文章推荐","link":"#文章推荐","children":[]}],"git":{"createdTime":1708912664000,"updatedTime":1708912664000,"contributors":[{"name":"xiaobai","email":"xiaobaidebug@gmail.com","commits":1}]},"readingTime":{"minutes":15.76,"words":4729},"filePathRelative":"golang/核心知识点/如何调用一个只支持batch_call的服务？ copy.md","localizedDate":"2024年2月26日","autoDesc":true}');export{f as comp,v as data};
