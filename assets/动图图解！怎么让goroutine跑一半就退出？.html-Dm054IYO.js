import{_ as o,c as p,a as i,b as n,d as t,e,r as c,o as l}from"./app-1g0Y90Ac.js";const u={},d={href:"https://golangguide.top/golang/%E9%9D%A2%E8%AF%95%E9%A2%98/2.Go%E8%BF%9B%E9%98%B6.html",target:"_blank",rel:"noopener noreferrer"},r={href:"https://golangguide.top/golang/%E9%9D%A2%E8%AF%95%E9%A2%98/1.Go%E5%85%A5%E9%97%A8.html",target:"_blank",rel:"noopener noreferrer"},g={href:"https://golangguide.top/golang/%E5%B8%B8%E7%94%A8%E5%8C%85%E5%A4%A7%E5%85%A8.html",target:"_blank",rel:"noopener noreferrer"},m={href:"https://golangguide.top/golang/%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF.html",target:"_blank",rel:"noopener noreferrer"},k={href:"https://www.xiaobaidebug.top/2022/07/19/%E5%9B%BE%E8%A7%A3%E7%BD%91%E7%BB%9C/%E6%97%A2%E7%84%B6%E6%9C%89HTTP%E5%8D%8F%E8%AE%AE%EF%BC%8C%E4%B8%BA%E4%BB%80%E4%B9%88%E8%BF%98%E8%A6%81%E6%9C%89RPC%E5%8D%8F%E8%AE%AE%EF%BC%9F/",target:"_blank",rel:"noopener noreferrer"},v={href:"https://www.xiaobaidebug.top/2021/03/26/%E5%9B%BE%E8%A7%A3%E7%BD%91%E7%BB%9C/TCP%E7%B2%98%E5%8C%85%EF%BC%81%E6%95%B0%E6%8D%AE%E5%8C%85%EF%BC%9A%E6%88%91%E5%8F%AA%E6%98%AF%E7%8A%AF%E4%BA%86%E6%AF%8F%E4%B8%AA%E6%95%B0%E6%8D%AE%E5%8C%85%E9%83%BD%E4%BC%9A%E7%8A%AF%E7%9A%84%E9%94%99%EF%BC%8C%E7%A1%AC%E6%A0%B8%E5%9B%BE%E8%A7%A3/",target:"_blank",rel:"noopener noreferrer"},b={href:"https://www.xiaobaidebug.top/2021/05/25/%E5%9B%BE%E8%A7%A3%E7%BD%91%E7%BB%9C/%E5%8A%A8%E5%9B%BE%E5%9B%BE%E8%A7%A3%EF%BC%81%E6%97%A2%E7%84%B6IP%E5%B1%82%E4%BC%9A%E5%88%86%E7%89%87%EF%BC%8C%E4%B8%BA%E4%BB%80%E4%B9%88TCP%E5%B1%82%E4%B9%9F%E8%BF%98%E8%A6%81%E5%88%86%E6%AE%B5%EF%BC%9F/",target:"_blank",rel:"noopener noreferrer"};function E(f,s){const a=c("ExternalLinkIcon");return l(),p("div",null,[s[7]||(s[7]=i(`<figure><img src="https://cdn.xiaobaidebug.top/image/doutub_gif2.gif" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>光看标题，大家可能不太理解我说的是啥。</p><p>我们平时创建一个协程，跑一段逻辑，代码大概长这样。</p><div class="language-go line-numbers-mode" data-ext="go" data-title="go"><pre class="language-go"><code><span class="token keyword">package</span> main

<span class="token keyword">import</span> <span class="token punctuation">(</span>
	<span class="token string">&quot;fmt&quot;</span>
	<span class="token string">&quot;time&quot;</span>
<span class="token punctuation">)</span>
<span class="token keyword">func</span> <span class="token function">Foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
	fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">&quot;打印1&quot;</span><span class="token punctuation">)</span>
	<span class="token keyword">defer</span> fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">&quot;打印2&quot;</span><span class="token punctuation">)</span>
	fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">&quot;打印3&quot;</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>

<span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
	<span class="token keyword">go</span>  <span class="token function">Foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
	fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">&quot;打印4&quot;</span><span class="token punctuation">)</span>
	time<span class="token punctuation">.</span><span class="token function">Sleep</span><span class="token punctuation">(</span><span class="token number">1000</span><span class="token operator">*</span>time<span class="token punctuation">.</span>Second<span class="token punctuation">)</span>
<span class="token punctuation">}</span>

<span class="token comment">// 这段代码，正常运行会有下面的结果</span>
打印<span class="token number">4</span>
打印<span class="token number">1</span>
打印<span class="token number">3</span>
打印<span class="token number">2</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>注意</strong>这上面&quot;<strong>打印 2</strong>&quot;是在<code>defer</code>中的，所以会在函数结束前打印。因此后置于&quot;<strong>打印 3</strong>&quot;。</p><p>那么今天的问题是，如何让<code>Foo()</code>函数<strong>跑一半就结束</strong>，比如说跑到<strong>打印 2</strong>，就退出协程。输出如下结果</p><div class="language-go line-numbers-mode" data-ext="go" data-title="go"><pre class="language-go"><code>打印<span class="token number">4</span>
打印<span class="token number">1</span>
打印<span class="token number">2</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>也不卖关子了，我这边直接说答案。</p><p>在&quot;打印 2&quot;后面插入一个 <code>runtime.Goexit()</code>， 协程就会直接结束。并且结束前还能执行到<code>defer</code>里的<strong>打印 2</strong>。</p><div class="language-go line-numbers-mode" data-ext="go" data-title="go"><pre class="language-go"><code><span class="token keyword">package</span> main

<span class="token keyword">import</span> <span class="token punctuation">(</span>
	<span class="token string">&quot;fmt&quot;</span>
	<span class="token string">&quot;runtime&quot;</span>
	<span class="token string">&quot;time&quot;</span>
<span class="token punctuation">)</span>
<span class="token keyword">func</span> <span class="token function">Foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
	fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">&quot;打印1&quot;</span><span class="token punctuation">)</span>
	<span class="token keyword">defer</span> fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">&quot;打印2&quot;</span><span class="token punctuation">)</span>
	runtime<span class="token punctuation">.</span><span class="token function">Goexit</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">// 加入这行</span>
	fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">&quot;打印3&quot;</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>

<span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
	<span class="token keyword">go</span>  <span class="token function">Foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
	fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">&quot;打印4&quot;</span><span class="token punctuation">)</span>
	time<span class="token punctuation">.</span><span class="token function">Sleep</span><span class="token punctuation">(</span><span class="token number">1000</span><span class="token operator">*</span>time<span class="token punctuation">.</span>Second<span class="token punctuation">)</span>
<span class="token punctuation">}</span>


<span class="token comment">// 输出结果</span>
打印<span class="token number">4</span>
打印<span class="token number">1</span>
打印<span class="token number">2</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>可以看到<strong>打印 3</strong>这一行没出现了，协程确实提前结束了。</p><p>其实面试题到这里就讲完了，这一波自问自答可还行？</p><p>但这不是今天的重点，我们需要搞搞清楚内部的逻辑。</p><h2 id="runtime-goexit-是什么" tabindex="-1"><a class="header-anchor" href="#runtime-goexit-是什么"><span>runtime.Goexit()是什么？</span></a></h2><p>看一下内部实现。</p><div class="language-go line-numbers-mode" data-ext="go" data-title="go"><pre class="language-go"><code><span class="token keyword">func</span> <span class="token function">Goexit</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
	<span class="token comment">// 以下函数省略一些逻辑...</span>
	gp <span class="token operator">:=</span> <span class="token function">getg</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
	<span class="token keyword">for</span> <span class="token punctuation">{</span>
    <span class="token comment">// 获取defer并执行</span>
		d <span class="token operator">:=</span> gp<span class="token punctuation">.</span>_defer
		<span class="token function">reflectcall</span><span class="token punctuation">(</span><span class="token boolean">nil</span><span class="token punctuation">,</span> unsafe<span class="token punctuation">.</span><span class="token function">Pointer</span><span class="token punctuation">(</span>d<span class="token punctuation">.</span>fn<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">deferArgs</span><span class="token punctuation">(</span>d<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">uint32</span><span class="token punctuation">(</span>d<span class="token punctuation">.</span>siz<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">uint32</span><span class="token punctuation">(</span>d<span class="token punctuation">.</span>siz<span class="token punctuation">)</span><span class="token punctuation">)</span>
	<span class="token punctuation">}</span>
	<span class="token function">goexit1</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>

<span class="token keyword">func</span> <span class="token function">goexit1</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
	<span class="token function">mcall</span><span class="token punctuation">(</span>goexit0<span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>从代码上看，<code>runtime.Goexit()</code>会先执行一下<code>defer</code>里的方法，这里就解释了开头的代码里为什么<strong>在 defer 里的打印 2</strong>能正常输出。</p><p>然后代码再执行<code>goexit1</code>。本质就是对<code>goexit0</code>的简单封装。</p><p>我们可以把代码继续跟下去，看看<code>goexit0</code>做了什么。</p><div class="language-go line-numbers-mode" data-ext="go" data-title="go"><pre class="language-go"><code><span class="token comment">// goexit continuation on g0.</span>
<span class="token keyword">func</span> <span class="token function">goexit0</span><span class="token punctuation">(</span>gp <span class="token operator">*</span>g<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// 获取当前的 goroutine</span>
	_g_ <span class="token operator">:=</span> <span class="token function">getg</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
	<span class="token comment">// 将当前goroutine的状态置为 _Gdead</span>
	<span class="token function">casgstatus</span><span class="token punctuation">(</span>gp<span class="token punctuation">,</span> _Grunning<span class="token punctuation">,</span> _Gdead<span class="token punctuation">)</span>
  <span class="token comment">// 全局协程数减一</span>
	<span class="token keyword">if</span> <span class="token function">isSystemGoroutine</span><span class="token punctuation">(</span>gp<span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
		atomic<span class="token punctuation">.</span><span class="token function">Xadd</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>sched<span class="token punctuation">.</span>ngsys<span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span>
	<span class="token punctuation">}</span>

  <span class="token comment">// 省略各种清空逻辑...</span>

  <span class="token comment">// 把g从m上摘下来。</span>
  <span class="token function">dropg</span><span class="token punctuation">(</span><span class="token punctuation">)</span>


	<span class="token comment">// 把这个g放回到p的本地协程队列里，放不下放全局协程队列。</span>
	<span class="token function">gfput</span><span class="token punctuation">(</span>_g_<span class="token punctuation">.</span>m<span class="token punctuation">.</span>p<span class="token punctuation">.</span><span class="token function">ptr</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> gp<span class="token punctuation">)</span>

  <span class="token comment">// 重新调度，拿下一个可运行的协程出来跑</span>
	<span class="token function">schedule</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这段代码，信息密度比较大。</p><p>很多名词可能让人一脸懵。</p><p>简单描述下，Go 语言里有个<strong>GMP 模型</strong>的说法，<code>M</code>是内核线程，<code>G</code>也就是我们平时用的协程<code>goroutine</code>，<code>P</code>会在<code>G和M之间</code>做工具人，负责<strong>调度</strong><code>G</code>到<code>M</code>上运行。</p><figure><img src="https://cdn.xiaobaidebug.top/image/GMP图.png" alt="GMP图" tabindex="0" loading="lazy"><figcaption>GMP图</figcaption></figure><p>既然是<strong>调度</strong>，也就是说不是每个<code>G</code>都能一直处于运行状态，等 G 不能运行时，就把它存起来，再<strong>调度</strong>下一个能运行的 G 过来运行。</p><p>暂时不能运行的 G，P 上会有个<strong>本地队列</strong>去存放这些这些 G，P 的本地队列存不下的话，还有个全局队列，干的事情也类似。</p><p>了解这个背景后，再回到 <code>goexit0</code> 方法看看，做的事情就是将当前的协程 G 置为<code>_Gdead</code>状态，然后把它从 M 上摘下来，尝试放回到 P 的本地队列中。然后重新调度一波，获取另一个能跑的 G，拿出来跑。</p><figure><img src="https://cdn.xiaobaidebug.top/image/goexit.gif" alt="goexit" tabindex="0" loading="lazy"><figcaption>goexit</figcaption></figure><p>所以简单总结一下，<strong>只要执行 goexit 这个函数，当前协程就会退出，同时还能调度下一个可执行的协程出来跑。</strong></p><p>看到这里，大家应该就能理解，开头的代码里，为什么<code>runtime.Goexit()</code>能让协程只执行一半就结束了。</p><h2 id="goexit-的用途" tabindex="-1"><a class="header-anchor" href="#goexit-的用途"><span>goexit 的用途</span></a></h2><p>看是看懂了，但是会忍不住疑惑。<strong>面试这么问问，那只能说明你遇到了一个喜欢为难年轻人的面试官</strong>，但正经人谁会没事跑一半协程就结束呢？所以<code>goexit</code>的<strong>真实用途</strong>是啥？</p><p>有个<strong>小细节</strong>，不知道大家平时 debug 的时候有没有关注过。</p><figure><img src="https://cdn.xiaobaidebug.top/image/0bec52deb6276987.jpeg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>为了说明问题，这里先给出一段代码。</p><div class="language-go line-numbers-mode" data-ext="go" data-title="go"><pre class="language-go"><code><span class="token keyword">package</span> main

<span class="token keyword">import</span> <span class="token punctuation">(</span>
	<span class="token string">&quot;fmt&quot;</span>
	<span class="token string">&quot;time&quot;</span>
<span class="token punctuation">)</span>
<span class="token keyword">func</span> <span class="token function">Foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
	fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">&quot;打印1&quot;</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>

<span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
	<span class="token keyword">go</span>  <span class="token function">Foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
	fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">&quot;打印3&quot;</span><span class="token punctuation">)</span>
	time<span class="token punctuation">.</span><span class="token function">Sleep</span><span class="token punctuation">(</span><span class="token number">1000</span><span class="token operator">*</span>time<span class="token punctuation">.</span>Second<span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这是一段非常简单的代码，输出什么完全不重要。通过<code>go</code>关键字启动了一个<code>goroutine</code>执行<code>Foo()</code>，里面打印一下就结束，主协程<code>sleep</code>很长时间，只为<strong>死等</strong>。</p><p>这里我们新启动的协程里，在<code>Foo()</code>函数内随便打个断点。然后<code>debug</code>一下。</p><figure><img src="https://cdn.xiaobaidebug.top/image/image-20211024150223114.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>会发现，这个协程的堆栈底部是从<code>runtime.goexit()</code>里开始启动的。</p><p>如果大家平时有注意观察，会发现，<strong>其实所有的堆栈底部，都是从这个函数开始的</strong>。我们继续跟跟代码。</p><h2 id="goexit-是什么" tabindex="-1"><a class="header-anchor" href="#goexit-是什么"><span>goexit 是什么？</span></a></h2><p>从上面的<code>debug</code>堆栈里点进去会发现，这是个汇编函数，可以看出调用的是<code>runtime</code>包内的 <code>goexit1()</code> 函数。</p><div class="language-c line-numbers-mode" data-ext="c" data-title="c"><pre class="language-c"><code><span class="token comment">// The top-most function running on a goroutine</span>
<span class="token comment">// returns to goexit+PCQuantum.</span>
TEXT runtime·<span class="token function">goexit</span><span class="token punctuation">(</span>SB<span class="token punctuation">)</span><span class="token punctuation">,</span>NOSPLIT<span class="token punctuation">,</span>$<span class="token number">0</span><span class="token operator">-</span><span class="token number">0</span>
	BYTE	$<span class="token number">0x90</span>	<span class="token comment">// NOP</span>
	CALL	runtime·<span class="token function">goexit1</span><span class="token punctuation">(</span>SB<span class="token punctuation">)</span>	<span class="token comment">// does not return</span>
	<span class="token comment">// traceback from goexit1 must hit code range of goexit</span>
	BYTE	$<span class="token number">0x90</span>	<span class="token comment">// NOP</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>于是跟到了<code>pruntime/proc.go</code>里的代码中。</p><div class="language-go line-numbers-mode" data-ext="go" data-title="go"><pre class="language-go"><code><span class="token comment">// 省略部分代码</span>
<span class="token keyword">func</span> <span class="token function">goexit1</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
	<span class="token function">mcall</span><span class="token punctuation">(</span>goexit0<span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>是不是很熟悉，这不就是我们开头讲<code>runtime.Goexit()</code>里内部执行的<code>goexit0</code>吗。</p><h2 id="为什么每个堆栈底部都是这个方法" tabindex="-1"><a class="header-anchor" href="#为什么每个堆栈底部都是这个方法"><span>为什么每个堆栈底部都是这个方法？</span></a></h2><p>我们首先需要知道的是，函数栈的执行过程，是先进后出。</p><p>假设我们有以下代码</p><div class="language-go line-numbers-mode" data-ext="go" data-title="go"><pre class="language-go"><code><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
	<span class="token function">B</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>

<span class="token keyword">func</span> <span class="token function">B</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
	<span class="token function">A</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>

<span class="token keyword">func</span> <span class="token function">A</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>

<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面的代码是 main 运行 B 函数，B 函数再运行 A 函数，代码执行时就跟下面的动图那样。</p><figure><img src="https://cdn.xiaobaidebug.top/image/函数堆栈.gif" alt="函数堆栈执行顺序" tabindex="0" loading="lazy"><figcaption>函数堆栈执行顺序</figcaption></figure><p>这个是先进后出的过程，也就是我们常说的函数栈，执行完<strong>子函数 A()<strong>后，就会回到</strong>父函数 B()<strong>中，执行完</strong>B()后</strong>，最后就会回到<strong>main()</strong>。这里的栈底是<code>main()</code>，如果在<strong>栈底</strong>插入的是 <code>goexit</code> 的话，那么当程序执行结束的时候就都能跑到<code>goexit</code>里去。</p><p>结合前面讲过的内容，我们就能知道，此时栈底的<code>goexit</code>，会在协程内的业务代码跑完后被执行到，从而实现协程退出，并调度下一个<strong>可执行的 G</strong>来运行。</p><br><p>那么问题又来了，栈底插入<code>goexit</code>这件事是谁做的，什么时候做的？</p><p>直接说答案，这个在<code>runtime/proc.go</code>里有个<code>newproc1</code>方法，只要是<strong>创建协程</strong>都会用到这个方法。里面有个地方是这么写的。</p><div class="language-go line-numbers-mode" data-ext="go" data-title="go"><pre class="language-go"><code><span class="token keyword">func</span> <span class="token function">newproc1</span><span class="token punctuation">(</span>fn <span class="token operator">*</span>funcval<span class="token punctuation">,</span> argp unsafe<span class="token punctuation">.</span>Pointer<span class="token punctuation">,</span> narg <span class="token builtin">int32</span><span class="token punctuation">,</span> callergp <span class="token operator">*</span>g<span class="token punctuation">,</span> callerpc <span class="token builtin">uintptr</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
	<span class="token comment">// 获取当前g</span>
  _g_ <span class="token operator">:=</span> <span class="token function">getg</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
	<span class="token comment">// 获取当前g所在的p</span>
	_p_ <span class="token operator">:=</span> _g_<span class="token punctuation">.</span>m<span class="token punctuation">.</span>p<span class="token punctuation">.</span><span class="token function">ptr</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
  <span class="token comment">// 创建一个新 goroutine</span>
	newg <span class="token operator">:=</span> <span class="token function">gfget</span><span class="token punctuation">(</span>_p_<span class="token punctuation">)</span>

	<span class="token comment">// 底部插入goexit</span>
	newg<span class="token punctuation">.</span>sched<span class="token punctuation">.</span>pc <span class="token operator">=</span> <span class="token function">funcPC</span><span class="token punctuation">(</span>goexit<span class="token punctuation">)</span> <span class="token operator">+</span> sys<span class="token punctuation">.</span>PCQuantum
	newg<span class="token punctuation">.</span>sched<span class="token punctuation">.</span>g <span class="token operator">=</span> <span class="token function">guintptr</span><span class="token punctuation">(</span>unsafe<span class="token punctuation">.</span><span class="token function">Pointer</span><span class="token punctuation">(</span>newg<span class="token punctuation">)</span><span class="token punctuation">)</span>
	<span class="token comment">// 把新创建的g放到p中</span>
	<span class="token function">runqput</span><span class="token punctuation">(</span>_p_<span class="token punctuation">,</span> newg<span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">)</span>

	<span class="token comment">// ...</span>
<span class="token punctuation">}</span>

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>主要的逻辑是获取当前协程 G 所在的调度器 P，然后创建一个新 G，并在栈底插入一个 goexit。</p><p>所以我们每次 debug 的时候，就都能看到函数栈底部有个 goexit 函数。</p><h2 id="main-函数也是个协程-栈底也是-goexit" tabindex="-1"><a class="header-anchor" href="#main-函数也是个协程-栈底也是-goexit"><span>main 函数也是个协程，栈底也是 goexit？</span></a></h2><p>关于 main 函数栈底是不是也有个<code>goexit</code>，我们对下面代码断点看下。直接得出结果。</p><figure><img src="https://cdn.xiaobaidebug.top/image/image-20211025073255360.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>main 函数栈底也是<code>goexit()</code>。</p><p>从 <code>asm_amd64.s</code>可以看到 Go 程序启动的流程，这里提到的 <code>runtime·mainPC</code> 其实就是 <code>runtime.main</code>.</p><div class="language-c line-numbers-mode" data-ext="c" data-title="c"><pre class="language-c"><code>	<span class="token comment">// create a new goroutine to start program</span>
	MOVQ	$runtime·<span class="token function">mainPC</span><span class="token punctuation">(</span>SB<span class="token punctuation">)</span><span class="token punctuation">,</span> AX		<span class="token comment">// 也就是runtime.main</span>
	PUSHQ	AX
	PUSHQ	$<span class="token number">0</span>			<span class="token comment">// arg size</span>
	CALL	runtime·<span class="token function">newproc</span><span class="token punctuation">(</span>SB<span class="token punctuation">)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>通过<code>runtime·newproc</code>创建<code>runtime.main</code>协程，然后在<code>runtime.main</code>里会启动<code>main.main</code>函数，这个就是我们平时写的那个 main 函数了。</p><div class="language-go line-numbers-mode" data-ext="go" data-title="go"><pre class="language-go"><code><span class="token comment">// runtime/proc.go</span>
<span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
	<span class="token comment">// 省略大量代码</span>
	fn <span class="token operator">:=</span> main_main <span class="token comment">// 其实就是我们的main函数入口</span>
	<span class="token function">fn</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>

<span class="token comment">//go:linkname main_main main.main</span>
<span class="token keyword">func</span> <span class="token function">main_main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>结论是，<strong>其实 main 函数也是由 newproc 创建的，只要通过 newproc 创建的 goroutine，栈底就会有一个 goexit。</strong></p><h2 id="os-exit-和-runtime-goexit-有什么区别" tabindex="-1"><a class="header-anchor" href="#os-exit-和-runtime-goexit-有什么区别"><span>os.Exit()和 runtime.Goexit()有什么区别</span></a></h2><p>最后再回到开头的问题，实现一下首尾呼应。</p><p>开头的面试题，除了<code>runtime.Goexit()</code>，是不是还可以改为用<code>os.Exit()</code>？</p><p>同样都是带有&quot;退出&quot;的含义，两者退出的<strong>对象</strong>不同。<code>os.Exit()</code> 指的是整个<strong>进程</strong>退出；而<code>runtime.Goexit()</code>指的是<strong>协程</strong>退出。</p><p>可想而知，改用<code>os.Exit()</code> 这种情况下，defer 里的内容就不会被执行到了。</p><div class="language-go line-numbers-mode" data-ext="go" data-title="go"><pre class="language-go"><code><span class="token keyword">package</span> main

<span class="token keyword">import</span> <span class="token punctuation">(</span>
	<span class="token string">&quot;fmt&quot;</span>
	<span class="token string">&quot;os&quot;</span>
	<span class="token string">&quot;time&quot;</span>
<span class="token punctuation">)</span>
<span class="token keyword">func</span> <span class="token function">Foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
	fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">&quot;打印1&quot;</span><span class="token punctuation">)</span>
	<span class="token keyword">defer</span> fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">&quot;打印2&quot;</span><span class="token punctuation">)</span>
	os<span class="token punctuation">.</span><span class="token function">Exit</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span>
	fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">&quot;打印3&quot;</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>

<span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
	<span class="token keyword">go</span>  <span class="token function">Foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
	fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">&quot;打印4&quot;</span><span class="token punctuation">)</span>
	time<span class="token punctuation">.</span><span class="token function">Sleep</span><span class="token punctuation">(</span><span class="token number">1000</span><span class="token operator">*</span>time<span class="token punctuation">.</span>Second<span class="token punctuation">)</span>
<span class="token punctuation">}</span>

<span class="token comment">// 输出结果</span>
打印<span class="token number">4</span>
打印<span class="token number">1</span>

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="总结" tabindex="-1"><a class="header-anchor" href="#总结"><span>总结</span></a></h2><ul><li>通过 <code>runtime.Goexit()</code>可以做到提前结束协程，且结束前还能执行到 defer 的内容</li><li><code>runtime.Goexit()</code>其实是对 goexit0 的封装，只要执行 goexit0 这个函数，当前协程就会退出，同时还能调度下一个可执行的协程出来跑。</li><li>通过<code>newproc</code>可以创建出新的<code>goroutine</code>，它会在函数栈底部插入一个 goexit。</li><li><code>os.Exit()</code> 指的是整个<strong>进程</strong>退出；而<code>runtime.Goexit()</code>指的是<strong>协程</strong>退出。两者含义有区别。</li></ul><h2 id="最后" tabindex="-1"><a class="header-anchor" href="#最后"><span>最后</span></a></h2><p>无用的知识又增加了。</p><p>一般情况下，业务开发中，谁会没事执行这个函数呢？</p><p><strong>但是开发中不关心，不代表面试官不关心！</strong></p><p>下次面试官问你，**如果想在 goroutine 执行一半就退出协程，该怎么办？**你知道该怎么回答了吧？</p><br><p>好了，兄弟们，有没有发现这篇文章写的又水又短，真的是因为我变懒了吗？</p><p>不！</p><p>当然不！</p><p>我是为了兄弟们的身体健康考虑，保持蹲姿太久对身体不好，懂？</p><br><p><strong>如果文章对你有帮助，欢迎.....</strong></p><p>算了。</p><p>一起在知识的海洋里呛水吧</p><p>我是小白，我们下期见！</p><br><p>关注公众号:【小白 debug】</p><br><p>不满足于在留言区说骚话？</p><p>加我，我们建了个划水吹牛皮群，在群里，你可以跟你下次跳槽可能遇到的同事或面试官聊点有趣的话题。就<strong>超！开！心！</strong></p><img src="https://cdn.xiaobaidebug.top/image-20220522162616202.png" width="50%" align="center"><h2 id="文章推荐" tabindex="-1"><a class="header-anchor" href="#文章推荐"><span>文章推荐：</span></a></h2>`,100)),n("ul",null,[n("li",null,[n("p",null,[n("a",d,[s[0]||(s[0]=t("golang进阶面试题八股文合集")),e(a)])])]),n("li",null,[n("p",null,[n("a",r,[s[1]||(s[1]=t("golang基础面试题八股文合集")),e(a)])])]),n("li",null,[n("p",null,[n("a",g,[s[2]||(s[2]=t("golang常用标准库第三方库大全")),e(a)])])]),n("li",null,[n("p",null,[n("a",m,[s[3]||(s[3]=t("golang学习路线")),e(a)])])]),n("li",null,[n("p",null,[n("a",k,[s[4]||(s[4]=t("既然有 HTTP 协议，为什么还要有 RPC")),e(a)])])]),n("li",null,[n("p",null,[n("a",v,[s[5]||(s[5]=t("TCP 粘包 数据包：我只是犯了每个数据包都会犯的错 |硬核图解")),e(a)])])]),n("li",null,[n("p",null,[n("a",b,[s[6]||(s[6]=t("动图图解！既然 IP 层会分片，为什么 TCP 层也还要分段？")),e(a)])])])])])}const B=o(u,[["render",E],["__file","动图图解！怎么让goroutine跑一半就退出？.html.vue"]]),h=JSON.parse('{"path":"/golang/%E6%A0%B8%E5%BF%83%E7%9F%A5%E8%AF%86%E7%82%B9/%E5%8A%A8%E5%9B%BE%E5%9B%BE%E8%A7%A3%EF%BC%81%E6%80%8E%E4%B9%88%E8%AE%A9goroutine%E8%B7%91%E4%B8%80%E5%8D%8A%E5%B0%B1%E9%80%80%E5%87%BA%EF%BC%9F.html","title":"动图图解！怎么让goroutine跑一半就退出？","lang":"zh-CN","frontmatter":{"title":"动图图解！怎么让goroutine跑一半就退出？","date":"2021-11-15T22:57:55.000Z","tags":null,"categories":"golang面试题","description":" 光看标题，大家可能不太理解我说的是啥。 我们平时创建一个协程，跑一段逻辑，代码大概长这样。 注意这上面\\"打印 2\\"是在defer中的，所以会在函数结束前打印。因此后置于\\"打印 3\\"。 那么今天的问题是，如何让Foo()函数跑一半就结束，比如说跑到打印 2，就退出协程。输出如下结果 也不卖关子了，我这边直接说答案。 在\\"打印 2\\"后面插入一个 runt...","head":[["meta",{"property":"og:url","content":"https://golangguide.top/golang/%E6%A0%B8%E5%BF%83%E7%9F%A5%E8%AF%86%E7%82%B9/%E5%8A%A8%E5%9B%BE%E5%9B%BE%E8%A7%A3%EF%BC%81%E6%80%8E%E4%B9%88%E8%AE%A9goroutine%E8%B7%91%E4%B8%80%E5%8D%8A%E5%B0%B1%E9%80%80%E5%87%BA%EF%BC%9F.html"}],["meta",{"property":"og:site_name","content":"golang全栈指南"}],["meta",{"property":"og:title","content":"动图图解！怎么让goroutine跑一半就退出？"}],["meta",{"property":"og:description","content":" 光看标题，大家可能不太理解我说的是啥。 我们平时创建一个协程，跑一段逻辑，代码大概长这样。 注意这上面\\"打印 2\\"是在defer中的，所以会在函数结束前打印。因此后置于\\"打印 3\\"。 那么今天的问题是，如何让Foo()函数跑一半就结束，比如说跑到打印 2，就退出协程。输出如下结果 也不卖关子了，我这边直接说答案。 在\\"打印 2\\"后面插入一个 runt..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:image","content":"https://cdn.xiaobaidebug.top/image/doutub_gif2.gif"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2024-05-12T13:55:00.000Z"}],["meta",{"name":"twitter:card","content":"summary_large_image"}],["meta",{"name":"twitter:image:alt","content":"动图图解！怎么让goroutine跑一半就退出？"}],["meta",{"property":"article:author","content":"小白debug"}],["meta",{"property":"article:published_time","content":"2021-11-15T22:57:55.000Z"}],["meta",{"property":"article:modified_time","content":"2024-05-12T13:55:00.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"动图图解！怎么让goroutine跑一半就退出？\\",\\"image\\":[\\"https://cdn.xiaobaidebug.top/image/doutub_gif2.gif\\",\\"https://cdn.xiaobaidebug.top/image/GMP图.png\\",\\"https://cdn.xiaobaidebug.top/image/goexit.gif\\",\\"https://cdn.xiaobaidebug.top/image/0bec52deb6276987.jpeg\\",\\"https://cdn.xiaobaidebug.top/image/image-20211024150223114.png\\",\\"https://cdn.xiaobaidebug.top/image/%E5%87%BD%E6%95%B0%E5%A0%86%E6%A0%88.gif\\",\\"https://cdn.xiaobaidebug.top/image/image-20211025073255360.png\\"],\\"datePublished\\":\\"2021-11-15T22:57:55.000Z\\",\\"dateModified\\":\\"2024-05-12T13:55:00.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"小白debug\\",\\"url\\":\\"https://xiaobaidebug.top/\\"}]}"],["link",{"rel":"canonical","href":"https://golangguide.top/golang/%E6%A0%B8%E5%BF%83%E7%9F%A5%E8%AF%86%E7%82%B9/%E5%8A%A8%E5%9B%BE%E5%9B%BE%E8%A7%A3%EF%BC%81%E6%80%8E%E4%B9%88%E8%AE%A9goroutine%E8%B7%91%E4%B8%80%E5%8D%8A%E5%B0%B1%E9%80%80%E5%87%BA%EF%BC%9F.html"}],["meta",{"property":"og:url","content":"https://golangguide.top/golang/%E6%A0%B8%E5%BF%83%E7%9F%A5%E8%AF%86%E7%82%B9/%E5%8A%A8%E5%9B%BE%E5%9B%BE%E8%A7%A3%EF%BC%81%E6%80%8E%E4%B9%88%E8%AE%A9goroutine%E8%B7%91%E4%B8%80%E5%8D%8A%E5%B0%B1%E9%80%80%E5%87%BA%EF%BC%9F.html"}],["meta",{"property":"og:site_name","content":"golang全栈指南"}],["meta",{"property":"og:title","content":"动图图解！怎么让goroutine跑一半就退出？"}],["meta",{"property":"og:description","content":" 光看标题，大家可能不太理解我说的是啥。 我们平时创建一个协程，跑一段逻辑，代码大概长这样。 注意这上面\\"打印 2\\"是在defer中的，所以会在函数结束前打印。因此后置于\\"打印 3\\"。 那么今天的问题是，如何让Foo()函数跑一半就结束，比如说跑到打印 2，就退出协程。输出如下结果 也不卖关子了，我这边直接说答案。 在\\"打印 2\\"后面插入一个 runt..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2024-05-12T13:55:00.000Z"}],["meta",{"property":"article:published_time","content":"2021-11-15T22:57:55.000Z"}],["meta",{"property":"article:modified_time","content":"2024-05-12T13:55:00.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"动图图解！怎么让goroutine跑一半就退出？\\",\\"image\\":[\\"\\"],\\"datePublished\\":\\"2021-11-15T22:57:55.000Z\\",\\"dateModified\\":\\"2024-05-12T13:55:00.000Z\\",\\"author\\":[]}"]]},"headers":[{"level":2,"title":"runtime.Goexit()是什么？","slug":"runtime-goexit-是什么","link":"#runtime-goexit-是什么","children":[]},{"level":2,"title":"goexit 的用途","slug":"goexit-的用途","link":"#goexit-的用途","children":[]},{"level":2,"title":"goexit 是什么？","slug":"goexit-是什么","link":"#goexit-是什么","children":[]},{"level":2,"title":"为什么每个堆栈底部都是这个方法？","slug":"为什么每个堆栈底部都是这个方法","link":"#为什么每个堆栈底部都是这个方法","children":[]},{"level":2,"title":"main 函数也是个协程，栈底也是 goexit？","slug":"main-函数也是个协程-栈底也是-goexit","link":"#main-函数也是个协程-栈底也是-goexit","children":[]},{"level":2,"title":"os.Exit()和 runtime.Goexit()有什么区别","slug":"os-exit-和-runtime-goexit-有什么区别","link":"#os-exit-和-runtime-goexit-有什么区别","children":[]},{"level":2,"title":"总结","slug":"总结","link":"#总结","children":[]},{"level":2,"title":"最后","slug":"最后","link":"#最后","children":[]},{"level":2,"title":"文章推荐：","slug":"文章推荐","link":"#文章推荐","children":[]}],"git":{"createdTime":1708315540000,"updatedTime":1715522100000,"contributors":[{"name":"xiaobai","email":"xiaobaidebug@gmail.com","commits":2},{"name":"xiaobai-tech","email":"948485496@qq.com","commits":1}]},"readingTime":{"minutes":10.04,"words":3011},"filePathRelative":"golang/核心知识点/动图图解！怎么让goroutine跑一半就退出？.md","localizedDate":"2021年11月15日","autoDesc":true}');export{B as comp,h as data};
