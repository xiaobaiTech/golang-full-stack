import{_ as a}from"./plugin-vue_export-helper-DlAUqK2U.js";import{r as t,o as e,c as p,a as n,b as o,d as i,e as c}from"./app-BHIpk5aV.js";const r={},l=c('<h1 id="为什么大家说-mysql-数据库单表最大两千万-依据是啥" tabindex="-1"><a class="header-anchor" href="#为什么大家说-mysql-数据库单表最大两千万-依据是啥"><span>为什么大家说 mysql 数据库单表最大两千万？依据是啥？</span></a></h1><br><p>故事从好多年前说起。</p><p>想必大家也听说过数据库单表<strong>建议最大 2kw</strong>条数据这个说法。如果超过了，性能就会下降得比较厉害。</p><p>巧了。</p><p>我也听说过。</p><p><strong>但我不接受它的建议，硬是单表装了 1 亿条数据。</strong></p><p>这时候，我们组里新来的实习生看到了之后，天真无邪的问我：&quot;单表不是建议最大两千万吗？为什么这个表都<strong>放了 1 个亿还不分库分表</strong>&quot;？</p><p>我能说我是<strong>因为懒</strong>吗？我当初设计时哪里想到这表竟然能涨这么快。。。</p><p>我不能。</p><p>说了等于承认自己是<strong>开发组里的毒瘤</strong>，虽然我确实是，但我<strong>不能承认</strong>。</p><p>我如坐针毡，如芒刺背，如鲠在喉。</p><p>开始了一波骚操作。</p><p>&quot;我这么做是有道理的&quot;</p><p>&quot;虽然这个表很大，但你有没有发现它查询其实还是很快&quot;</p><p>&quot;这个 2kw 是个建议值，我们要来看下这个 2kw 是怎么来的&quot;</p><br><h2 id="数据库单表行数最大多大" tabindex="-1"><a class="header-anchor" href="#数据库单表行数最大多大"><span>数据库单表行数最大多大？</span></a></h2><p>我们先看下单表行数理论最大值是多少。</p><p>建表的 SQL 是这么写的，</p><div class="language-sql line-numbers-mode" data-ext="sql" data-title="sql"><pre class="language-sql"><code><span class="token keyword">CREATE</span> <span class="token keyword">TABLE</span> <span class="token identifier"><span class="token punctuation">`</span>user<span class="token punctuation">`</span></span> <span class="token punctuation">(</span>\n  <span class="token identifier"><span class="token punctuation">`</span>id<span class="token punctuation">`</span></span> <span class="token keyword">int</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span> <span class="token keyword">unsigned</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span> <span class="token keyword">AUTO_INCREMENT</span> <span class="token keyword">COMMENT</span> <span class="token string">&#39;主键&#39;</span><span class="token punctuation">,</span>\n  <span class="token identifier"><span class="token punctuation">`</span>name<span class="token punctuation">`</span></span> <span class="token keyword">varchar</span><span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">)</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span> <span class="token keyword">DEFAULT</span> <span class="token string">&#39;&#39;</span> <span class="token keyword">COMMENT</span> <span class="token string">&#39;名字&#39;</span><span class="token punctuation">,</span>\n  <span class="token identifier"><span class="token punctuation">`</span>age<span class="token punctuation">`</span></span> <span class="token keyword">int</span><span class="token punctuation">(</span><span class="token number">11</span><span class="token punctuation">)</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span> <span class="token keyword">DEFAULT</span> <span class="token string">&#39;0&#39;</span> <span class="token keyword">COMMENT</span> <span class="token string">&#39;年龄&#39;</span><span class="token punctuation">,</span>\n  <span class="token keyword">PRIMARY</span> <span class="token keyword">KEY</span> <span class="token punctuation">(</span><span class="token identifier"><span class="token punctuation">`</span>id<span class="token punctuation">`</span></span><span class="token punctuation">)</span><span class="token punctuation">,</span>\n  <span class="token keyword">KEY</span> <span class="token identifier"><span class="token punctuation">`</span>idx_age<span class="token punctuation">`</span></span> <span class="token punctuation">(</span><span class="token identifier"><span class="token punctuation">`</span>age<span class="token punctuation">`</span></span><span class="token punctuation">)</span>\n<span class="token punctuation">)</span> <span class="token keyword">ENGINE</span><span class="token operator">=</span><span class="token keyword">InnoDB</span> <span class="token keyword">AUTO_INCREMENT</span><span class="token operator">=</span><span class="token number">100037</span> <span class="token keyword">DEFAULT</span> <span class="token keyword">CHARSET</span><span class="token operator">=</span>utf8<span class="token punctuation">;</span>\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>其中 id 就是主键。主键本身唯一，也就是说主键的大小可以限制表的上限。</p><p>如果主键声明为<code>int</code>大小，也就是 32 位，那么能支持 2^32-1，也就是<strong>21 个亿</strong>左右。</p><p>如果是<code>bigint</code>，那就是 2^64-1，但这个<strong>数字太大</strong>，一般还没到这个限制之前，<strong>磁盘先受不了</strong>。</p><p>搞离谱点。</p><p>如果我把主键声明为 <code>tinyint</code>，一个字节，8 位，最大 2^8-1，也就是<code>255</code>。</p><div class="language-sql line-numbers-mode" data-ext="sql" data-title="sql"><pre class="language-sql"><code><span class="token keyword">CREATE</span> <span class="token keyword">TABLE</span> <span class="token identifier"><span class="token punctuation">`</span>user<span class="token punctuation">`</span></span> <span class="token punctuation">(</span>\n  <span class="token identifier"><span class="token punctuation">`</span>id<span class="token punctuation">`</span></span> <span class="token keyword">tinyint</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span> <span class="token keyword">unsigned</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span> <span class="token keyword">AUTO_INCREMENT</span> <span class="token keyword">COMMENT</span> <span class="token string">&#39;主键&#39;</span><span class="token punctuation">,</span>\n  <span class="token identifier"><span class="token punctuation">`</span>name<span class="token punctuation">`</span></span> <span class="token keyword">varchar</span><span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">)</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span> <span class="token keyword">DEFAULT</span> <span class="token string">&#39;&#39;</span> <span class="token keyword">COMMENT</span> <span class="token string">&#39;名字&#39;</span><span class="token punctuation">,</span>\n  <span class="token identifier"><span class="token punctuation">`</span>age<span class="token punctuation">`</span></span> <span class="token keyword">int</span><span class="token punctuation">(</span><span class="token number">11</span><span class="token punctuation">)</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span> <span class="token keyword">DEFAULT</span> <span class="token string">&#39;0&#39;</span> <span class="token keyword">COMMENT</span> <span class="token string">&#39;年龄&#39;</span><span class="token punctuation">,</span>\n  <span class="token keyword">PRIMARY</span> <span class="token keyword">KEY</span> <span class="token punctuation">(</span><span class="token identifier"><span class="token punctuation">`</span>id<span class="token punctuation">`</span></span><span class="token punctuation">)</span><span class="token punctuation">,</span>\n  <span class="token keyword">KEY</span> <span class="token identifier"><span class="token punctuation">`</span>idx_age<span class="token punctuation">`</span></span> <span class="token punctuation">(</span><span class="token identifier"><span class="token punctuation">`</span>age<span class="token punctuation">`</span></span><span class="token punctuation">)</span>\n<span class="token punctuation">)</span> <span class="token keyword">ENGINE</span><span class="token operator">=</span><span class="token keyword">InnoDB</span> <span class="token keyword">AUTO_INCREMENT</span><span class="token operator">=</span><span class="token number">0</span> <span class="token keyword">DEFAULT</span> <span class="token keyword">CHARSET</span><span class="token operator">=</span>utf8<span class="token punctuation">;</span>\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>如果我想插入一个 id=256 的数据，那<strong>就会报错</strong>。</p><div class="language-sql line-numbers-mode" data-ext="sql" data-title="sql"><pre class="language-sql"><code>mysql<span class="token operator">&gt;</span> <span class="token keyword">INSERT</span> <span class="token keyword">INTO</span> <span class="token identifier"><span class="token punctuation">`</span>tmp<span class="token punctuation">`</span></span> <span class="token punctuation">(</span><span class="token identifier"><span class="token punctuation">`</span>id<span class="token punctuation">`</span></span><span class="token punctuation">,</span> <span class="token identifier"><span class="token punctuation">`</span>name<span class="token punctuation">`</span></span><span class="token punctuation">,</span> <span class="token identifier"><span class="token punctuation">`</span>age<span class="token punctuation">`</span></span><span class="token punctuation">)</span> <span class="token keyword">VALUES</span> <span class="token punctuation">(</span><span class="token number">256</span><span class="token punctuation">,</span> <span class="token string">&#39;&#39;</span><span class="token punctuation">,</span> <span class="token number">60</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\nERROR <span class="token number">1264</span> <span class="token punctuation">(</span><span class="token number">22003</span><span class="token punctuation">)</span>: <span class="token keyword">Out</span> <span class="token keyword">of</span> range <span class="token keyword">value</span> <span class="token keyword">for</span> <span class="token keyword">column</span> <span class="token string">&#39;id&#39;</span> at <span class="token keyword">row</span> <span class="token number">1</span>\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>也就是说，<code>tinyint</code>主键限制表内最多 255 条数据。</p><p>那除了主键，还有哪些因素会影响行数？</p><br><h2 id="索引的结构" tabindex="-1"><a class="header-anchor" href="#索引的结构"><span>索引的结构</span></a></h2><p>索引内部是用的 B+树，这个也是八股文老股了，大家估计也背得很熟了。</p><p>为了不让大家有过于强烈的审丑疲劳，今天我尝试从另外一个角度给大家讲讲这玩意。</p><br><h3 id="页的结构" tabindex="-1"><a class="header-anchor" href="#页的结构"><span>页的结构</span></a></h3><p>假设我们有这么一张 user 数据表。</p><figure><img src="https://cdn.xiaobaidebug.top/image/user表数据库原始状态2.drawio.png" alt="user表" tabindex="0" loading="lazy"><figcaption>user表</figcaption></figure><p>其中 id 是<strong>唯一主键</strong>。</p><p>这看起来的一行行数据，为了方便，我们后面就叫它们<strong>record</strong>吧。</p><p>这张表看起来就跟个 excel 表格一样。excel 的数据在硬盘上是一个 xx.excel 的文件。</p><p>而上面 user 表数据，在硬盘上其实也是类似，放在了 user.<strong>ibd</strong>文件下，<code>user.idb</code>的含义是 user 表的 innodb data 文件，专业点，又叫<strong>表空间</strong>。</p><p>虽然在数据表里，record 们看起来是挨在一起的。但实际上在 user.ibd 里 record 们被分成很多小份的<strong>数据页</strong>，每份大小 16k。</p><p>类似于下面这样。</p><figure><img src="https://cdn.xiaobaidebug.top/image/ibd文件内部有大量的页.png" alt="ibd文件内部有大量的页" tabindex="0" loading="lazy"><figcaption>ibd文件内部有大量的页</figcaption></figure><p>我们把视角聚焦一下，放到页上面。</p><p>整个页<code>16k</code>，不大，但也不可能全用来放 record 对吧。</p><p>因为 record 们被分成好多份，放到好多页里了，为了唯一标识具体是哪一页，那就需要引入<strong>页号</strong>（其实是一个表空间的地址偏移量）。同时为了把这些数据页给关联起来，于是引入了<strong>前后指针</strong>，用于指向前后的页。这些都被加到了<strong>页头</strong>里。</p><p>页是需要读写的，16k 说小也不小，写一半电源线被拔了也是有可能发生的，所以为了保证数据页的正确性，还引入了校验码。这个被加到了<strong>页尾</strong>。</p><p>那剩下的空间，才是用来放我们的 record 的。而 record 如果行数特别多的话，进入到页内时挨个遍历，效率也不太行，所以为这些数据生成了一个<strong>页目录</strong>，具体实现细节不重要。只需要知道，它可以通过<strong>二分查找</strong>的方式将查找效率<strong>从 O(n) 变成 O(lgn)</strong>。</p><p><img src="https://cdn.xiaobaidebug.top/image/页结构.png" alt="页结构" loading="lazy"><br></p><h3 id="从页到索引" tabindex="-1"><a class="header-anchor" href="#从页到索引"><span>从页到索引</span></a></h3><p>如果想查一条 record，我们可以把表空间里每一页都捞出来，再把里面的 record 捞出来挨个判断是不是我们要找的。</p><p>行数量小的时候，这么操作也没啥问题。</p><p><strong>行数量大了，性能就慢了</strong>，于是为了加速搜索，我们可以在每个数据页里选出<strong>主键 id 最小</strong>的 record，而且只需要它们的<strong>主键 id 和所在页的页号</strong>。组成<strong>新的 record</strong>，放入到一个新生成的一个数据页中，这个<strong>新数据页跟之前的页结构没啥区别，而且大小还是 16k。</strong></p><p>但为了跟之前的数据页进行区分。数据页里加入了<strong>页层级（page level）<strong>的信息，从 0 开始往上算。于是页与页之间就有了</strong>上下层级</strong>的概念，就像下面这样。</p><figure><img src="https://cdn.xiaobaidebug.top/两层B加树结构.png" alt="两层B+树结构" tabindex="0" loading="lazy"><figcaption>两层B+树结构</figcaption></figure><p>突然页跟页之间看起来就像是一棵倒过来的树了。也就是我们常说的<strong>B+树</strong>索引。</p><p>最下面那一层，<strong>page level 为 0</strong>，也就是所谓的<strong>叶子结点</strong>，其余都叫<strong>非叶子结点</strong>。</p><p>上面展示的是<strong>两层</strong>的树，如果数据变多了，我们还可以再通过类似的方法，再往上构建一层。就成了<strong>三层</strong>的树。</p><figure><img src="https://cdn.xiaobaidebug.top/B加树结构7.drawio.png" alt="B+树结构" tabindex="0" loading="lazy"><figcaption>B+树结构</figcaption></figure><br><p>那现在我们就可以通过这样一棵 B+树加速查询。举个例子。</p><p>比方说我们想要查找行数据 5。会先从顶层页的 record 们入手。<strong>record 里包含了主键 id 和页号（页地址）</strong>。看下图黄色的箭头，向左最小 id 是 1，向右最小 id 是 7。那 id=5 的数据如果存在，那必定在左边箭头。于是顺着的 record 的页地址就到了<code>6号</code>数据页里，再判断 id=5&gt;4，所以肯定在右边的数据页里，于是加载<code>105号</code>数据页。在数据页里找到 id=5 的数据行，完成查询。</p><figure><img src="https://cdn.xiaobaidebug.top/B加树查询过程.png" alt="B+树查询过程" tabindex="0" loading="lazy"><figcaption>B+树查询过程</figcaption></figure><p>另外需要注意的是，上面的页的页号并不是连续的，它们在磁盘里也不一定是挨在一起的。</p><p>这个过程中查询了三个页，如果这三个页都在磁盘中（没有被提前加载到内存中），那么<strong>最多</strong>需要经历三次<strong>磁盘 IO 查询</strong>，它们才能被加载到内存中。</p><br><h2 id="b-树承载的记录数量" tabindex="-1"><a class="header-anchor" href="#b-树承载的记录数量"><span>B+树承载的记录数量</span></a></h2><p>从上面的结构里可以看出 B+树的<strong>最末级叶子结点</strong>里放了 record 数据。而<strong>非叶子结点</strong>里则放了用来加速查询的索引数据。</p><p>也就是说</p><p>同样一个 16k 的页，非叶子节点里每一条数据都指向一个新的页，而新的页有两种可能。</p><ul><li>如果是末级叶子节点的话，那么里面放的就是一行行 record 数据。</li><li>如果是非叶子节点，那么就会循环继续指向新的数据页。</li></ul><p>假设</p><ul><li>非叶子结点内指向其他内存页的指针数量为<code>x</code></li><li>叶子节点内能容纳的 record 数量为<code>y</code></li><li>B+树的层数为<code>z</code></li></ul><figure><img src="https://cdn.xiaobaidebug.top/image/总行数的计算方法.png" alt="总行数的计算方法" tabindex="0" loading="lazy"><figcaption>总行数的计算方法</figcaption></figure><p>那这棵 B+树放的<strong>行数据总量</strong>等于 <code>(x ^ (z-1)) * y</code>。</p><br><h3 id="x-怎么算" tabindex="-1"><a class="header-anchor" href="#x-怎么算"><span>x 怎么算</span></a></h3><p>我们回去看数据页的结构。</p><figure><img src="https://cdn.xiaobaidebug.top/image/页结构.png" alt="页结构" tabindex="0" loading="lazy"><figcaption>页结构</figcaption></figure><p>非叶子节点里主要放索引查询相关的数据，放的是主键和指向页号。</p><p>主键假设是<code>bigint（8Byte）</code>，而页号在源码里叫<code>FIL_PAGE_OFFSET（4Byte）</code>，那么非叶子节点里的一条数据是<code>12Byte</code>左右。</p><p>整个数据页<code>16k</code>， 页头页尾那部分数据全加起来大概<code>128Byte</code>，加上页目录毛估占<code>1k</code>吧。那剩下的<strong>15k</strong>除以<code>12Byte</code>，等于<code>1280</code>，也就是可以指向<strong>x=1280 页</strong>。</p><p>我们常说的二叉树指的是一个结点可以发散出两个新的结点。m 叉树一个节点能指向 m 个新的结点。这个指向新节点的操作就叫<strong>扇出（fanout）</strong>。</p><p>而上面的 B+树，它能指向 1280 个新的节点，恐怖如斯，可以说<strong>扇出非常高</strong>了。</p><br><h3 id="y-的计算" tabindex="-1"><a class="header-anchor" href="#y-的计算"><span>y 的计算</span></a></h3><p>叶子节点和非叶子节点的数据结构是一样的，所以也假设剩下<code>15kb</code>可以发挥。</p><p>叶子节点里放的是真正的行数据。假设一条行数据<code>1kb</code>，所以一页里能放<strong>y=15 行</strong>。</p><br><h3 id="行总数计算" tabindex="-1"><a class="header-anchor" href="#行总数计算"><span>行总数计算</span></a></h3><p>回到 <code>(x ^ (z-1)) * y </code> 这个公式。</p><p>已知<code>x=1280</code>，<code>y=15</code>。</p><p>假设 B+树是<strong>两层</strong>，那<code>z=2</code>。则是<code>(1280 ^ (2-1)) * 15 ≈ 2w </code></p><p>假设 B+树是<strong>三层</strong>，那<code>z=3</code>。则是<code>(1280 ^ (3-1)) * 15 ≈ 2.5kw</code></p><p>**这个 2.5kw，就是我们常说的单表建议最大行数 2kw 的由来。**毕竟再加一层，数据就大得有点离谱了。三层数据页对应最多三次磁盘 IO，也比较合理。</p><br><h2 id="行数超一亿就慢了吗" tabindex="-1"><a class="header-anchor" href="#行数超一亿就慢了吗"><span>行数超一亿就慢了吗？</span></a></h2><p>上面假设单行数据用了 1kb，所以一个数据页能放个 15 行数据。</p><p>如果我单行数据用不了这么多，比如只用了<code>250byte</code>。那么单个数据页能放 60 行数据。</p><p>那同样是三层 B+树，单表支持的行数就是 <code>(1280 ^ (3-1)) * 60 ≈ 1个亿</code>。</p><p>你看我一个亿的数据，其实也就三层 B+树，在这个 B+树里要查到某行数据，最多也是三次磁盘 IO。所以并不慢。</p><p>这就很好的解释了文章开头，为什么我单表 1 个亿，但查询性能没啥大毛病。</p><br><h2 id="b-树承载的记录数量-1" tabindex="-1"><a class="header-anchor" href="#b-树承载的记录数量-1"><span>B 树承载的记录数量</span></a></h2><p>既然都聊到这里了，我们就顺着这个话题多聊一些吧。</p><p>我们都知道，现在 mysql 的索引都是 B+树，而有一种树，跟 B+树很像，叫<strong>B 树，也叫 B-树</strong>。</p><p>它跟 B+树最大的区别在于，<strong>B+树只在末级叶子结点处放数据表行数据，而 B 树则会在叶子和非叶子结点上都放。</strong></p><p>于是，B 树的结构就类似这样</p><figure><img src="https://cdn.xiaobaidebug.top/image/B树结构.png" alt="B树结构" tabindex="0" loading="lazy"><figcaption>B树结构</figcaption></figure><p>B 树将行数据都存在非叶子节点上，假设每个数据页还是 16kb，掐头去尾每页剩 15kb，并且一条数据表行数据还是占 1kb，就算不考虑各种页指针的情况下，也只能放个 15 条数据。<strong>数据页扇出明显变少了。</strong></p><p>计算可承载的总行数的公式也变成了一个<strong>等比数列</strong>。</p><div class="language-text line-numbers-mode" data-ext="text" data-title="text"><pre class="language-text"><code>15 + 15^2 +15^3 + ... + 15^z\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>其中<strong>z 还是层数</strong>的意思。</p><p>为了能放<code>2kw</code>左右的数据，需要<code>z&gt;=6</code>。也就是树需要有 6 层，查一次要访问 6 个页。假设这 6 个页并不连续，为了查询其中一条数据，最坏情况需要进行<strong>6 次磁盘 IO</strong>。</p><p>而 B+树同样情况下放 2kw 数据左右，查一次最多是<strong>3 次磁盘 IO。</strong></p><p>磁盘 IO 越多则越慢，这两者在性能上差距略大。</p><p>为此，<strong>B+树比 B 树更适合成为 mysql 的索引。</strong></p><br><h2 id="总结" tabindex="-1"><a class="header-anchor" href="#总结"><span>总结</span></a></h2><ul><li>B+树叶子和非叶子结点的数据页都是 16k，且数据结构一致，区别在于叶子节点放的是真实的行数据，而非叶子结点放的是主键和下一个页的地址。</li><li>B+树一般有两到三层，由于其高扇出，三层就能支持 2kw 以上的数据，且一次查询最多 1~3 次磁盘 IO，性能也还行。</li><li>存储同样量级的数据，B 树比 B+树层级更高，因此磁盘 IO 也更多，所以 B+树更适合成为 mysql 索引。</li><li>索引结构不会影响单表最大行数，2kw 也只是推荐值，超过了这个值可能会导致 B+树层级更高，影响查询性能。</li><li>单表最大值还受主键大小和磁盘大小限制。</li></ul><h2 id="参考资料" tabindex="-1"><a class="header-anchor" href="#参考资料"><span>参考资料</span></a></h2><p>《MYSQL 内核：INNODB 存储引擎 卷 1》</p><h2 id="最后" tabindex="-1"><a class="header-anchor" href="#最后"><span>最后</span></a></h2><br><p>虽然我在单表里塞了 1 亿条数据，但这个操作的前提是，我很清楚这不会太影响性能。</p><p>这波解释，毫无破绽，无懈可击。</p><p>到这里，连我自己都被自己说服了。想必实习生也是。</p><p>可恶，这该死的毒瘤竟然有些&quot;知识渊博&quot;。</p><figure><img src="https://cdn.xiaobaidebug.top/image/p34066865-20220327102515813.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><br><p>最近原创更文的阅读量稳步下跌，思前想后，夜里辗转反侧。</p><p>我有个不成熟的请求。</p><figure><img src="https://cdn.xiaobaidebug.top/image/u=2281575747,3550568508&amp;fm=253&amp;fmt=auto&amp;app=120&amp;f=JPEG.jpeg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><br><p><strong>离开广东好长时间了，好久没人叫我靓仔了。</strong></p><p>大家可以在<strong>评论区</strong>里，叫我一靓仔吗？</p><p>我这么善良质朴的愿望，能被满足吗？</p><p>如果实在叫不出口的话，能帮我点下右下角的<strong>点赞和在看</strong>吗？</p><br><h5 id="别说了-一起在知识的海洋里呛水吧" tabindex="-1"><a class="header-anchor" href="#别说了-一起在知识的海洋里呛水吧"><span>别说了，一起在知识的海洋里呛水吧</span></a></h5><p><strong>点击</strong>下方名片，关注公众号:【小白 debug】<br><img src="https://cdn.xiaobaidebug.top/1696069689495.png" alt="" loading="lazy"></p><br><p>不满足于在留言区说骚话？</p><p>加我，我们建了个划水吹牛皮群，在群里，你可以跟你下次跳槽可能遇到的同事或面试官聊点有意思的话题。就<strong>超！开！心！</strong></p><img src="https://cdn.xiaobaidebug.top/image-20220522162616202.png" width="50%" align="center"><figure><img src="https://cdn.xiaobaidebug.top/image/006APoFYly1g5q9gn2jipg308w08wqdi.gif" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><h2 id="文章推荐" tabindex="-1"><a class="header-anchor" href="#文章推荐"><span>文章推荐：</span></a></h2>',150),d={href:"https://mp.weixin.qq.com/s/PP80aD-GQp7VtgyfHj392g",target:"_blank",rel:"noopener noreferrer"},g=n("li",null,[n("a",{href:"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/%E6%A0%B8%E5%BF%83%E7%9F%A5%E8%AF%86%E7%82%B9/TCP%E7%B2%98%E5%8C%85%EF%BC%81%E6%95%B0%E6%8D%AE%E5%8C%85%EF%BC%9A%E6%88%91%E5%8F%AA%E6%98%AF%E7%8A%AF%E4%BA%86%E6%AF%8F%E4%B8%AA%E6%95%B0%E6%8D%AE%E5%8C%85%E9%83%BD%E4%BC%9A%E7%8A%AF%E7%9A%84%E9%94%99%EF%BC%8C%E7%A1%AC%E6%A0%B8%E5%9B%BE%E8%A7%A3"},"TCP 粘包 数据包：我只是犯了每个数据包都会犯的错 |硬核图解")],-1),u=n("li",null,[n("a",{href:"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/%E6%A0%B8%E5%BF%83%E7%9F%A5%E8%AF%86%E7%82%B9/%E5%8A%A8%E5%9B%BE%E5%9B%BE%E8%A7%A3%EF%BC%81%E6%97%A2%E7%84%B6IP%E5%B1%82%E4%BC%9A%E5%88%86%E7%89%87%EF%BC%8C%E4%B8%BA%E4%BB%80%E4%B9%88TCP%E5%B1%82%E4%B9%9F%E8%BF%98%E8%A6%81%E5%88%86%E6%AE%B5%EF%BC%9F"},"动图图解！既然 IP 层会分片，为什么 TCP 层也还要分段？")],-1);function E(k,B){const s=t("ExternalLinkIcon");return e(),p("div",null,[l,n("ul",null,[n("li",null,[n("a",d,[o("程序员防猝死指南"),i(s)])]),g,u])])}const A=a(r,[["render",E],["__file","为什么大家说mysql数据库单表最大两千万？.html.vue"]]),h=JSON.parse('{"path":"/%E4%B8%AD%E9%97%B4%E4%BB%B6/mysql/%E6%A0%B8%E5%BF%83%E7%9F%A5%E8%AF%86%E7%82%B9/%E4%B8%BA%E4%BB%80%E4%B9%88%E5%A4%A7%E5%AE%B6%E8%AF%B4mysql%E6%95%B0%E6%8D%AE%E5%BA%93%E5%8D%95%E8%A1%A8%E6%9C%80%E5%A4%A7%E4%B8%A4%E5%8D%83%E4%B8%87%EF%BC%9F.html","title":"为什么大家说 mysql 数据库单表最大两千万？依据是啥？","lang":"zh-CN","frontmatter":{"description":"为什么大家说 mysql 数据库单表最大两千万？依据是啥？ 故事从好多年前说起。 想必大家也听说过数据库单表建议最大 2kw条数据这个说法。如果超过了，性能就会下降得比较厉害。 巧了。 我也听说过。 但我不接受它的建议，硬是单表装了 1 亿条数据。 这时候，我们组里新来的实习生看到了之后，天真无邪的问我：\\"单表不是建议最大两千万吗？为什么这个表都放了 ...","head":[["meta",{"property":"og:url","content":"https://golangguide.top/%E4%B8%AD%E9%97%B4%E4%BB%B6/mysql/%E6%A0%B8%E5%BF%83%E7%9F%A5%E8%AF%86%E7%82%B9/%E4%B8%BA%E4%BB%80%E4%B9%88%E5%A4%A7%E5%AE%B6%E8%AF%B4mysql%E6%95%B0%E6%8D%AE%E5%BA%93%E5%8D%95%E8%A1%A8%E6%9C%80%E5%A4%A7%E4%B8%A4%E5%8D%83%E4%B8%87%EF%BC%9F.html"}],["meta",{"property":"og:site_name","content":"golang全栈指南"}],["meta",{"property":"og:title","content":"为什么大家说 mysql 数据库单表最大两千万？依据是啥？"}],["meta",{"property":"og:description","content":"为什么大家说 mysql 数据库单表最大两千万？依据是啥？ 故事从好多年前说起。 想必大家也听说过数据库单表建议最大 2kw条数据这个说法。如果超过了，性能就会下降得比较厉害。 巧了。 我也听说过。 但我不接受它的建议，硬是单表装了 1 亿条数据。 这时候，我们组里新来的实习生看到了之后，天真无邪的问我：\\"单表不是建议最大两千万吗？为什么这个表都放了 ..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:image","content":"https://cdn.xiaobaidebug.top/image/user%E8%A1%A8%E6%95%B0%E6%8D%AE%E5%BA%93%E5%8E%9F%E5%A7%8B%E7%8A%B6%E6%80%812.drawio.png"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2024-03-04T07:59:24.000Z"}],["meta",{"name":"twitter:card","content":"summary_large_image"}],["meta",{"name":"twitter:image:alt","content":"为什么大家说 mysql 数据库单表最大两千万？依据是啥？"}],["meta",{"property":"article:author","content":"小白debug"}],["meta",{"property":"article:modified_time","content":"2024-03-04T07:59:24.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"为什么大家说 mysql 数据库单表最大两千万？依据是啥？\\",\\"image\\":[\\"https://cdn.xiaobaidebug.top/image/user%E8%A1%A8%E6%95%B0%E6%8D%AE%E5%BA%93%E5%8E%9F%E5%A7%8B%E7%8A%B6%E6%80%812.drawio.png\\",\\"https://cdn.xiaobaidebug.top/image/ibd%E6%96%87%E4%BB%B6%E5%86%85%E9%83%A8%E6%9C%89%E5%A4%A7%E9%87%8F%E7%9A%84%E9%A1%B5.png\\",\\"https://cdn.xiaobaidebug.top/image/%E9%A1%B5%E7%BB%93%E6%9E%84.png\\",\\"https://cdn.xiaobaidebug.top/%E4%B8%A4%E5%B1%82B%E5%8A%A0%E6%A0%91%E7%BB%93%E6%9E%84.png\\",\\"https://cdn.xiaobaidebug.top/B%E5%8A%A0%E6%A0%91%E7%BB%93%E6%9E%847.drawio.png\\",\\"https://cdn.xiaobaidebug.top/B%E5%8A%A0%E6%A0%91%E6%9F%A5%E8%AF%A2%E8%BF%87%E7%A8%8B.png\\",\\"https://cdn.xiaobaidebug.top/image/%E6%80%BB%E8%A1%8C%E6%95%B0%E7%9A%84%E8%AE%A1%E7%AE%97%E6%96%B9%E6%B3%95.png\\",\\"https://cdn.xiaobaidebug.top/image/页结构.png\\",\\"https://cdn.xiaobaidebug.top/image/B%E6%A0%91%E7%BB%93%E6%9E%84.png\\",\\"https://cdn.xiaobaidebug.top/image/p34066865-20220327102515813.jpg\\",\\"https://cdn.xiaobaidebug.top/image/u=2281575747,3550568508&fm=253&fmt=auto&app=120&f=JPEG.jpeg\\",\\"https://cdn.xiaobaidebug.top/1696069689495.png\\",\\"https://cdn.xiaobaidebug.top/image/006APoFYly1g5q9gn2jipg308w08wqdi.gif\\"],\\"dateModified\\":\\"2024-03-04T07:59:24.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"小白debug\\",\\"url\\":\\"https://xiaobaidebug.top/\\"}]}"],["link",{"rel":"canonical","href":"https://golangguide.top/%E4%B8%AD%E9%97%B4%E4%BB%B6/mysql/%E6%A0%B8%E5%BF%83%E7%9F%A5%E8%AF%86%E7%82%B9/%E4%B8%BA%E4%BB%80%E4%B9%88%E5%A4%A7%E5%AE%B6%E8%AF%B4mysql%E6%95%B0%E6%8D%AE%E5%BA%93%E5%8D%95%E8%A1%A8%E6%9C%80%E5%A4%A7%E4%B8%A4%E5%8D%83%E4%B8%87%EF%BC%9F.html"}],["meta",{"property":"og:url","content":"https://golangguide.top/%E4%B8%AD%E9%97%B4%E4%BB%B6/mysql/%E6%A0%B8%E5%BF%83%E7%9F%A5%E8%AF%86%E7%82%B9/%E4%B8%BA%E4%BB%80%E4%B9%88%E5%A4%A7%E5%AE%B6%E8%AF%B4mysql%E6%95%B0%E6%8D%AE%E5%BA%93%E5%8D%95%E8%A1%A8%E6%9C%80%E5%A4%A7%E4%B8%A4%E5%8D%83%E4%B8%87%EF%BC%9F.html"}],["meta",{"property":"og:site_name","content":"golang全栈指南"}],["meta",{"property":"og:title","content":"为什么大家说 mysql 数据库单表最大两千万？依据是啥？"}],["meta",{"property":"og:description","content":"为什么大家说 mysql 数据库单表最大两千万？依据是啥？ 故事从好多年前说起。 想必大家也听说过数据库单表建议最大 2kw条数据这个说法。如果超过了，性能就会下降得比较厉害。 巧了。 我也听说过。 但我不接受它的建议，硬是单表装了 1 亿条数据。 这时候，我们组里新来的实习生看到了之后，天真无邪的问我：\\"单表不是建议最大两千万吗？为什么这个表都放了 ..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2024-03-04T07:59:24.000Z"}],["meta",{"property":"article:modified_time","content":"2024-03-04T07:59:24.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"为什么大家说 mysql 数据库单表最大两千万？依据是啥？\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2024-03-04T07:59:24.000Z\\",\\"author\\":[]}"]]},"headers":[{"level":2,"title":"数据库单表行数最大多大？","slug":"数据库单表行数最大多大","link":"#数据库单表行数最大多大","children":[]},{"level":2,"title":"索引的结构","slug":"索引的结构","link":"#索引的结构","children":[{"level":3,"title":"页的结构","slug":"页的结构","link":"#页的结构","children":[]},{"level":3,"title":"从页到索引","slug":"从页到索引","link":"#从页到索引","children":[]}]},{"level":2,"title":"B+树承载的记录数量","slug":"b-树承载的记录数量","link":"#b-树承载的记录数量","children":[{"level":3,"title":"x 怎么算","slug":"x-怎么算","link":"#x-怎么算","children":[]},{"level":3,"title":"y 的计算","slug":"y-的计算","link":"#y-的计算","children":[]},{"level":3,"title":"行总数计算","slug":"行总数计算","link":"#行总数计算","children":[]}]},{"level":2,"title":"行数超一亿就慢了吗？","slug":"行数超一亿就慢了吗","link":"#行数超一亿就慢了吗","children":[]},{"level":2,"title":"B 树承载的记录数量","slug":"b-树承载的记录数量-1","link":"#b-树承载的记录数量-1","children":[]},{"level":2,"title":"总结","slug":"总结","link":"#总结","children":[]},{"level":2,"title":"参考资料","slug":"参考资料","link":"#参考资料","children":[]},{"level":2,"title":"最后","slug":"最后","link":"#最后","children":[]},{"level":2,"title":"文章推荐：","slug":"文章推荐","link":"#文章推荐","children":[]}],"git":{"createdTime":1708315055000,"updatedTime":1709539164000,"contributors":[{"name":"xiaobai","email":"xiaobaidebug@gmail.com","commits":2}]},"readingTime":{"minutes":12.53,"words":3758},"filePathRelative":"中间件/mysql/核心知识点/为什么大家说mysql数据库单表最大两千万？.md","localizedDate":"2024年2月19日","autoDesc":true}');export{A as comp,h as data};
