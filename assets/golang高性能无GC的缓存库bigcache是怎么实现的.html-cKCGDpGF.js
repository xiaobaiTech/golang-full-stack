import{_ as s}from"./plugin-vue_export-helper-DlAUqK2U.js";import{r as o,o as i,c as p,a as n,b as a,d as t,e as l}from"./app-BHIpk5aV.js";const c={},g=l(`<h1 id="golang-高性能无-gc-的缓存库-bigcache-是怎么实现的" tabindex="-1"><a class="header-anchor" href="#golang-高性能无-gc-的缓存库-bigcache-是怎么实现的"><span>golang 高性能无 GC 的缓存库 bigcache 是怎么实现的？</span></a></h1><p>我们写代码的时候，经常会需要从数据库里读取一些数据，比如配置信息或者诸如每周热点商品之类的数据。</p><figure><img src="https://cdn.xiaobaidebug.top/1708817471422.png" alt="应用读取数据库" tabindex="0" loading="lazy"><figcaption>应用读取数据库</figcaption></figure><p>如果这些数据既不经常变化，又需要频繁读取，那比起每次都去读数据库，更优的解决方案就是将它们放到<strong>应用的本地内存</strong>里，这样可以省下不少<strong>数据库 IO</strong>，性能嘎一下就上来了。</p><figure><img src="https://cdn.xiaobaidebug.top/1708818464147.png" alt="应用优先读缓存" tabindex="0" loading="lazy"><figcaption>应用优先读缓存</figcaption></figure><p>那么现在问题就来了，假设我要在某个服务应用里实现一个<strong>缓存组件</strong>去存各种类型的数据，该怎么实现这个组件呢？</p><h2 id="从一个-map-说起" tabindex="-1"><a class="header-anchor" href="#从一个-map-说起"><span>从一个 map 说起</span></a></h2><p>最简单的的方案就是使用 <strong>map</strong>，也就是<strong>字典</strong>，将需要保存的结构以 <code>key-value</code> 的形式，保存到内存中。比如系统配置，<strong>key</strong> 就叫 system_config，<strong>value</strong> 就是具体的配置内容。 需要读取数据就用 <code>v = m[key]</code>来获取数据，需要写数据就执行<code>m[key] = v</code>.<br><img src="https://cdn.xiaobaidebug.top/1708818954358.png" alt="单线程读写map" loading="lazy"><br> 这样看起来在<strong>单线程</strong>下是满足需求了。<br> 但如果我想在<strong>多个线程（协程）<strong>里并发读写这个缓存呢？<br> 那必然会发生</strong>竞态</strong>问题。<br> 这就需要加个<strong>读写锁</strong>了。读操作前后要<strong>加锁和解锁</strong>，也就是改成下面这样。</p><div class="language-go line-numbers-mode" data-ext="go" data-title="go"><pre class="language-go"><code><span class="token function">RLock</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
v <span class="token operator">=</span> m<span class="token punctuation">[</span>key<span class="token punctuation">]</span>
<span class="token function">RUnLock</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>写操作也需要相应修改：</p><div class="language-go line-numbers-mode" data-ext="go" data-title="go"><pre class="language-go"><code><span class="token function">Lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
m<span class="token punctuation">[</span>key<span class="token punctuation">]</span> <span class="token operator">=</span> v
<span class="token function">UnLock</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><img src="https://cdn.xiaobaidebug.top/1708819462719.png" alt="多线程加锁读写map" loading="lazy"><br> 这在<strong>读写不频繁</strong>的场景下是完全 ok 的，如果没有什么性能要求，服务也没出现什么瓶颈，就算新来的实习生笑它很 low，你也要有自信，这就是个好用的缓存组件。<br> 架构就是这样，能快速满足需求，不出错就行。</p><p>但其实这个方案其实也有很大的问题，如果读写 qps 非常高，那么就会有一堆请求争抢<strong>同一个 map 锁</strong>，这对性能影响太大了。<br> 怎么解决呢？</p><h2 id="将锁粒度变小" tabindex="-1"><a class="header-anchor" href="#将锁粒度变小"><span>将锁粒度变小</span></a></h2><p>上面的方案中，最大的问题是所有读写请求，都抢的同一个锁，所以竞争才大，如果能将一部分请求改为抢 A 锁，另一部分请求改为抢 B 锁，那竞争就变小了。<br> 于是，我们可以将原来的一个 map，进行<strong>分片</strong>，变成多个 map，每个 map 都有自己的锁。<br> 发生读写操作时，第一步先对 key 进行 hash 分片，获取分片对应的锁后，再对分片 map 进行读写。<br> 只有落在<strong>同一个分片</strong>的请求才会发生锁争抢。也就是说 map 拆的越细，锁竞争就越小。<br><img src="https://cdn.xiaobaidebug.top/1708820165851.png" alt="分片锁" loading="lazy"></p><p>像这种将资源分割成多个独立的分片（segments/shard），每个段都有一个对应的锁来控制并发访问的<strong>控制机制</strong>, 其实就是所谓的<strong>分片（段）锁</strong>。<br> 看起来很完美，但其实还有问题。</p><h2 id="gc-带来的问题" tabindex="-1"><a class="header-anchor" href="#gc-带来的问题"><span>gc 带来的问题</span></a></h2><p>像 <code>C/C++</code>这类语言中，用户申请的内存需要由用户自己写代码去释放，一不小心忘了释放那就会发生<strong>内存泄露</strong>，给程序员带来了很大的心智负担。<br> 为了避免这样的问题，一般高级语言里都会自带 GC，也就是<strong>垃圾回收</strong>（Garbage Collection），说白了就是程序员只管申请内存，用完了系统会自动回收释放这些内存。<br> 比如 golang，它会每隔一段时间就去扫描哪些变量内存是可以被回收的。对于指针类型，<strong>golang 会先扫指针，再扫描指针指向的对象里的内容</strong>。<br> map 缓存里放的东西少还好说，缓存里的 key-value 一多，那就喜提多遍疯狂扫描，浪费，全是浪费，golang 你糊涂啊。</p><p><img src="https://cdn.xiaobaidebug.top/1708820767568.png" alt="gc扫描指针对象" loading="lazy"><br> 那有没有办法可以减少这部分 gc 扫描 成本呢？<br> 有。golang 对于 key 和 value 都不含指针的的 map，会选择跳过，不进行 gc 扫描。<br> 所以我们需要<strong>想办法将 map 里的内容改成完全不含指针</strong>。<br> 原来 map 中放的 key-value，key 和 value 都可能是指针结构体。</p><h3 id="对于-key" tabindex="-1"><a class="header-anchor" href="#对于-key"><span>对于 key</span></a></h3><p>原来 key 是用的字符串，<strong>在 golang 中字符串本质上也是指针</strong>，于是我们将它进行 hash 操作，<strong>将字符串转为整形</strong>。信息经过 hash 操作后，有可能会丢掉部分信息，为了避免<strong>hash 冲突</strong>时分不清具体是哪个 key-value，我们会将 key 放到 value 中一起处理，继续看下面。</p><h3 id="对于-value" tabindex="-1"><a class="header-anchor" href="#对于-value"><span>对于 value</span></a></h3><p>我们可以构造一个超大的 byte 数组 <code>buf</code>，将原来的 key value 等信息经过序列化，变成二进制 01 串。将它存放到这个超大 buf 中，并记录它在 超大 buf 中的<strong>位置 index</strong>。<br> 然后将这个<strong>位置 index</strong> 信息放到 map 的 value 位置上，也就是从 key-velue，变成了 key-index。</p><figure><img src="https://cdn.xiaobaidebug.top/1708822123026.png" alt="引入buf减少gc扫描" tabindex="0" loading="lazy"><figcaption>引入buf减少gc扫描</figcaption></figure><p>同时为了防止 buf 数组变得过大，占用过多内存导致应用 oom，还可以采用 <code>ringbuf</code> 的结构，写到尾部就重头开始写，如果 ringbuf 空间不够，还能对它进行<strong>扩容</strong>。<br><img src="https://cdn.xiaobaidebug.top/1708822572381.png" alt="ringbuf扩容" loading="lazy"></p><h3 id="写操作" tabindex="-1"><a class="header-anchor" href="#写操作"><span>写操作</span></a></h3><p>对于写操作，程序先将 key 进行 hash，得到所在分片 map，加锁。</p><ul><li>如果不能从分片 map 里拿到 index，也就是 map 中没旧数据，那就找到 ringbuf 里的空位置后写入 value，再将 index 写入 map。</li><li>如果能从分片 map 里拿到 index，也就是 map 中有旧数据，那就覆盖写 ringbuf。</li></ul><p>然后解锁，结束流程。</p><figure><img src="https://cdn.xiaobaidebug.top/1708823937814.png" alt="写分片map流程" tabindex="0" loading="lazy"><figcaption>写分片map流程</figcaption></figure><h3 id="读操作" tabindex="-1"><a class="header-anchor" href="#读操作"><span>读操作</span></a></h3><p>对于读操作，程序同样先对 key 进行 hash，得到分片 map。<br> 加锁，从分片 map 里拿到 value 对应的 index，拿着这个 index 到 ringbuf 数组中去获取到 value 的值，然后解锁，结束流程。<br><img src="https://cdn.xiaobaidebug.top/1708824029962.png" alt="读分片map流程" loading="lazy"></p><p>到这里，我们可以发现 map 的 key 和 value 都被改成了整形数字，也就省下了大量的 gc 扫描，大大提升了组件性能。<br> 其实这就是有名的高性能无 GC 的缓存库 <code>github.com/allegro/bigcache</code> 的实现原理。</p><h2 id="bigcache-的使用" tabindex="-1"><a class="header-anchor" href="#bigcache-的使用"><span>bigcache 的使用</span></a></h2><p>它的使用方法大概像下面这样。</p><div class="language-go line-numbers-mode" data-ext="go" data-title="go"><pre class="language-go"><code><span class="token keyword">package</span> main

<span class="token keyword">import</span> <span class="token punctuation">(</span>
	<span class="token string">&quot;fmt&quot;</span>
	<span class="token string">&quot;github.com/allegro/bigcache/v3&quot;</span>
<span class="token punctuation">)</span>

<span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
	<span class="token comment">// 设置 bigcache 配置参数</span>
	cacheConfig <span class="token operator">:=</span> bigcache<span class="token punctuation">.</span>Config<span class="token punctuation">{</span>
		Shards<span class="token punctuation">:</span> <span class="token number">1024</span><span class="token punctuation">,</span> <span class="token comment">// 分片数量，提高并发性</span>
	<span class="token punctuation">}</span>

	<span class="token comment">// 初始化 bigcache</span>
	cache<span class="token punctuation">,</span> <span class="token boolean">_</span> <span class="token operator">:=</span> bigcache<span class="token punctuation">.</span><span class="token function">NewBigCache</span><span class="token punctuation">(</span>cacheConfig<span class="token punctuation">)</span>

	<span class="token comment">// 写缓存数据</span>
	key <span class="token operator">:=</span> <span class="token string">&quot;欢迎关注&quot;</span>
	value <span class="token operator">:=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token function">byte</span><span class="token punctuation">(</span><span class="token string">&quot;小白debug&quot;</span><span class="token punctuation">)</span>
	cache<span class="token punctuation">.</span><span class="token function">Set</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> value<span class="token punctuation">)</span>

	<span class="token comment">// 读缓存数据</span>
	entry<span class="token punctuation">,</span> <span class="token boolean">_</span> <span class="token operator">:=</span> cache<span class="token punctuation">.</span><span class="token function">Get</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span>

	fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">&quot;Entry: %s\\n&quot;</span><span class="token punctuation">,</span> entry<span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>说白了就是 Get 方法读缓存数据，Set 方法写缓存数据，比较简单。<br> 现在，大概原理和使用方法我们都懂了，我们再来看下 bigcache 中，两个我认为挺<strong>巧妙</strong>的设计点。</p><h2 id="ringbuf-中的数据格式" tabindex="-1"><a class="header-anchor" href="#ringbuf-中的数据格式"><span>ringbuf 中的数据格式</span></a></h2><p>在前面的介绍中，我猜你心里可能有疑问，程序从 ringbuf 读写 value 的时候，ringbuf 里面放的都是 01 二进制数组，程序怎么知道该<strong>读多少 bit 才算一个完整 value</strong>？<br> bigcache 的解法非常值得学习，它重新定义了一个新的数据格式。</p><figure><img src="https://cdn.xiaobaidebug.top/1708825671005.png" alt="ringbuf内数据格式" tabindex="0" loading="lazy"><figcaption>ringbuf内数据格式</figcaption></figure><ul><li><p>length 表示 header 到 data 的数据长度</p></li><li><p>header 是固定长度</p></li><li><p>data 则是 key 和 value 的完整数据。</p></li></ul><p>当读取 ringbuf 时，我们会先读到 length，有了它，我们就能在 ringbuf 里拿到 header 和 data，header 里又含有 key 的长度，这样就能在 data 里将 key 和 value 完整区分开来。</p><p>很多网络传输框架中都会用到类似的方案，后面有机会跟大家细聊。</p><h2 id="ringbuffer-的第-0-位" tabindex="-1"><a class="header-anchor" href="#ringbuffer-的第-0-位"><span>ringbuffer 的第 0 位</span></a></h2><p>另外，还有个巧妙的设计是，在 bigcache 中， ringbuffer 的<strong>第 0 位</strong>并不用来存放任何数据，这样如果发现 分片 map 中得到数据的 index 为 0，就可以直接认为没有对应的缓存数据，那就不需要跑到 ringbuffer 里去捞一遍数据了，觉得学到了，记得在右下角给我点个赞。<br><img src="https://cdn.xiaobaidebug.top/1708824528403.png" alt="ringbuf不使用第0位" loading="lazy"></p><h2 id="bigcache-的缺点" tabindex="-1"><a class="header-anchor" href="#bigcache-的缺点"><span>bigcache 的缺点</span></a></h2><p>bigcache 性能非常好，但也不是完全没有问题。比较明显的是，它读写数据时，用的都是<strong>byte 数组</strong>，但我们平时写代码用的都是结构体，为了让<strong>结构体和 byte 数组互转</strong>，我们就需要用到<strong>序列化和反序列化</strong>，这些都是成本。</p><p>另外它的缓存淘汰策略也比较粗暴，用的是 <strong>FIFO</strong>，不支持 LRU 或 LFU 的淘汰策略。</p><h2 id="总结" tabindex="-1"><a class="header-anchor" href="#总结"><span>总结</span></a></h2><ul><li>对于不频繁读写的场景，加锁读写 map 就够了。</li><li>对于需要频繁读写的场景，可以使用分片锁，减少锁竞争。</li><li>对于 golang，map 中含指针的话会引发 gc 扫描，为了降低这部分成本，引入了 ringbuf，map 的 value 则改为缓存对象在 ringbuf 中的 index，以此提升组件性能。以后面试官问你看没看过哪些优秀组件的源码的时候，你知道该怎么回答了吧？</li></ul><h2 id="最后" tabindex="-1"><a class="header-anchor" href="#最后"><span>最后</span></a></h2><p>不管是空间换时间还是时间换空间，适合、够用，就是最好的，架构总是在做折中。<br> 这就像我们做的 go/java 后端训练营，你不能要求它效果好，又要求它价格低。</p>`,52),r={href:"https://golangguide.top/%E8%AE%AD%E7%BB%83%E8%90%A5/%E4%BB%8B%E7%BB%8D.html",target:"_blank",rel:"noopener noreferrer"},d=n("h1",{id:"相关文章",tabindex:"-1"},[n("a",{class:"header-anchor",href:"#相关文章"},[n("span",null,"相关文章")])],-1),u={href:"https://golangguide.top/golang/%E9%9D%A2%E8%AF%95%E9%A2%98/2.Go%E8%BF%9B%E9%98%B6.html",target:"_blank",rel:"noopener noreferrer"},b={href:"https://golangguide.top/golang/%E9%9D%A2%E8%AF%95%E9%A2%98/1.Go%E5%85%A5%E9%97%A8.html",target:"_blank",rel:"noopener noreferrer"},h={href:"https://golangguide.top/golang/%E5%B8%B8%E7%94%A8%E5%8C%85%E5%A4%A7%E5%85%A8.html",target:"_blank",rel:"noopener noreferrer"},m={href:"https://golangguide.top/golang/%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF.html",target:"_blank",rel:"noopener noreferrer"};function k(v,E){const e=o("ExternalLinkIcon");return i(),p("div",null,[g,n("p",null,[a("不管你是学生，还是工作了几年的程序员，如果你最近想换份工作，又对自己的实力不自信，可以考虑下我们"),n("a",r,[a("训练营"),t(e)]),a("。")]),d,n("ul",null,[n("li",null,[n("p",null,[n("a",u,[a("golang进阶面试题八股文合集"),t(e)])])]),n("li",null,[n("p",null,[n("a",b,[a("golang基础面试题八股文合集"),t(e)])])]),n("li",null,[n("p",null,[n("a",h,[a("golang常用标准库第三方库大全"),t(e)])])]),n("li",null,[n("p",null,[n("a",m,[a("golang学习路线"),t(e)])])])])])}const A=s(c,[["render",k],["__file","golang高性能无GC的缓存库bigcache是怎么实现的.html.vue"]]),x=JSON.parse('{"path":"/golang/%E6%A0%B8%E5%BF%83%E7%9F%A5%E8%AF%86%E7%82%B9/golang%E9%AB%98%E6%80%A7%E8%83%BD%E6%97%A0GC%E7%9A%84%E7%BC%93%E5%AD%98%E5%BA%93bigcache%E6%98%AF%E6%80%8E%E4%B9%88%E5%AE%9E%E7%8E%B0%E7%9A%84.html","title":"golang 高性能无 GC 的缓存库 bigcache 是怎么实现的？","lang":"zh-CN","frontmatter":{"description":"golang 高性能无 GC 的缓存库 bigcache 是怎么实现的？ 我们写代码的时候，经常会需要从数据库里读取一些数据，比如配置信息或者诸如每周热点商品之类的数据。 应用读取数据库应用读取数据库 如果这些数据既不经常变化，又需要频繁读取，那比起每次都去读数据库，更优的解决方案就是将它们放到应用的本地内存里，这样可以省下不少数据库 IO，性能嘎一下...","head":[["meta",{"property":"og:url","content":"https://golangguide.top/golang/%E6%A0%B8%E5%BF%83%E7%9F%A5%E8%AF%86%E7%82%B9/golang%E9%AB%98%E6%80%A7%E8%83%BD%E6%97%A0GC%E7%9A%84%E7%BC%93%E5%AD%98%E5%BA%93bigcache%E6%98%AF%E6%80%8E%E4%B9%88%E5%AE%9E%E7%8E%B0%E7%9A%84.html"}],["meta",{"property":"og:site_name","content":"golang全栈指南"}],["meta",{"property":"og:title","content":"golang 高性能无 GC 的缓存库 bigcache 是怎么实现的？"}],["meta",{"property":"og:description","content":"golang 高性能无 GC 的缓存库 bigcache 是怎么实现的？ 我们写代码的时候，经常会需要从数据库里读取一些数据，比如配置信息或者诸如每周热点商品之类的数据。 应用读取数据库应用读取数据库 如果这些数据既不经常变化，又需要频繁读取，那比起每次都去读数据库，更优的解决方案就是将它们放到应用的本地内存里，这样可以省下不少数据库 IO，性能嘎一下..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:image","content":"https://cdn.xiaobaidebug.top/1708817471422.png"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2024-02-28T01:37:12.000Z"}],["meta",{"name":"twitter:card","content":"summary_large_image"}],["meta",{"name":"twitter:image:alt","content":"golang 高性能无 GC 的缓存库 bigcache 是怎么实现的？"}],["meta",{"property":"article:author","content":"小白debug"}],["meta",{"property":"article:modified_time","content":"2024-02-28T01:37:12.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"golang 高性能无 GC 的缓存库 bigcache 是怎么实现的？\\",\\"image\\":[\\"https://cdn.xiaobaidebug.top/1708817471422.png\\",\\"https://cdn.xiaobaidebug.top/1708818464147.png\\",\\"https://cdn.xiaobaidebug.top/1708818954358.png\\",\\"https://cdn.xiaobaidebug.top/1708819462719.png\\",\\"https://cdn.xiaobaidebug.top/1708820165851.png\\",\\"https://cdn.xiaobaidebug.top/1708820767568.png\\",\\"https://cdn.xiaobaidebug.top/1708822123026.png\\",\\"https://cdn.xiaobaidebug.top/1708822572381.png\\",\\"https://cdn.xiaobaidebug.top/1708823937814.png\\",\\"https://cdn.xiaobaidebug.top/1708824029962.png\\",\\"https://cdn.xiaobaidebug.top/1708825671005.png\\",\\"https://cdn.xiaobaidebug.top/1708824528403.png\\"],\\"dateModified\\":\\"2024-02-28T01:37:12.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"小白debug\\",\\"url\\":\\"https://xiaobaidebug.top/\\"}]}"],["link",{"rel":"canonical","href":"https://golangguide.top/golang/%E6%A0%B8%E5%BF%83%E7%9F%A5%E8%AF%86%E7%82%B9/golang%E9%AB%98%E6%80%A7%E8%83%BD%E6%97%A0GC%E7%9A%84%E7%BC%93%E5%AD%98%E5%BA%93bigcache%E6%98%AF%E6%80%8E%E4%B9%88%E5%AE%9E%E7%8E%B0%E7%9A%84.html"}],["meta",{"property":"og:url","content":"https://golangguide.top/golang/%E6%A0%B8%E5%BF%83%E7%9F%A5%E8%AF%86%E7%82%B9/golang%E9%AB%98%E6%80%A7%E8%83%BD%E6%97%A0GC%E7%9A%84%E7%BC%93%E5%AD%98%E5%BA%93bigcache%E6%98%AF%E6%80%8E%E4%B9%88%E5%AE%9E%E7%8E%B0%E7%9A%84.html"}],["meta",{"property":"og:site_name","content":"golang全栈指南"}],["meta",{"property":"og:title","content":"golang 高性能无 GC 的缓存库 bigcache 是怎么实现的？"}],["meta",{"property":"og:description","content":"golang 高性能无 GC 的缓存库 bigcache 是怎么实现的？ 我们写代码的时候，经常会需要从数据库里读取一些数据，比如配置信息或者诸如每周热点商品之类的数据。 应用读取数据库应用读取数据库 如果这些数据既不经常变化，又需要频繁读取，那比起每次都去读数据库，更优的解决方案就是将它们放到应用的本地内存里，这样可以省下不少数据库 IO，性能嘎一下..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2024-02-28T01:37:12.000Z"}],["meta",{"property":"article:modified_time","content":"2024-02-28T01:37:12.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"golang 高性能无 GC 的缓存库 bigcache 是怎么实现的？\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2024-02-28T01:37:12.000Z\\",\\"author\\":[]}"]]},"headers":[{"level":2,"title":"从一个 map 说起","slug":"从一个-map-说起","link":"#从一个-map-说起","children":[]},{"level":2,"title":"将锁粒度变小","slug":"将锁粒度变小","link":"#将锁粒度变小","children":[]},{"level":2,"title":"gc 带来的问题","slug":"gc-带来的问题","link":"#gc-带来的问题","children":[{"level":3,"title":"对于 key","slug":"对于-key","link":"#对于-key","children":[]},{"level":3,"title":"对于 value","slug":"对于-value","link":"#对于-value","children":[]},{"level":3,"title":"写操作","slug":"写操作","link":"#写操作","children":[]},{"level":3,"title":"读操作","slug":"读操作","link":"#读操作","children":[]}]},{"level":2,"title":"bigcache 的使用","slug":"bigcache-的使用","link":"#bigcache-的使用","children":[]},{"level":2,"title":"ringbuf 中的数据格式","slug":"ringbuf-中的数据格式","link":"#ringbuf-中的数据格式","children":[]},{"level":2,"title":"ringbuffer 的第 0 位","slug":"ringbuffer-的第-0-位","link":"#ringbuffer-的第-0-位","children":[]},{"level":2,"title":"bigcache 的缺点","slug":"bigcache-的缺点","link":"#bigcache-的缺点","children":[]},{"level":2,"title":"总结","slug":"总结","link":"#总结","children":[]},{"level":2,"title":"最后","slug":"最后","link":"#最后","children":[]}],"git":{"createdTime":1708912664000,"updatedTime":1709084232000,"contributors":[{"name":"xiaobai","email":"xiaobaidebug@gmail.com","commits":2}]},"readingTime":{"minutes":8.52,"words":2555},"filePathRelative":"golang/核心知识点/golang高性能无GC的缓存库bigcache是怎么实现的.md","localizedDate":"2024年2月26日","autoDesc":true}');export{A as comp,x as data};
