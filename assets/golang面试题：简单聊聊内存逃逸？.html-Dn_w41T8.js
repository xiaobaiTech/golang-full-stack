import{_ as o}from"./plugin-vue_export-helper-DlAUqK2U.js";import{r as e,o as p,c,a as n,b as s,d as t,e as l}from"./app-XdEnGITl.js";const i={},r=l(`<figure><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pbWdrci5jbi1iai51ZmlsZW9zLmNvbS9jNzJkY2JmNi05YTc2LTRlYmMtODBkMC1lZjNmNzZjNDk5NzcucG5n?x-oss-process=image/format,png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><h1 id="问题" tabindex="-1"><a class="header-anchor" href="#问题"><span>问题</span></a></h1><p>知道 golang 的<strong>内存逃逸</strong>吗？什么情况下会发生内存逃逸？</p><h1 id="怎么答" tabindex="-1"><a class="header-anchor" href="#怎么答"><span>怎么答</span></a></h1><p><code>golang程序变量</code>会携带有一组校验数据，用来证明它的整个生命周期是否在运行时完全可知。如果变量通过了这些校验，它就可以在<code>栈上</code>分配。否则就说它 <code>逃逸</code> 了，必须在<code>堆上分配</code>。</p><p>能引起变量逃逸到堆上的<strong>典型情况</strong>：</p><ul><li><strong>在方法内把局部变量指针返回</strong> 局部变量原本应该在栈中分配，在栈中回收。但是由于返回时被外部引用，因此其生命周期大于栈，则溢出。</li><li><strong>发送指针或带有指针的值到 channel 中。</strong> 在编译时，是没有办法知道哪个 goroutine 会在 channel 上接收数据。所以编译器没法知道变量什么时候才会被释放。</li><li><strong>在一个切片上存储指针或带指针的值。</strong> 一个典型的例子就是 []*string 。这会导致切片的内容逃逸。尽管其后面的数组可能是在栈上分配的，但其引用的值一定是在堆上。</li><li><strong>slice 的背后数组被重新分配了，因为 append 时可能会超出其容量( cap )。</strong> slice 初始化的地方在编译时是可以知道的，它最开始会在栈上分配。如果切片背后的存储要基于运行时的数据进行扩充，就会在堆上分配。</li><li><strong>在 interface 类型上调用方法。</strong> 在 interface 类型上调用方法都是动态调度的 —— 方法的真正实现只能在运行时知道。想像一个 io.Reader 类型的变量 r , 调用 r.Read(b) 会使得 r 的值和切片 b 的背后存储都逃逸掉，所以会在堆上分配。</li></ul><h1 id="举例" tabindex="-1"><a class="header-anchor" href="#举例"><span>举例</span></a></h1><ul><li>通过一个例子加深理解，接下来尝试下怎么通过 <code>go build -gcflags=-m</code> 查看逃逸的情况。</li></ul><div class="language-go line-numbers-mode" data-ext="go" data-title="go"><pre class="language-go"><code><span class="token keyword">package</span> main
<span class="token keyword">import</span> <span class="token string">&quot;fmt&quot;</span>
<span class="token keyword">type</span> A <span class="token keyword">struct</span> <span class="token punctuation">{</span>
	s <span class="token builtin">string</span>
<span class="token punctuation">}</span>
<span class="token comment">// 这是上面提到的 &quot;在方法内把局部变量指针返回&quot; 的情况</span>
<span class="token keyword">func</span> <span class="token function">foo</span><span class="token punctuation">(</span>s <span class="token builtin">string</span><span class="token punctuation">)</span> <span class="token operator">*</span>A <span class="token punctuation">{</span>
	a <span class="token operator">:=</span> <span class="token function">new</span><span class="token punctuation">(</span>A<span class="token punctuation">)</span>
	a<span class="token punctuation">.</span>s <span class="token operator">=</span> s
	<span class="token keyword">return</span> a <span class="token comment">//返回局部变量a,在C语言中妥妥野指针，但在go则ok，但a会逃逸到堆</span>
<span class="token punctuation">}</span>
<span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
	a <span class="token operator">:=</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token string">&quot;hello&quot;</span><span class="token punctuation">)</span>
	b <span class="token operator">:=</span> a<span class="token punctuation">.</span>s <span class="token operator">+</span> <span class="token string">&quot; world&quot;</span>
	c <span class="token operator">:=</span> b <span class="token operator">+</span> <span class="token string">&quot;!&quot;</span>
	fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>执行<code>go build -gcflags=-m main.go</code></p><div class="language-go line-numbers-mode" data-ext="go" data-title="go"><pre class="language-go"><code><span class="token keyword">go</span> build <span class="token operator">-</span>gcflags<span class="token operator">=</span><span class="token operator">-</span>m main<span class="token punctuation">.</span><span class="token keyword">go</span>
# command<span class="token operator">-</span>line<span class="token operator">-</span>arguments
<span class="token punctuation">.</span><span class="token operator">/</span>main<span class="token punctuation">.</span><span class="token keyword">go</span><span class="token punctuation">:</span><span class="token number">7</span><span class="token punctuation">:</span><span class="token number">6</span><span class="token punctuation">:</span> can inline foo
<span class="token punctuation">.</span><span class="token operator">/</span>main<span class="token punctuation">.</span><span class="token keyword">go</span><span class="token punctuation">:</span><span class="token number">13</span><span class="token punctuation">:</span><span class="token number">10</span><span class="token punctuation">:</span> inlining call to foo
<span class="token punctuation">.</span><span class="token operator">/</span>main<span class="token punctuation">.</span><span class="token keyword">go</span><span class="token punctuation">:</span><span class="token number">16</span><span class="token punctuation">:</span><span class="token number">13</span><span class="token punctuation">:</span> inlining call to fmt<span class="token punctuation">.</span>Println
<span class="token operator">/</span><span class="token keyword">var</span><span class="token operator">/</span>folders<span class="token operator">/</span><span class="token number">45</span><span class="token operator">/</span>qx9lfw2s2zzgvhzg3mtzkwzc0000gn<span class="token operator">/</span>T<span class="token operator">/</span><span class="token keyword">go</span><span class="token operator">-</span>build409982591<span class="token operator">/</span>b001<span class="token operator">/</span>_gomod_<span class="token punctuation">.</span><span class="token keyword">go</span><span class="token punctuation">:</span><span class="token number">6</span><span class="token punctuation">:</span><span class="token number">6</span><span class="token punctuation">:</span> can inline init<span class="token punctuation">.</span><span class="token number">0</span>
<span class="token punctuation">.</span><span class="token operator">/</span>main<span class="token punctuation">.</span><span class="token keyword">go</span><span class="token punctuation">:</span><span class="token number">7</span><span class="token punctuation">:</span><span class="token number">10</span><span class="token punctuation">:</span> leaking param<span class="token punctuation">:</span> s
<span class="token punctuation">.</span><span class="token operator">/</span>main<span class="token punctuation">.</span><span class="token keyword">go</span><span class="token punctuation">:</span><span class="token number">8</span><span class="token punctuation">:</span><span class="token number">10</span><span class="token punctuation">:</span> <span class="token function">new</span><span class="token punctuation">(</span>A<span class="token punctuation">)</span> escapes to heap
<span class="token punctuation">.</span><span class="token operator">/</span>main<span class="token punctuation">.</span><span class="token keyword">go</span><span class="token punctuation">:</span><span class="token number">16</span><span class="token punctuation">:</span><span class="token number">13</span><span class="token punctuation">:</span> io<span class="token punctuation">.</span><span class="token function">Writer</span><span class="token punctuation">(</span>os<span class="token punctuation">.</span>Stdout<span class="token punctuation">)</span> escapes to heap
<span class="token punctuation">.</span><span class="token operator">/</span>main<span class="token punctuation">.</span><span class="token keyword">go</span><span class="token punctuation">:</span><span class="token number">16</span><span class="token punctuation">:</span><span class="token number">13</span><span class="token punctuation">:</span> c escapes to heap
<span class="token punctuation">.</span><span class="token operator">/</span>main<span class="token punctuation">.</span><span class="token keyword">go</span><span class="token punctuation">:</span><span class="token number">15</span><span class="token punctuation">:</span><span class="token number">9</span><span class="token punctuation">:</span> b <span class="token operator">+</span> <span class="token string">&quot;!&quot;</span> escapes to heap
<span class="token punctuation">.</span><span class="token operator">/</span>main<span class="token punctuation">.</span><span class="token keyword">go</span><span class="token punctuation">:</span><span class="token number">13</span><span class="token punctuation">:</span><span class="token number">10</span><span class="token punctuation">:</span> main <span class="token function">new</span><span class="token punctuation">(</span>A<span class="token punctuation">)</span> does not escape
<span class="token punctuation">.</span><span class="token operator">/</span>main<span class="token punctuation">.</span><span class="token keyword">go</span><span class="token punctuation">:</span><span class="token number">14</span><span class="token punctuation">:</span><span class="token number">11</span><span class="token punctuation">:</span> main a<span class="token punctuation">.</span>s <span class="token operator">+</span> <span class="token string">&quot; world&quot;</span> does not escape
<span class="token punctuation">.</span><span class="token operator">/</span>main<span class="token punctuation">.</span><span class="token keyword">go</span><span class="token punctuation">:</span><span class="token number">16</span><span class="token punctuation">:</span><span class="token number">13</span><span class="token punctuation">:</span> main <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token keyword">interface</span> <span class="token punctuation">{</span><span class="token punctuation">}</span> literal does not escape
<span class="token operator">&lt;</span>autogenerated<span class="token operator">&gt;</span><span class="token punctuation">:</span><span class="token number">1</span><span class="token punctuation">:</span> os<span class="token punctuation">.</span><span class="token punctuation">(</span><span class="token operator">*</span>File<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token builtin">close</span> <span class="token punctuation">.</span>this does not escape
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li><p><code>./main.go:8:10: new(A) escapes to heap</code> 说明 <code>new(A)</code> 逃逸了,符合上述提到的常见情况中的第一种。</p></li><li><p><code>./main.go:14:11: main a.s + &quot; world&quot; does not escape</code> 说明 <code>b</code> 变量没有逃逸，因为它只在方法内存在，会在方法结束时被回收。</p></li><li><p><code>./main.go:15:9: b + &quot;!&quot; escapes to heap</code> 说明 <code>c</code> 变量逃逸，通过<code>fmt.Println(a ...interface{})</code>打印的变量，都会发生逃逸，感兴趣的朋友可以去查查为什么。</p></li><li><p>以上操作其实就叫<strong>逃逸分析</strong>。<strong>下篇文章，跟大家聊聊怎么用一个比较 trick 的方法使变量不逃逸。方便大家在面试官面前秀一波</strong>。</p></li></ul><h2 id="相关文章" tabindex="-1"><a class="header-anchor" href="#相关文章"><span>相关文章</span></a></h2>`,14),u={href:"https://golangguide.top/golang/%E9%9D%A2%E8%AF%95%E9%A2%98/2.Go%E8%BF%9B%E9%98%B6.html",target:"_blank",rel:"noopener noreferrer"},k={href:"https://golangguide.top/golang/%E9%9D%A2%E8%AF%95%E9%A2%98/1.Go%E5%85%A5%E9%97%A8.html",target:"_blank",rel:"noopener noreferrer"},d={href:"https://golangguide.top/golang/%E5%B8%B8%E7%94%A8%E5%8C%85%E5%A4%A7%E5%85%A8.html",target:"_blank",rel:"noopener noreferrer"},g={href:"https://golangguide.top/golang/%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF.html",target:"_blank",rel:"noopener noreferrer"};function m(b,E){const a=e("ExternalLinkIcon");return p(),c("div",null,[r,n("ul",null,[n("li",null,[n("p",null,[n("a",u,[s("golang进阶面试题八股文合集"),t(a)])])]),n("li",null,[n("p",null,[n("a",k,[s("golang基础面试题八股文合集"),t(a)])])]),n("li",null,[n("p",null,[n("a",d,[s("golang常用标准库第三方库大全"),t(a)])])]),n("li",null,[n("p",null,[n("a",g,[s("golang学习路线"),t(a)])])])])])}const A=o(i,[["render",m],["__file","golang面试题：简单聊聊内存逃逸？.html.vue"]]),f=JSON.parse('{"path":"/golang/%E6%A0%B8%E5%BF%83%E7%9F%A5%E8%AF%86%E7%82%B9/golang%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%9A%E7%AE%80%E5%8D%95%E8%81%8A%E8%81%8A%E5%86%85%E5%AD%98%E9%80%83%E9%80%B8%EF%BC%9F.html","title":"golang面试题：简单聊聊内存逃逸？","lang":"zh-CN","frontmatter":{"title":"golang面试题：简单聊聊内存逃逸？","date":"2020-05-12T22:57:55.000Z","tags":null,"categories":"golang面试题","description":" 问题 知道 golang 的内存逃逸吗？什么情况下会发生内存逃逸？ 怎么答 golang程序变量会携带有一组校验数据，用来证明它的整个生命周期是否在运行时完全可知。如果变量通过了这些校验，它就可以在栈上分配。否则就说它 逃逸 了，必须在堆上分配。 能引起变量逃逸到堆上的典型情况： 在方法内把局部变量指针返回 局部变量原本应该在栈中分配，在栈中回收。但...","head":[["meta",{"property":"og:url","content":"https://golangguide.top/golang/%E6%A0%B8%E5%BF%83%E7%9F%A5%E8%AF%86%E7%82%B9/golang%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%9A%E7%AE%80%E5%8D%95%E8%81%8A%E8%81%8A%E5%86%85%E5%AD%98%E9%80%83%E9%80%B8%EF%BC%9F.html"}],["meta",{"property":"og:site_name","content":"golang全栈指南"}],["meta",{"property":"og:title","content":"golang面试题：简单聊聊内存逃逸？"}],["meta",{"property":"og:description","content":" 问题 知道 golang 的内存逃逸吗？什么情况下会发生内存逃逸？ 怎么答 golang程序变量会携带有一组校验数据，用来证明它的整个生命周期是否在运行时完全可知。如果变量通过了这些校验，它就可以在栈上分配。否则就说它 逃逸 了，必须在堆上分配。 能引起变量逃逸到堆上的典型情况： 在方法内把局部变量指针返回 局部变量原本应该在栈中分配，在栈中回收。但..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:image","content":"https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pbWdrci5jbi1iai51ZmlsZW9zLmNvbS9jNzJkY2JmNi05YTc2LTRlYmMtODBkMC1lZjNmNzZjNDk5NzcucG5n?x-oss-process=image/format,png"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2024-02-28T01:37:12.000Z"}],["meta",{"name":"twitter:card","content":"summary_large_image"}],["meta",{"name":"twitter:image:alt","content":"golang面试题：简单聊聊内存逃逸？"}],["meta",{"property":"article:author","content":"小白debug"}],["meta",{"property":"article:published_time","content":"2020-05-12T22:57:55.000Z"}],["meta",{"property":"article:modified_time","content":"2024-02-28T01:37:12.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"golang面试题：简单聊聊内存逃逸？\\",\\"image\\":[\\"https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pbWdrci5jbi1iai51ZmlsZW9zLmNvbS9jNzJkY2JmNi05YTc2LTRlYmMtODBkMC1lZjNmNzZjNDk5NzcucG5n?x-oss-process=image/format,png\\"],\\"datePublished\\":\\"2020-05-12T22:57:55.000Z\\",\\"dateModified\\":\\"2024-02-28T01:37:12.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"小白debug\\",\\"url\\":\\"https://xiaobaidebug.top/\\"}]}"],["link",{"rel":"canonical","href":"https://golangguide.top/golang/%E6%A0%B8%E5%BF%83%E7%9F%A5%E8%AF%86%E7%82%B9/golang%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%9A%E7%AE%80%E5%8D%95%E8%81%8A%E8%81%8A%E5%86%85%E5%AD%98%E9%80%83%E9%80%B8%EF%BC%9F.html"}],["meta",{"property":"og:url","content":"https://golangguide.top/golang/%E6%A0%B8%E5%BF%83%E7%9F%A5%E8%AF%86%E7%82%B9/golang%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%9A%E7%AE%80%E5%8D%95%E8%81%8A%E8%81%8A%E5%86%85%E5%AD%98%E9%80%83%E9%80%B8%EF%BC%9F.html"}],["meta",{"property":"og:site_name","content":"golang全栈指南"}],["meta",{"property":"og:title","content":"golang面试题：简单聊聊内存逃逸？"}],["meta",{"property":"og:description","content":" 问题 知道 golang 的内存逃逸吗？什么情况下会发生内存逃逸？ 怎么答 golang程序变量会携带有一组校验数据，用来证明它的整个生命周期是否在运行时完全可知。如果变量通过了这些校验，它就可以在栈上分配。否则就说它 逃逸 了，必须在堆上分配。 能引起变量逃逸到堆上的典型情况： 在方法内把局部变量指针返回 局部变量原本应该在栈中分配，在栈中回收。但..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2024-02-28T01:37:12.000Z"}],["meta",{"property":"article:published_time","content":"2020-05-12T22:57:55.000Z"}],["meta",{"property":"article:modified_time","content":"2024-02-28T01:37:12.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"golang面试题：简单聊聊内存逃逸？\\",\\"image\\":[\\"\\"],\\"datePublished\\":\\"2020-05-12T22:57:55.000Z\\",\\"dateModified\\":\\"2024-02-28T01:37:12.000Z\\",\\"author\\":[]}"]]},"headers":[{"level":2,"title":"相关文章","slug":"相关文章","link":"#相关文章","children":[]}],"git":{"createdTime":1708315540000,"updatedTime":1709084232000,"contributors":[{"name":"xiaobai","email":"xiaobaidebug@gmail.com","commits":2}]},"readingTime":{"minutes":3.32,"words":996},"filePathRelative":"golang/核心知识点/golang面试题：简单聊聊内存逃逸？.md","localizedDate":"2020年5月12日","autoDesc":true}');export{A as comp,f as data};
