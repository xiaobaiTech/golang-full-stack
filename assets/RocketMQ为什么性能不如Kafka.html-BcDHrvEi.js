import{_ as e,c as t,a as o,o as n}from"./app-B3fHpbRm.js";const s={};function p(c,a){return n(),t("div",null,a[0]||(a[0]=[o(`<h1 id="rocketmq-为什么性能不如-kafka" tabindex="-1"><a class="header-anchor" href="#rocketmq-为什么性能不如-kafka"><span>RocketMQ 为什么性能不如 Kafka？</span></a></h1><p>在上篇文章<a href="/%E4%B8%AD%E9%97%B4%E4%BB%B6/rocketmq/%E6%A0%B8%E5%BF%83%E7%9F%A5%E8%AF%86%E7%82%B9/RocketMQ%E6%98%AF%E4%BB%80%E4%B9%88">《rocketmq 是什么》</a>中，我们了解到 RocketMQ 的架构其实参考了 kafka 的设计思想，同时又在 kafka 的基础上做了一些调整。<br> 看起来，RocketMQ 好像各方面都比 kafka 更能打。</p><figure><img src="https://cdn.xiaobaidebug.top/1722555605803.jpeg" alt="Kafka与RocketMQ对比" tabindex="0" loading="lazy"><figcaption>Kafka与RocketMQ对比</figcaption></figure><p>但 kafka 却一直没被淘汰，说明 RocketMQ 必然是有着不如 kafka 的地方。<br> 是啥呢？<br><strong>性能</strong>，严格来说是<strong>吞吐量</strong>。阿里中间件团队对它们做过压测，同样条件下，kafka 比 RocketMQ 快 50%左右。但即使这样，RocketMQ 依然能每秒处理 10w 量级的数据，依旧非常能打。<br> 你不能说 RocketMQ 弱，只能说 Kafka 性能太强了。</p><p>不过这就很奇怪了，<strong>为什么 RocketMQ 参考了 kafka 的架构，却不能跟 kafka 保持一样的性能呢</strong>？<br> 在回答这个问题之前，我们来聊下什么是<strong>零拷贝</strong>。</p><h2 id="零拷贝是什么" tabindex="-1"><a class="header-anchor" href="#零拷贝是什么"><span>零拷贝是什么</span></a></h2><p>我们知道，消息队列的消息为了防止进程崩溃后丢失，一般不会放内存里，而是放磁盘上。<br> 那么问题就来了，消息从消息队列的磁盘，发送到消费者，过程是怎么样的呢？</p><h3 id="消息的发送过程" tabindex="-1"><a class="header-anchor" href="#消息的发送过程"><span>消息的发送过程</span></a></h3><p>操作系统分为<strong>用户空间</strong>和<strong>内核空间</strong>。<br> 程序处于用户空间，而磁盘属于硬件，操作系统本质上是程序和硬件设备的一个<strong>中间层</strong>。程序需要通过操作系统去调用硬件能力。</p><p><img src="https://cdn.xiaobaidebug.top/1722555643564.jpeg" alt="操作系统是程序和硬件的中间层" loading="lazy"><br> 如果用户想要将数据从磁盘发送到网络。那么就会发生下面这几件事：<br> 程序会发起<strong>系统调用</strong><code>read()</code>，尝试读取磁盘数据，</p><ul><li>磁盘数据从设备<strong>拷贝</strong>到内核空间的缓冲区。</li><li>再从内核空间的缓冲区<strong>拷贝</strong>到用户空间。</li></ul><p>程序再发起<strong>系统调用</strong><code>write()</code>，将读到的数据发到网络：</p><ul><li>数据从用户空间<strong>拷贝</strong>到 socket 发送缓冲区</li><li>再从 socket 发送缓冲区<strong>拷贝</strong>到网卡。</li></ul><p>最终数据就会经过网络到达消费者。</p><figure><img src="https://cdn.xiaobaidebug.top/1722555691634.jpeg" alt="原始发送流程" tabindex="0" loading="lazy"><figcaption>原始发送流程</figcaption></figure><p>整个过程，本机内发生了 <code>2</code> 次<strong>系统调用</strong>，对应 <code>4</code> 次用户空间和内核空间的<strong>切换</strong>，以及 <code>4</code> 次数据<strong>拷贝</strong>。<br><img src="https://cdn.xiaobaidebug.top/1722555706861.jpeg" alt="4次切换" loading="lazy"><br> 一顿操作猛如虎，结果就是同样一份数据来回拷贝。<br> 有没有办法优化呢？<br> 有，它就是零拷贝技术，常见的方案有两种，分别是 <code>mmap</code> 和 <code>sendfile</code>。我们来看下它们是什么。</p><h3 id="mmap-是什么" tabindex="-1"><a class="header-anchor" href="#mmap-是什么"><span>mmap 是什么</span></a></h3><p><code>mmap</code> 是操作系统内核提供的一个方法，可以将内核空间的缓冲区<strong>映射</strong>到用户空间。</p><figure><img src="https://cdn.xiaobaidebug.top/1722555730034.jpeg" alt="mmap映射内存" tabindex="0" loading="lazy"><figcaption>mmap映射内存</figcaption></figure><p>用了它，整个发送流程就有了一些变化。<br> 程序发起<strong>系统调用</strong><code>mmap()</code>，尝试读取磁盘数据，具体情况如下：</p><ul><li>磁盘数据从设备<strong>拷贝</strong>到内核空间的缓冲区。</li><li>内核空间的缓冲区<strong>映射</strong>到用户空间，这里<strong>不需要</strong>拷贝。</li></ul><p>程序再发起<strong>系统调用</strong><code>write()</code>，将读到的数据发到网络：</p><ul><li>数据从内核空间缓冲区<strong>拷贝</strong>到 socket 发送缓冲区。</li><li>再从 socket 发送缓冲区<strong>拷贝</strong>到网卡。</li></ul><figure><img src="https://cdn.xiaobaidebug.top/1722555757439.jpeg" alt="基于mmap的发送流程" tabindex="0" loading="lazy"><figcaption>基于mmap的发送流程</figcaption></figure><p>整个过程，发生了 <code>2</code> 次系统调用，对应 <code>4</code> 次用户空间和内核空间的切换，以及 <code>3</code> 次数据拷贝，对比之前，省下<strong>一次</strong>内核空间到用户空间的拷贝。</p><p><img src="https://cdn.xiaobaidebug.top/1722555796816.jpeg" alt="4次切换" loading="lazy"><br> 看到这里大家估计也蒙了，不是说零拷贝吗？怎么还有 3 次拷贝。<br> mmap 作为一种零拷贝技术，指的是用户空间到内核空间这个过程不需要拷贝，而不是指数据从磁盘到发送到网卡这个过程零拷贝。</p><p><img src="https://cdn.xiaobaidebug.top/1722555810648.jpeg" alt="这该洗的文字游戏" loading="lazy"><br><strong>确实省了一点，但不多</strong>。有没有更彻底的零拷贝？<br> 有，用 <code>sendfile</code>.</p><h3 id="sendfile-是什么" tabindex="-1"><a class="header-anchor" href="#sendfile-是什么"><span>sendfile 是什么</span></a></h3><p><code>sendfile</code>，也是内核提供的一个方法，从名字可以看出，就是用来<strong>发送文件数据</strong>的。<br> 程序发起<strong>系统调用</strong><code>sendfile()</code>，内核会尝试读取磁盘数据然后发送，具体情况如下：</p><ul><li>磁盘数据从设备<strong>拷贝</strong>到内核空间的缓冲区。</li><li>内核空间缓冲区里的数据<strong>可以</strong>直接<strong>拷贝</strong>到网卡。</li></ul><figure><img src="https://cdn.xiaobaidebug.top/1722555899562.jpeg" alt="基于sendfile的发送流程" tabindex="0" loading="lazy"><figcaption>基于sendfile的发送流程</figcaption></figure><p>整个过程，发生了 <code>1</code> 次系统调用，对应 <code>2</code> 次用户空间和内核空间的切换，以及 <code>2</code> 次数据拷贝。<br> 这时候问题很多的小明就有意见了，说好的<strong>零</strong>拷贝怎么还有 <code>2</code> 次拷贝？</p><p><img src="https://cdn.xiaobaidebug.top/1722555845114.jpeg" alt="2次切换" loading="lazy"><br> 其实，这里的零拷贝指的是<strong>零 CPU</strong>拷贝。<br> 也就是说 sendfile 场景下，需要的两次拷贝，都不是 CPU 直接参与的拷贝，而是其他硬件设备技术做的拷贝，不耽误我们 CPU 跑程序。</p><h3 id="kafka-为什么性能比-rocketmq-好" tabindex="-1"><a class="header-anchor" href="#kafka-为什么性能比-rocketmq-好"><span>kafka 为什么性能比 RocketMQ 好</span></a></h3><p>聊完两种零拷贝技术，我们回过头来看下 kafka 为什么性能比 RocketMQ 好。<br> 这是因为 <strong>RocketMQ 使用的是 mmap 零拷贝技术，而 kafka 使用的是 sendfile</strong>。kafka 以更少的拷贝次数以及系统内核切换次数，获得了更高的性能。<br> 但问题又来了，为什么 RocketMQ 不使用 sendfile？参考 kafka 抄个作业也不难啊？<br> 我们来看下 <code>sendfile</code> 函数长啥样。</p><div class="language-c line-numbers-mode" data-ext="c" data-title="c"><pre class="language-c"><code><span class="token class-name">ssize_t</span> <span class="token function">sendfile</span><span class="token punctuation">(</span><span class="token keyword">int</span> out_fd<span class="token punctuation">,</span> <span class="token keyword">int</span> in_fd<span class="token punctuation">,</span> <span class="token class-name">off_t</span><span class="token operator">*</span> offset<span class="token punctuation">,</span> <span class="token class-name">size_t</span> count<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// num = sendfile(xxx);</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>再来看下 <code>mmap</code> 函数长啥样。</p><div class="language-c line-numbers-mode" data-ext="c" data-title="c"><pre class="language-c"><code><span class="token keyword">void</span> <span class="token operator">*</span><span class="token function">mmap</span><span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span>addr<span class="token punctuation">,</span> <span class="token class-name">size_t</span> length<span class="token punctuation">,</span> <span class="token keyword">int</span> prot<span class="token punctuation">,</span> <span class="token keyword">int</span> flags<span class="token punctuation">,</span>
           <span class="token keyword">int</span> fd<span class="token punctuation">,</span> <span class="token class-name">off_t</span> offset<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// buf = mmap(xxx)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>注释里写的是两个函数的用法，<code>mmap</code> 返回的是数据的<strong>具体内容</strong>，应用层能获取到消息内容并进行一些逻辑处理。</p><p><img src="https://cdn.xiaobaidebug.top/1722555950668.jpeg" alt="mmap能获取到具体内容" loading="lazy">而 <code>sendfile</code> 返回的则是发送成功了几个<strong>字节数</strong>，<strong>具体发了什么内容，应用层根本不知道</strong>。</p><p><img src="https://cdn.xiaobaidebug.top/1722555968565.jpeg" alt="sendfile只返回num" loading="lazy"><br> 而 RocketMQ 的一些功能，却需要了解具体这个消息内容，方便二次投递等，比如将消费失败的消息重新投递到死信队列中，如果 RocketMQ 使用 sendfile，那根本没机会获取到消息内容长什么样子，也就没办法实现一些好用的功能了。</p><p><img src="https://cdn.xiaobaidebug.top/1722556008636.jpeg" alt="rocketMQ有二次投递等功能" loading="lazy"><br> 而 kafka 却没有这些功能特性，追求极致性能，正好可以使用 sendfile。</p><p>除了零拷贝以外，kafka 高性能的原因还有很多，比如什么批处理，数据压缩啥的，但那些优化手段 rocketMQ 也都能借鉴一波，唯独这个零拷贝，那是毫无办法。</p><p><img src="https://cdn.xiaobaidebug.top/1722556052377.jpeg" alt="Kafka的优化手段" loading="lazy"><br> 所以还是那句话，没有一种架构是完美的，一种架构往往用于适配某些场景，你很难做到既要又要还要。<br> 当场景不同，我们就需要做一些定制化改造，通过牺牲一部分能力去换取另一部分能力。<br> 做架构，做到最后都是在做折中。<br> 是不是感觉升华了。</p><h3 id="kafka-和-rocketmq-怎么选" tabindex="-1"><a class="header-anchor" href="#kafka-和-rocketmq-怎么选"><span>kafka 和 RocketMQ 怎么选？</span></a></h3><p>这时候大家估计还是想知道 kafka 和 RocketMQ 到底该怎么选，用哪个。<br> 官方点的回答是&quot;这个要看场景的&quot;。说了等于没说。<br> 这不是我的风格。<br> 我的标准只有一个，如果是大数据场景，比如你能频繁听到 spark，flink 这些关键词的时候，那就用 kafka。<br> 除此之外，如果公司组件支持，尽量用 RocketMQ。</p><p>现在大家通了吗？</p><h2 id="总结" tabindex="-1"><a class="header-anchor" href="#总结"><span>总结</span></a></h2><ul><li>RocketMQ 和 kafka 相比，在架构上做了减法，在功能上做了加法</li><li>跟 kafka 的架构相比，RocketMQ 简化了协调节点和分区以及备份模型。同时增强了消息过滤、消息回溯和事务能力，加入了延迟队列，死信队列等新特性。</li><li>凡事皆有代价，RocketMQ 牺牲了一部分性能，换取了比 kafka 更强大的功能特性。</li></ul><h2 id="推荐阅读" tabindex="-1"><a class="header-anchor" href="#推荐阅读"><span>推荐阅读</span></a></h2><p><a href="/%E4%B8%AD%E9%97%B4%E4%BB%B6/kafka/%E9%9D%A2%E8%AF%95%E9%A2%98">kafka面试八股文</a><br><a href="/%E4%B8%AD%E9%97%B4%E4%BB%B6/rocketmq/%E9%9D%A2%E8%AF%95%E9%A2%98">rocketMQ面试八股文</a></p>`,51)]))}const r=e(s,[["render",p],["__file","RocketMQ为什么性能不如Kafka.html.vue"]]),l=JSON.parse('{"path":"/%E4%B8%AD%E9%97%B4%E4%BB%B6/rocketmq/%E6%A0%B8%E5%BF%83%E7%9F%A5%E8%AF%86%E7%82%B9/RocketMQ%E4%B8%BA%E4%BB%80%E4%B9%88%E6%80%A7%E8%83%BD%E4%B8%8D%E5%A6%82Kafka.html","title":"RocketMQ 为什么性能不如 Kafka？","lang":"zh-CN","frontmatter":{"description":"RocketMQ 为什么性能不如 Kafka？ 在上篇文章《rocketmq 是什么》中，我们了解到 RocketMQ 的架构其实参考了 kafka 的设计思想，同时又在 kafka 的基础上做了一些调整。 看起来，RocketMQ 好像各方面都比 kafka 更能打。 Kafka与RocketMQ对比Kafka与RocketMQ对比 但 kafka ...","head":[["meta",{"property":"og:url","content":"https://golangguide.top/%E4%B8%AD%E9%97%B4%E4%BB%B6/rocketmq/%E6%A0%B8%E5%BF%83%E7%9F%A5%E8%AF%86%E7%82%B9/RocketMQ%E4%B8%BA%E4%BB%80%E4%B9%88%E6%80%A7%E8%83%BD%E4%B8%8D%E5%A6%82Kafka.html"}],["meta",{"property":"og:site_name","content":"golang全栈指南"}],["meta",{"property":"og:title","content":"RocketMQ 为什么性能不如 Kafka？"}],["meta",{"property":"og:description","content":"RocketMQ 为什么性能不如 Kafka？ 在上篇文章《rocketmq 是什么》中，我们了解到 RocketMQ 的架构其实参考了 kafka 的设计思想，同时又在 kafka 的基础上做了一些调整。 看起来，RocketMQ 好像各方面都比 kafka 更能打。 Kafka与RocketMQ对比Kafka与RocketMQ对比 但 kafka ..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:image","content":"https://cdn.xiaobaidebug.top/1722555605803.jpeg"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2024-08-03T00:37:09.000Z"}],["meta",{"name":"twitter:card","content":"summary_large_image"}],["meta",{"name":"twitter:image:alt","content":"RocketMQ 为什么性能不如 Kafka？"}],["meta",{"property":"article:author","content":"小白debug"}],["meta",{"property":"article:modified_time","content":"2024-08-03T00:37:09.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"RocketMQ 为什么性能不如 Kafka？\\",\\"image\\":[\\"https://cdn.xiaobaidebug.top/1722555605803.jpeg\\",\\"https://cdn.xiaobaidebug.top/1722555643564.jpeg\\",\\"https://cdn.xiaobaidebug.top/1722555691634.jpeg\\",\\"https://cdn.xiaobaidebug.top/1722555706861.jpeg\\",\\"https://cdn.xiaobaidebug.top/1722555730034.jpeg\\",\\"https://cdn.xiaobaidebug.top/1722555757439.jpeg\\",\\"https://cdn.xiaobaidebug.top/1722555796816.jpeg\\",\\"https://cdn.xiaobaidebug.top/1722555810648.jpeg\\",\\"https://cdn.xiaobaidebug.top/1722555899562.jpeg\\",\\"https://cdn.xiaobaidebug.top/1722555845114.jpeg\\",\\"https://cdn.xiaobaidebug.top/1722555950668.jpeg\\",\\"https://cdn.xiaobaidebug.top/1722555968565.jpeg\\",\\"https://cdn.xiaobaidebug.top/1722556008636.jpeg\\",\\"https://cdn.xiaobaidebug.top/1722556052377.jpeg\\"],\\"dateModified\\":\\"2024-08-03T00:37:09.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"小白debug\\",\\"url\\":\\"https://xiaobaidebug.top/\\"}]}"],["link",{"rel":"canonical","href":"https://golangguide.top/%E4%B8%AD%E9%97%B4%E4%BB%B6/rocketmq/%E6%A0%B8%E5%BF%83%E7%9F%A5%E8%AF%86%E7%82%B9/RocketMQ%E4%B8%BA%E4%BB%80%E4%B9%88%E6%80%A7%E8%83%BD%E4%B8%8D%E5%A6%82Kafka.html"}],["meta",{"property":"og:url","content":"https://golangguide.top/%E4%B8%AD%E9%97%B4%E4%BB%B6/rocketmq/%E6%A0%B8%E5%BF%83%E7%9F%A5%E8%AF%86%E7%82%B9/RocketMQ%E4%B8%BA%E4%BB%80%E4%B9%88%E6%80%A7%E8%83%BD%E4%B8%8D%E5%A6%82Kafka.html"}],["meta",{"property":"og:site_name","content":"golang全栈指南"}],["meta",{"property":"og:title","content":"RocketMQ 为什么性能不如 Kafka？"}],["meta",{"property":"og:description","content":"RocketMQ 为什么性能不如 Kafka？ 在上篇文章《rocketmq 是什么》中，我们了解到 RocketMQ 的架构其实参考了 kafka 的设计思想，同时又在 kafka 的基础上做了一些调整。 看起来，RocketMQ 好像各方面都比 kafka 更能打。 Kafka与RocketMQ对比Kafka与RocketMQ对比 但 kafka ..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2024-08-03T00:37:09.000Z"}],["meta",{"property":"article:modified_time","content":"2024-08-03T00:37:09.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"RocketMQ 为什么性能不如 Kafka？\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2024-08-03T00:37:09.000Z\\",\\"author\\":[]}"]]},"headers":[{"level":2,"title":"零拷贝是什么","slug":"零拷贝是什么","link":"#零拷贝是什么","children":[{"level":3,"title":"消息的发送过程","slug":"消息的发送过程","link":"#消息的发送过程","children":[]},{"level":3,"title":"mmap 是什么","slug":"mmap-是什么","link":"#mmap-是什么","children":[]},{"level":3,"title":"sendfile 是什么","slug":"sendfile-是什么","link":"#sendfile-是什么","children":[]},{"level":3,"title":"kafka 为什么性能比 RocketMQ 好","slug":"kafka-为什么性能比-rocketmq-好","link":"#kafka-为什么性能比-rocketmq-好","children":[]},{"level":3,"title":"kafka 和 RocketMQ 怎么选？","slug":"kafka-和-rocketmq-怎么选","link":"#kafka-和-rocketmq-怎么选","children":[]}]},{"level":2,"title":"总结","slug":"总结","link":"#总结","children":[]},{"level":2,"title":"推荐阅读","slug":"推荐阅读","link":"#推荐阅读","children":[]}],"git":{"createdTime":1722645429000,"updatedTime":1722645429000,"contributors":[{"name":"xiaobai-tech","email":"948485496@qq.com","commits":1}]},"readingTime":{"minutes":6.94,"words":2083},"filePathRelative":"中间件/rocketmq/核心知识点/RocketMQ为什么性能不如Kafka.md","localizedDate":"2024年8月3日","autoDesc":true}');export{r as comp,l as data};
