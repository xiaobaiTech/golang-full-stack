import{_ as i}from"./plugin-vue_export-helper-DlAUqK2U.js";import{r as s,o as r,c as d,a as t,b as e,d as o,e as a}from"./app-BHIpk5aV.js";const g={},p=a(`<h1 id="都是同样条件的-mysql-select-语句-为什么读到的内容却不一样" tabindex="-1"><a class="header-anchor" href="#都是同样条件的-mysql-select-语句-为什么读到的内容却不一样"><span>都是同样条件的 mysql select 语句，为什么读到的内容却不一样？</span></a></h1><p>假设当前数据库里有下面这张表。</p><figure><img src="https://cdn.xiaobaidebug.top/image/user表数据库原始状态4.drawio.png" alt="user表数据库原始状态" tabindex="0" loading="lazy"><figcaption>user表数据库原始状态</figcaption></figure><p>老规矩，以下内容还是默认发生在 innodb 引擎的<strong>可重复读隔离级别</strong>下。</p><figure><img src="https://cdn.xiaobaidebug.top/image/都是select结果却不同1.drawio.png" alt="都是select结果却不同" tabindex="0" loading="lazy"><figcaption>都是select结果却不同</figcaption></figure><p>大家可以看到，<strong>线程 1</strong>，同样都是读 <code>age &gt;= 3</code> 的数据。第一次读到<strong>1 条数据</strong>，这个是原始状态。这之后线程 2 将 id=2 的 age 字段也改成了 3。</p><p>线程 1 此时再读两次，一次读到的结果还是原来的<strong>1 条</strong>，另一次读的结果却是<strong>2 条</strong>，<strong>区别在于加没加 for update。</strong></p><p>为什么同样条件下，都是读，读出来的数据却不一样呢？</p><p>可重复读不是要求每次读出来的内容要一样吗？</p><br><p>要回答这个问题。</p><p>我需要从盘古是怎么开天辟地这个话题开始聊起。</p><br><p>不好意思。</p><p>失态了。</p><p>那就从事务是怎么回滚的开始聊起吧。</p><br><h2 id="事务的回滚是怎么实现的" tabindex="-1"><a class="header-anchor" href="#事务的回滚是怎么实现的"><span>事务的回滚是怎么实现的</span></a></h2><p>我们在执行事务的时候，一般都是下面这样的格式</p><div class="language-sql line-numbers-mode" data-ext="sql" data-title="sql"><pre class="language-sql"><code><span class="token keyword">begin</span><span class="token punctuation">;</span>
操作<span class="token number">1</span><span class="token punctuation">;</span>
操作<span class="token number">2</span><span class="token punctuation">;</span>
操作<span class="token number">3</span><span class="token punctuation">;</span>
xxxxx
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token keyword">commit</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在提交事务之前，会执行各种操作，里面可以包含各种逻辑。</p><p>只要是执行逻辑，那就<strong>有可能</strong>会报错。</p><p>回想下事务的<code>ACID</code>里有个<code>A</code>，<strong>原子性</strong>，整个事务就是个整体，要么一起成功，要么一起失败。</p><figure><img src="https://cdn.xiaobaidebug.top/image/ACID.png" alt="ACID" tabindex="0" loading="lazy"><figcaption>ACID</figcaption></figure><p>如果失败了的话，那就要让执行到一半的事务有能力回到没执行事务前的状态，这就是<strong>回滚</strong>。</p><p>执行事务的代码就类似写成下面这样。</p><div class="language-sql line-numbers-mode" data-ext="sql" data-title="sql"><pre class="language-sql"><code><span class="token keyword">begin</span><span class="token punctuation">;</span>
try:
	操作<span class="token number">1</span><span class="token punctuation">;</span>
  操作<span class="token number">2</span><span class="token punctuation">;</span>
  操作<span class="token number">3</span><span class="token punctuation">;</span>
  xxxxx
  <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
  <span class="token keyword">commit</span><span class="token punctuation">;</span>
<span class="token keyword">except</span> Exception:
	<span class="token keyword">rollback</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>如果执行<code>rollback</code>能回到事务执行前的状态的话，那说明 mysql 需要知道某些行，执行事务前的数据长什么样子。</p><p>那数据库是怎么做到的呢？</p><p>这就要提到<strong>undo 日志</strong>了，它记录了某一行数据，在执行事务前是怎么样的。</p><p>比如<code>id=1</code>那行数据，<code>name</code>字段从**&quot;小白&quot;<strong>更新成了</strong>&quot;小白 debug&quot;**，那就会新增一个 undo 日志，用于记录之前的数据。</p><figure><img src="https://cdn.xiaobaidebug.top/image/undo日志会记录之前的数据.drawio.png" alt="undo日志会记录之前的数据" tabindex="0" loading="lazy"><figcaption>undo日志会记录之前的数据</figcaption></figure><p>由于同时并发执行的事务可以有很多，于是可能会有很多 undo 日志，日志里加入事务的 id（<code>trx_id</code>）字段，用于标明这是哪个事务下产生的 undo 日志。</p><p>同时将它们用<strong>链表的形式</strong>组织起来，在 undo 日志里加入一个指针（<code>roll_pointer</code>），指向上一个 undo 日志，于是就形成了一条<strong>版本链</strong>。</p><figure><img src="https://cdn.xiaobaidebug.top/image/undo日志版本链.png" alt="undo日志版本链" tabindex="0" loading="lazy"><figcaption>undo日志版本链</figcaption></figure><p>有了这个版本链，当某个事务执行到一半发现失败时，就直接回滚，这时候就可以顺着这个版本链，回到执行事务前的状态。</p><br><h2 id="当前读和快照读是什么" tabindex="-1"><a class="header-anchor" href="#当前读和快照读是什么"><span>当前读和快照读是什么</span></a></h2><p>有了上面的 undo 日志版本链之后，我们可以看到<strong>最新的数据在表头</strong>，在这之后的都是一个个旧的数据版本。不管是最新的，还是旧的数据版本，我们都叫它数据<strong>快照</strong>。</p><p><strong>当前读</strong>，读的就是版本链的表头，也就是<strong>最新的数据</strong>。</p><p><strong>快照读</strong>，读的就是版本链里的其中一个快照，当然如果这个快照正好就是表头，那此时快照读和当前读的结果一样。</p><figure><img src="https://cdn.xiaobaidebug.top/image/当前读和快照读.drawio.png" alt="当前读和快照读" tabindex="0" loading="lazy"><figcaption>当前读和快照读</figcaption></figure><p>我们平时执行的普通 select 语句，比如下面这种，就是<strong>快照读</strong>。</p><div class="language-text line-numbers-mode" data-ext="text" data-title="text"><pre class="language-text"><code>select * from user where phone_no=2；
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>而特殊的 select 语句，比如在<code>select</code>后面加上<code>lock in share mode</code>或<code>for update</code>，都属于<strong>当前读</strong>。</p><p>除此之外<code>insert，update，delete</code>操作都属于<strong>写操作</strong>，既然写，那必然是写最新的数据，所以都会引发当前读。</p><br><p>那么问题来了。</p><p><strong>当前读</strong>，读的是版本链的<strong>表头</strong>，那么执行当前读的时候，有没有可能恰好有其他事务，生成更加新的快照，替代当前表头，成为新的表头呢，<strong>那这时候岂不是读的不是最新数据了？</strong></p><p>答案是<strong>不会</strong>，不管是 select ... for update 这些（特殊的）读操作，还是 insert、update 这些写操作，<strong>都会对这行数据加锁</strong>。而生成 undo 日志快照，也是在<strong>写操作</strong>的情况下生成的，执行写操作前<strong>也需要获得锁</strong>。所以写操作需要阻塞等待<strong>当前读</strong>完成后，获得锁后才能更新版本链。</p><br><h2 id="read-view" tabindex="-1"><a class="header-anchor" href="#read-view"><span>read view</span></a></h2><p>数据库里可以同时并发执行非常多的事务, <strong>每个事务都会被分配一个事务 ID, 这个 ID 是递增的，越新的事务，ID 越大。</strong></p><p>而数据表里某行数据的 undo 日志版本链，每个 undo 日志上面也有一个事务 id (<code>trx_id</code>)，它是创建这个 undo 日志的<strong>事务 id</strong>。</p><p>并不是所有事务都会生成 undo 日志，也就是说某行数据的 undo 日志版本链上只有<strong>部分</strong>事务的 id。但是，<strong>所有</strong>事务都有可能会访问这行数据对应的版本链。而且版本链上虽然有很多 undo 日志快照，但也不是所有 undo 日志都能被读，毕竟有些 undo 日志，创建它们的事务还没提交呢，人家随时可能失败并回滚。</p><p>现在的问题就成了，<strong>现在有一个事务，通过快照读的方式去读 undo 日志版本链，那它能读哪些快照？并且它应该读哪个快照？</strong></p><p>这里就要引入一个<strong>read view</strong>的概念。它就像是一个有上下边界的滑动窗口。</p><p>整个数据库里有那么多事务，这些事务分为已经提交（commit）的，和没提交的。没提交的，意味着这些事务还在进行中，也就是所谓的<strong>活跃事务</strong>。所有的活跃事务的 id，组成<strong>m_ids</strong>。而这其中最小的事务 id 就是 read view 的<strong>下边界，叫 min_trx_id。</strong></p><p>产生 read view 的那一刻，<strong>所有事务里最大的事务 id</strong>，加个 1，就是这个 read view 的<strong>上边界，叫 max_trx_id。</strong></p><p>概念太多，有点乱？没事的，继续往下看，后面会有例子的。</p><br><h3 id="事务能读哪些快照" tabindex="-1"><a class="header-anchor" href="#事务能读哪些快照"><span>事务能读哪些快照</span></a></h3><p>有了这些基础信息之后，我们先看下事务在 read view 下，他<strong>能读哪些快照呢？</strong></p><p>记住一个大前提：<strong>事务只能读到自己产生的 undo 日志数据（事务提不提交都行），或者是其他事务已经提交完成的数据</strong>。</p><p>现在事务（假设就叫<strong>事务 A</strong>吧）有了 read view 之后，不管看哪个 undo 日志版本链，我们都可以把 read view 往版本链上一放。版本链就被分成了好几部分。</p><figure><img src="https://cdn.xiaobaidebug.top/image/readview2.drawio.png" alt="readview" tabindex="0" loading="lazy"><figcaption>readview</figcaption></figure><ul><li><p><strong>版本链快照的 trx_id &lt; read view 的 min_trx_id</strong></p><p>从上面的描述中，我们可以知道 read view 的 m_ids 来源于数据库所有<strong>活跃事务的 id</strong>，而最小的 min_trx_id 就是 read view 的下边界，因为事务 id 是根据时间递增的，所以<strong>如果版本链快照的 trx_id 比 min_trx_id 还要小，那这些肯定都是非活跃（已经提交）的事务 id，这些快照都能被事务 A 读到。</strong></p></li><li><p><strong>版本链快照的 trx_id &gt;= read view 的 max_trx_id</strong></p><p>max_trx_id 是在<strong>事务 A 创建 read view 的那一刻产生的</strong>，它比<strong>那时候</strong>所有数据库已知的事务 id 都还要大。所以如果 undo 日志版本链上的某个快照上含有比 max_trx_id 还要大的 trx_id，那说明这个快照已经超出事务 A 的&quot;理解范围了&quot;，它不该被读到。</p></li><li><p><strong>read view 的 min_trx_id &lt;= 版本链快照的 trx_id &lt; read view 的 max_trx_id</strong></p><ul><li>如果版本链快照的 trx_id 正好就是事务 A 的 id，那正好是它自己生成的 undo 日志快照，那不管有没有提交，<strong>都能读</strong>。</li><li>如果版本链快照的 trx_id 正好在活跃事务 m_ids 中, 那这些事务数据都还没提交，所以事务 A 不能读到它们</li><li>除了上面两种情况外，剩下的都是<strong>已经提交</strong>的事务数据，可以放心读。</li></ul></li></ul><br><h3 id="事务会读哪个快照" tabindex="-1"><a class="header-anchor" href="#事务会读哪个快照"><span>事务会读哪个快照</span></a></h3><p>上面提到，事务在 read view 的可见范围里，有机会能读到 N 多快照。但那么<strong>多快照版本，事务具体会读哪个快照呢？</strong></p><p>事务会<strong>从表头开始</strong>遍历这个 undo 日志版本链，它会拿每个 undo 日志里的 trx_id 去跟自己的 read view 的上下边界去做判断。<strong>第一个出现的小于 max_trx_id 的快照</strong>。</p><ul><li>如果快照是自己产生，那<strong>提不提交都行</strong>，就决定是读它了。</li><li>如果快照是别人产生的，且<strong>已经提交完成</strong>了，那也行，决定读它了。</li></ul><p>比如下图，<code>undo日志1</code>正好小于<code>max_trx_id</code>，且事务已经提交，那么就读它了。</p><figure><img src="https://cdn.xiaobaidebug.top/image/readview与undo版本链3.drawio.png" alt="readview与undo版本链" tabindex="0" loading="lazy"><figcaption>readview与undo版本链</figcaption></figure><br><h3 id="mvcc-是什么" tabindex="-1"><a class="header-anchor" href="#mvcc-是什么"><span>MVCC 是什么</span></a></h3><p>像上面这种，维护一个多快照的<strong>undo 日志版本链</strong>，事务根据自己的<code>read view</code>去决定具体读那个 undo 日志<strong>快照</strong>，最理想的情况下是每个事务都读自己的一份快照，然后在这个快照上做自己的逻辑，只有在写数据的时候，才去操作最新的行数据，这样<strong>读和写就被分开了</strong>，比起单行数据没有快照的方式，它能更好的解决读写冲突，所以数据库并发性能也更好。其实这就是面试里常问的<strong>MVCC</strong>，全称<strong>M</strong>ulti-<strong>V</strong>ersion <strong>C</strong>oncurrency <strong>C</strong>ontrol，即<strong>多版本并发控制。</strong></p><figure><img src="https://cdn.xiaobaidebug.top/image/MVCC.png" alt="MVCC" tabindex="0" loading="lazy"><figcaption>MVCC</figcaption></figure><br><h2 id="四个隔离级别是怎么实现的" tabindex="-1"><a class="header-anchor" href="#四个隔离级别是怎么实现的"><span>四个隔离级别是怎么实现的</span></a></h2>`,80),l={href:"https://mp.weixin.qq.com/s/2UxF7GJrAW2nY8bB57ZogQ",target:"_blank",rel:"noopener noreferrer"},c=a('<p>知道了<strong>undo 日志版本链</strong>和<strong>MVCC</strong>之后，我们再回过头来看下这个问题。</p><figure><img src="https://cdn.xiaobaidebug.top/image/四层隔离级别.png" alt="四层隔离级别" tabindex="0" loading="lazy"><figcaption>四层隔离级别</figcaption></figure><p><strong>读未提交</strong>，每次读到的都是最新的数据，也不管数据行所在的事务是否提交。实现也很简单，只需要每次都读 undo 日志版本链的<strong>链表头</strong>（最新的快照）就行了。</p><p>与读未提交不同，<strong>读提交和可重复读隔离级别都是基于 MVCC 的 read view 实现的</strong>，反过来说, <strong>MVCC 也只会出现在这两个隔离级别里</strong>。</p><p><strong>读已提交</strong>隔离级别，<strong>每次执行普通 select，都会重新生成一个新的 read view</strong>，然后拿着这个<strong>最新的 read view</strong>到某行数据的版本链上挨个遍历，找到第一个合适的数据。这样就能做到每次都读到其他事务最新<strong>已提交</strong>的数据。</p><p><strong>可重复读</strong>隔离级别下的事务只会在<strong>第一次</strong>执行<strong>普通 select</strong>时生成<code>read view</code>，后续不管执行几次普通 select，都会<strong>复用</strong>这个 read view。这样就能保持每次读的时候都是在同一标准下进行读取，那读到的数据也会是一样的。</p><p><strong>串行化</strong>目的就是让并发事务看起来就像单线程执行一样，那实现也很简单，<strong>和读未提交隔离级别一样</strong>，串行化隔离界别下事务只读 undo 日志链的链表头，也就是<strong>最新版本的快照</strong>，并且就算是普通 select，也会在版本链的<strong>最新快照</strong>上加入<strong>读锁</strong>。这样其他事务想写，也得等这个读锁释放掉才行。所有对这行数据进行操作的事务，都老老实实地阻塞等待加锁，一个接一个进行处理，从效果上看就跟单线程处理一样。</p><br><h2 id="再看文章开头的例子" tabindex="-1"><a class="header-anchor" href="#再看文章开头的例子"><span>再看文章开头的例子</span></a></h2><p>我们用上面提到的概念，重新回到文章开头的例子，梳理一遍。</p><figure><img src="https://cdn.xiaobaidebug.top/image/user表数据库原始状态4.drawio.png" alt="user表数据库原始状态" tabindex="0" loading="lazy"><figcaption>user表数据库原始状态</figcaption></figure><p>我们<strong>假设</strong>数据库一开始的三条数据，都是由<code>trx_id=1</code>的事务<code>insert</code>生成的。</p><p>于是数据表一开始长下面这样。每行数据只有一个快照。注意快照里，<code>trx_id</code>填的是创建它们的事务 id，也就是刚刚提到的事务<code>1</code>。<code>roll_pointer</code>原本应该指向 insert 产生的 undo 日志，为了简化，这里写为<code>null</code>（insert undo 日志在事务提交后可以被清理掉）。</p><figure><img src="https://cdn.xiaobaidebug.top/image/user表数据库原始trx信息.drawio.png" alt="user表数据库原始trx信息.drawio" tabindex="0" loading="lazy"><figcaption>user表数据库原始trx信息.drawio</figcaption></figure><p>下面这个图，还是文章开头的图，这里放出来是为了方便大家，不用划回去看了。</p><figure><img src="https://cdn.xiaobaidebug.top/image/都是select结果却不同1.drawio.png" alt="都是select结果却不同" tabindex="0" loading="lazy"><figcaption>都是select结果却不同</figcaption></figure><p>在<strong>线程 1</strong>启动事务，我们假设它的事务<code>trx_id=2</code>，<strong>第一次执行普通 select，是快照读</strong>，在<strong>可重复读</strong>隔离级别，会生成一个<code>read view</code>。当前这个数据库，活跃事务只有它一个，那<code>m_ids =[2]</code>。 m_ids 里最小的 id，也就是<code>min_trx_id=2</code>。max_trx_id 是当前最大数据库事务 id（只有它自己，所以也是 2），加个 1，也就是<code>max_trx_id=3</code></p><figure><img src="https://cdn.xiaobaidebug.top/image/事务1的readview.drawio.png" alt="事务1的readview" tabindex="0" loading="lazy"><figcaption>事务1的readview</figcaption></figure><p>此时<strong>线程 1</strong>的事务，拿着这个 read view 去读数据库表。</p><p>因为这三条数据的 trx_id=1 都小于 min_trx_id=2，都属于可见范围，因此能读到这三条数据的所有快照，最后返回符合条件（age&gt;=3）的数据，有 1 条。</p><br><p>这时候事务 2，假设它的事务<code>trx_id=3</code>，执行更新操作，生成新的 undo 日志快照。</p><figure><img src="https://cdn.xiaobaidebug.top/image/user表数据库加入undo日志.drawio.png" alt="user表数据库加入undo日志" tabindex="0" loading="lazy"><figcaption>user表数据库加入undo日志</figcaption></figure><p>此时线程 1<strong>第二次执行普通 select</strong>，还是<strong>快照读</strong>，由于是可重复读，会复用之前的 read view，再执行一次读操作，这里重点关注 id=2 的那行数据，从版本链表头开始遍历，<strong>第一个快照 trx_id=3</strong> <code>&gt;=</code> <strong>read view 的 max_trx_id=3</strong>，因此不可读，遍历下一个快照<strong>trx_id=1</strong> <code>&lt;</code> <strong>min_trx_id=2</strong>，可读。于是 id=2 的那行数据，还是拿到 age=2，而不是更新后的 age=3，因此快照读结果还是只有<strong>1 条</strong>数据符合 age&gt;=3。</p><p>但是线程 1<strong>第三次读，执行 select for update</strong>，就成了<strong>当前读</strong>了，直接读 undo 日志版本链里<strong>最新的那行快照</strong>，于是能读到 id=2，age=3，所以最终结果返回<strong>符合 age&gt;=3 的数据有 2 条</strong>。</p><p>总的来说就是，由于快照读和当前读，读数据的规则不同，我们看到了不一样的结果。</p><br><p>看到这里，大家应该理解了，所谓的可重复读<strong>每次读</strong>都要读到一样的数据，这里头的**&quot;读&quot;<strong>，指的是</strong>快照读**。</p><p>如果下次面试官问你，<strong>可重复读隔离级别下每次读到的数据都是一样的吗？</strong></p><p>你该知道怎么回答了吧？</p><br><h2 id="总结" tabindex="-1"><a class="header-anchor" href="#总结"><span>总结</span></a></h2><ul><li>事务通过 undo 日志实现回滚的功能，从而实现事务的原子性（Atomicity）。</li><li>多个事务生成的 undo 日志构成一条版本链。<strong>快照读</strong>时事务根据 read view 来决定具体读哪个快照。<strong>当前读</strong>时事务直接读最新的快照版本。</li><li>mysql 的 innodb 引擎通过 MVCC 提升了读写并发。</li></ul><br><h2 id="最后" tabindex="-1"><a class="header-anchor" href="#最后"><span>最后</span></a></h2><p>最近原创更文的阅读量稳步下跌，思前想后，夜里辗转反侧。</p><p>我有个不成熟的请求。</p><figure><img src="https://cdn.xiaobaidebug.top/image/u=2281575747,3550568508&amp;fm=253&amp;fmt=auto&amp;app=120&amp;f=JPEG.jpeg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><br><p><strong>离开广东好长时间了，好久没人叫我靓仔了。</strong></p><p>大家可以在<strong>评论区</strong>里，叫我一靓仔吗？</p><p>我这么善良质朴的愿望，能被满足吗？</p><p>如果实在叫不出口的话，能帮我点下右下角的<strong>点赞和在看</strong>吗？</p><br><h5 id="别说了-一起在知识的海洋里呛水吧" tabindex="-1"><a class="header-anchor" href="#别说了-一起在知识的海洋里呛水吧"><span>别说了，一起在知识的海洋里呛水吧</span></a></h5><p><strong>点击</strong>下方名片，关注公众号:【小白 debug】<br><img src="https://cdn.xiaobaidebug.top/1696069689495.png" alt="" loading="lazy"></p><br><p>不满足于在留言区说骚话？</p><p>加我，我们建了个划水吹牛皮群，在群里，你可以跟你下次跳槽可能遇到的同事或面试官聊点有意思的话题。就<strong>超！开！心！</strong></p><img src="https://cdn.xiaobaidebug.top/image-20220522162616202.png" width="50%" align="center"><figure><img src="https://cdn.xiaobaidebug.top/image/006APoFYly1g5q9gn2jipg308w08wqdi.gif" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><h2 id="文章推荐" tabindex="-1"><a class="header-anchor" href="#文章推荐"><span>文章推荐：</span></a></h2>',52),u={href:"https://mp.weixin.qq.com/s/PP80aD-GQp7VtgyfHj392g",target:"_blank",rel:"noopener noreferrer"},E=t("li",null,[t("a",{href:"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/%E6%A0%B8%E5%BF%83%E7%9F%A5%E8%AF%86%E7%82%B9/TCP%E7%B2%98%E5%8C%85%EF%BC%81%E6%95%B0%E6%8D%AE%E5%8C%85%EF%BC%9A%E6%88%91%E5%8F%AA%E6%98%AF%E7%8A%AF%E4%BA%86%E6%AF%8F%E4%B8%AA%E6%95%B0%E6%8D%AE%E5%8C%85%E9%83%BD%E4%BC%9A%E7%8A%AF%E7%9A%84%E9%94%99%EF%BC%8C%E7%A1%AC%E6%A0%B8%E5%9B%BE%E8%A7%A3"},"TCP 粘包 数据包：我只是犯了每个数据包都会犯的错 |硬核图解")],-1),m=t("li",null,[t("a",{href:"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/%E6%A0%B8%E5%BF%83%E7%9F%A5%E8%AF%86%E7%82%B9/%E5%8A%A8%E5%9B%BE%E5%9B%BE%E8%A7%A3%EF%BC%81%E6%97%A2%E7%84%B6IP%E5%B1%82%E4%BC%9A%E5%88%86%E7%89%87%EF%BC%8C%E4%B8%BA%E4%BB%80%E4%B9%88TCP%E5%B1%82%E4%B9%9F%E8%BF%98%E8%A6%81%E5%88%86%E6%AE%B5%EF%BC%9F"},"动图图解！既然 IP 层会分片，为什么 TCP 层也还要分段？")],-1);function B(b,A){const n=s("ExternalLinkIcon");return r(),d("div",null,[p,t("p",null,[e("之前的写的"),t("a",l,[e("一篇文章"),o(n)]),e("最后留了个问题，四个隔离级别是怎么实现的。")]),c,t("ul",null,[t("li",null,[t("a",u,[e("程序员防猝死指南"),o(n)])]),E,m])])}const f=i(g,[["render",B],["__file","都是select语句，为什么读到的内容不一样？.html.vue"]]),_=JSON.parse('{"path":"/%E4%B8%AD%E9%97%B4%E4%BB%B6/mysql/%E6%A0%B8%E5%BF%83%E7%9F%A5%E8%AF%86%E7%82%B9/%E9%83%BD%E6%98%AFselect%E8%AF%AD%E5%8F%A5%EF%BC%8C%E4%B8%BA%E4%BB%80%E4%B9%88%E8%AF%BB%E5%88%B0%E7%9A%84%E5%86%85%E5%AE%B9%E4%B8%8D%E4%B8%80%E6%A0%B7%EF%BC%9F.html","title":"都是同样条件的 mysql select 语句，为什么读到的内容却不一样？","lang":"zh-CN","frontmatter":{"description":"都是同样条件的 mysql select 语句，为什么读到的内容却不一样？ 假设当前数据库里有下面这张表。 user表数据库原始状态user表数据库原始状态 老规矩，以下内容还是默认发生在 innodb 引擎的可重复读隔离级别下。 都是select结果却不同都是select结果却不同 大家可以看到，线程 1，同样都是读 age >= 3 的数据。第一次...","head":[["meta",{"property":"og:url","content":"https://golangguide.top/%E4%B8%AD%E9%97%B4%E4%BB%B6/mysql/%E6%A0%B8%E5%BF%83%E7%9F%A5%E8%AF%86%E7%82%B9/%E9%83%BD%E6%98%AFselect%E8%AF%AD%E5%8F%A5%EF%BC%8C%E4%B8%BA%E4%BB%80%E4%B9%88%E8%AF%BB%E5%88%B0%E7%9A%84%E5%86%85%E5%AE%B9%E4%B8%8D%E4%B8%80%E6%A0%B7%EF%BC%9F.html"}],["meta",{"property":"og:site_name","content":"golang全栈指南"}],["meta",{"property":"og:title","content":"都是同样条件的 mysql select 语句，为什么读到的内容却不一样？"}],["meta",{"property":"og:description","content":"都是同样条件的 mysql select 语句，为什么读到的内容却不一样？ 假设当前数据库里有下面这张表。 user表数据库原始状态user表数据库原始状态 老规矩，以下内容还是默认发生在 innodb 引擎的可重复读隔离级别下。 都是select结果却不同都是select结果却不同 大家可以看到，线程 1，同样都是读 age >= 3 的数据。第一次..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:image","content":"https://cdn.xiaobaidebug.top/image/user%E8%A1%A8%E6%95%B0%E6%8D%AE%E5%BA%93%E5%8E%9F%E5%A7%8B%E7%8A%B6%E6%80%814.drawio.png"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2024-03-04T07:59:24.000Z"}],["meta",{"name":"twitter:card","content":"summary_large_image"}],["meta",{"name":"twitter:image:alt","content":"都是同样条件的 mysql select 语句，为什么读到的内容却不一样？"}],["meta",{"property":"article:author","content":"小白debug"}],["meta",{"property":"article:modified_time","content":"2024-03-04T07:59:24.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"都是同样条件的 mysql select 语句，为什么读到的内容却不一样？\\",\\"image\\":[\\"https://cdn.xiaobaidebug.top/image/user%E8%A1%A8%E6%95%B0%E6%8D%AE%E5%BA%93%E5%8E%9F%E5%A7%8B%E7%8A%B6%E6%80%814.drawio.png\\",\\"https://cdn.xiaobaidebug.top/image/%E9%83%BD%E6%98%AFselect%E7%BB%93%E6%9E%9C%E5%8D%B4%E4%B8%8D%E5%90%8C1.drawio.png\\",\\"https://cdn.xiaobaidebug.top/image/ACID.png\\",\\"https://cdn.xiaobaidebug.top/image/undo%E6%97%A5%E5%BF%97%E4%BC%9A%E8%AE%B0%E5%BD%95%E4%B9%8B%E5%89%8D%E7%9A%84%E6%95%B0%E6%8D%AE.drawio.png\\",\\"https://cdn.xiaobaidebug.top/image/undo%E6%97%A5%E5%BF%97%E7%89%88%E6%9C%AC%E9%93%BE.png\\",\\"https://cdn.xiaobaidebug.top/image/%E5%BD%93%E5%89%8D%E8%AF%BB%E5%92%8C%E5%BF%AB%E7%85%A7%E8%AF%BB.drawio.png\\",\\"https://cdn.xiaobaidebug.top/image/readview2.drawio.png\\",\\"https://cdn.xiaobaidebug.top/image/readview%E4%B8%8Eundo%E7%89%88%E6%9C%AC%E9%93%BE3.drawio.png\\",\\"https://cdn.xiaobaidebug.top/image/MVCC.png\\",\\"https://cdn.xiaobaidebug.top/image/四层隔离级别.png\\",\\"https://cdn.xiaobaidebug.top/image/user表数据库原始状态4.drawio.png\\",\\"https://cdn.xiaobaidebug.top/image/user%E8%A1%A8%E6%95%B0%E6%8D%AE%E5%BA%93%E5%8E%9F%E5%A7%8Btrx%E4%BF%A1%E6%81%AF.drawio.png\\",\\"https://cdn.xiaobaidebug.top/image/都是select结果却不同1.drawio.png\\",\\"https://cdn.xiaobaidebug.top/image/%E4%BA%8B%E5%8A%A11%E7%9A%84readview.drawio.png\\",\\"https://cdn.xiaobaidebug.top/image/user%E8%A1%A8%E6%95%B0%E6%8D%AE%E5%BA%93%E5%8A%A0%E5%85%A5undo%E6%97%A5%E5%BF%97.drawio.png\\",\\"https://cdn.xiaobaidebug.top/image/u=2281575747,3550568508&fm=253&fmt=auto&app=120&f=JPEG.jpeg\\",\\"https://cdn.xiaobaidebug.top/1696069689495.png\\",\\"https://cdn.xiaobaidebug.top/image/006APoFYly1g5q9gn2jipg308w08wqdi.gif\\"],\\"dateModified\\":\\"2024-03-04T07:59:24.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"小白debug\\",\\"url\\":\\"https://xiaobaidebug.top/\\"}]}"],["link",{"rel":"canonical","href":"https://golangguide.top/%E4%B8%AD%E9%97%B4%E4%BB%B6/mysql/%E6%A0%B8%E5%BF%83%E7%9F%A5%E8%AF%86%E7%82%B9/%E9%83%BD%E6%98%AFselect%E8%AF%AD%E5%8F%A5%EF%BC%8C%E4%B8%BA%E4%BB%80%E4%B9%88%E8%AF%BB%E5%88%B0%E7%9A%84%E5%86%85%E5%AE%B9%E4%B8%8D%E4%B8%80%E6%A0%B7%EF%BC%9F.html"}],["meta",{"property":"og:url","content":"https://golangguide.top/%E4%B8%AD%E9%97%B4%E4%BB%B6/mysql/%E6%A0%B8%E5%BF%83%E7%9F%A5%E8%AF%86%E7%82%B9/%E9%83%BD%E6%98%AFselect%E8%AF%AD%E5%8F%A5%EF%BC%8C%E4%B8%BA%E4%BB%80%E4%B9%88%E8%AF%BB%E5%88%B0%E7%9A%84%E5%86%85%E5%AE%B9%E4%B8%8D%E4%B8%80%E6%A0%B7%EF%BC%9F.html"}],["meta",{"property":"og:site_name","content":"golang全栈指南"}],["meta",{"property":"og:title","content":"都是同样条件的 mysql select 语句，为什么读到的内容却不一样？"}],["meta",{"property":"og:description","content":"都是同样条件的 mysql select 语句，为什么读到的内容却不一样？ 假设当前数据库里有下面这张表。 user表数据库原始状态user表数据库原始状态 老规矩，以下内容还是默认发生在 innodb 引擎的可重复读隔离级别下。 都是select结果却不同都是select结果却不同 大家可以看到，线程 1，同样都是读 age >= 3 的数据。第一次..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2024-03-04T07:59:24.000Z"}],["meta",{"property":"article:modified_time","content":"2024-03-04T07:59:24.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"都是同样条件的 mysql select 语句，为什么读到的内容却不一样？\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2024-03-04T07:59:24.000Z\\",\\"author\\":[]}"]]},"headers":[{"level":2,"title":"事务的回滚是怎么实现的","slug":"事务的回滚是怎么实现的","link":"#事务的回滚是怎么实现的","children":[]},{"level":2,"title":"当前读和快照读是什么","slug":"当前读和快照读是什么","link":"#当前读和快照读是什么","children":[]},{"level":2,"title":"read view","slug":"read-view","link":"#read-view","children":[{"level":3,"title":"事务能读哪些快照","slug":"事务能读哪些快照","link":"#事务能读哪些快照","children":[]},{"level":3,"title":"事务会读哪个快照","slug":"事务会读哪个快照","link":"#事务会读哪个快照","children":[]},{"level":3,"title":"MVCC 是什么","slug":"mvcc-是什么","link":"#mvcc-是什么","children":[]}]},{"level":2,"title":"四个隔离级别是怎么实现的","slug":"四个隔离级别是怎么实现的","link":"#四个隔离级别是怎么实现的","children":[]},{"level":2,"title":"再看文章开头的例子","slug":"再看文章开头的例子","link":"#再看文章开头的例子","children":[]},{"level":2,"title":"总结","slug":"总结","link":"#总结","children":[]},{"level":2,"title":"最后","slug":"最后","link":"#最后","children":[]},{"level":2,"title":"文章推荐：","slug":"文章推荐","link":"#文章推荐","children":[]}],"git":{"createdTime":1708315055000,"updatedTime":1709539164000,"contributors":[{"name":"xiaobai","email":"xiaobaidebug@gmail.com","commits":2}]},"readingTime":{"minutes":14.8,"words":4440},"filePathRelative":"中间件/mysql/核心知识点/都是select语句，为什么读到的内容不一样？.md","localizedDate":"2024年2月19日","autoDesc":true}');export{f as comp,_ as data};
