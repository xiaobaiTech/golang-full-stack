import{_ as i}from"./plugin-vue_export-helper-DlAUqK2U.js";import{r as p,o,c as l,a as s,b as a,d as n,e as t}from"./app-BVNinm5e.js";const r={},d=t(`<h1 id="mysql-查询-limit-1000-10-和-limit-10-速度一样快吗-如果我要分页-我该怎么办" tabindex="-1"><a class="header-anchor" href="#mysql-查询-limit-1000-10-和-limit-10-速度一样快吗-如果我要分页-我该怎么办"><span>mysql 查询 limit 1000,10 和 limit 10 速度一样快吗？如果我要分页，我该怎么办？</span></a></h1><br><p>刷网站的时候，我们经常会遇到需要分页查询的场景。</p><p>比如下图红框里的翻页功能。</p><img src="https://cdn.xiaobaidebug.top/image-20220603221954745.png" style="zoom:50%;"><br><p>我们很容易能联想到可以用 mysql 实现。</p><p>假设我们的建表 sql 是这样的</p><figure><img src="https://cdn.xiaobaidebug.top/image/mysql建表sql5.png" alt="mysql建表sql" tabindex="0" loading="lazy"><figcaption>mysql建表sql</figcaption></figure><br><p>建表 sql 大家也不用扣细节，只需要知道<strong>id 是主键，并且在 user_name 建了个非主键索引</strong>就够了，其他都不重要。</p><p>为了实现分页。</p><p>很容易联想到下面这样的 sql 语句。</p><div class="language-sql line-numbers-mode" data-ext="sql" data-title="sql"><pre class="language-sql"><code><span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> page <span class="token keyword">order</span> <span class="token keyword">by</span> id <span class="token keyword">limit</span> <span class="token keyword">offset</span><span class="token punctuation">,</span> size<span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>比如一页有 10 条数据。</p><figure><img src="https://cdn.xiaobaidebug.top/image/user表数据库原始状态6.drawio.png" alt="user表数据库原始状态" tabindex="0" loading="lazy"><figcaption>user表数据库原始状态</figcaption></figure><p>第一页就是下面这样的 sql 语句。</p><div class="language-sql line-numbers-mode" data-ext="sql" data-title="sql"><pre class="language-sql"><code><span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> page <span class="token keyword">order</span> <span class="token keyword">by</span> id <span class="token keyword">limit</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>第一百页就是</p><div class="language-sql line-numbers-mode" data-ext="sql" data-title="sql"><pre class="language-sql"><code><span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> page <span class="token keyword">order</span> <span class="token keyword">by</span> id <span class="token keyword">limit</span> <span class="token number">990</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><br><p>那么问题来了。</p><p>用这种方式，<strong>同样都是拿 10 条数据，查第一页和第一百页的查询速度是一样的吗？为什么？</strong></p><br><h2 id="两种-limit-的执行过程" tabindex="-1"><a class="header-anchor" href="#两种-limit-的执行过程"><span>两种 limit 的执行过程</span></a></h2><p>上面的两种查询方式。对应 <code>limit offset, size</code> 和 <code>limit size</code> 两种方式。</p><p>而其实 <code>limit size</code> ，相当于 <code>limit 0, size</code>。也就是从 0 开始取 size 条数据。</p><p>也就是说，两种方式的<strong>区别在于 offset 是否为 0。</strong></p><p>我们先来看下 limit sql 的内部执行逻辑。</p><figure><img src="https://cdn.xiaobaidebug.top/image/Mysql架构6.drawio.png" alt="Mysql架构" tabindex="0" loading="lazy"><figcaption>Mysql架构</figcaption></figure><p>mysql 内部分为<strong>server 层</strong>和<strong>存储引擎层</strong>。一般情况下存储引擎都用 innodb。</p><p>server 层有很多模块，其中需要关注的是<strong>执行器</strong>是用于跟存储引擎打交道的组件。</p><p>执行器可以通过调用存储引擎提供的接口，将一行行数据取出，当这些数据完全符合要求（比如满足其他 where 条件），则会放到<strong>结果集</strong>中，最后返回给调用 mysql 的<strong>客户端（go、java 写的应用程序）</strong>。</p><br><p>我们可以对下面的 sql 先执行下 <code>explain</code>。</p><div class="language-sql line-numbers-mode" data-ext="sql" data-title="sql"><pre class="language-sql"><code><span class="token keyword">explain</span> <span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> page <span class="token keyword">order</span> <span class="token keyword">by</span> id <span class="token keyword">limit</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>可以看到，explain 中提示 key 那里，执行的是<strong>PRIMARY</strong>，也就是走的<strong>主键索引</strong>。</p><figure><img src="https://cdn.xiaobaidebug.top/image/分页查询offset=0.png" alt="分页查询offset=0" tabindex="0" loading="lazy"><figcaption>分页查询offset=0</figcaption></figure><p>主键索引本质是一棵 B+树，它是放在 innodb 中的一个数据结构。</p><p>我们可以回忆下，B+树大概长这样。</p><figure><img src="https://cdn.xiaobaidebug.top/B加树结构2d.png" alt="B+树结构" tabindex="0" loading="lazy"><figcaption>B+树结构</figcaption></figure><p>在这个树状结构里，我们需要关注的是，最下面一层节点，也就是<strong>叶子结点</strong>。而这个叶子结点里放的信息会根据当前的索引是<strong>主键还是非主键</strong>有所不同。</p><ul><li>如果是<strong>主键索引</strong>，它的叶子节点会存放完整的行数据信息。</li><li>如果是<strong>非主键索引</strong>，那它的叶子节点则会存放主键，如果想获得行数据信息，则需要再跑到主键索引去拿一次数据，这叫<strong>回表</strong>。</li></ul><p>比如执行</p><div class="language-sql line-numbers-mode" data-ext="sql" data-title="sql"><pre class="language-sql"><code><span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> page <span class="token keyword">where</span> user_name <span class="token operator">=</span> <span class="token string">&quot;小白10&quot;</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>会通过非主键索引去查询<strong>user_name</strong>为&quot;<strong>小白 10</strong>&quot;的数据，然后在叶子结点里找到&quot;<strong>小白 10</strong>&quot;的数据对应的<strong>主键为 10</strong>。</p><p>此时回表到<strong>主键索引</strong>中做查询，最后定位到<strong>主键为 10 的行数据</strong>。</p><figure><img src="https://cdn.xiaobaidebug.top/image/回表.drawio.png" alt="回表" tabindex="0" loading="lazy"><figcaption>回表</figcaption></figure><p>但不管是主键还是非主键索引，他们的叶子结点数据都是<strong>有序的</strong>。比如在主键索引中，这些数据是根据主键 id 的大小，从小到大，进行排序的。</p><br><h3 id="基于主键索引的-limit-执行过程" tabindex="-1"><a class="header-anchor" href="#基于主键索引的-limit-执行过程"><span>基于主键索引的 limit 执行过程</span></a></h3><p>那么回到文章开头的问题里。</p><p>当我们去掉 explain，执行这条 sql。</p><div class="language-sql line-numbers-mode" data-ext="sql" data-title="sql"><pre class="language-sql"><code><span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> page <span class="token keyword">order</span> <span class="token keyword">by</span> id <span class="token keyword">limit</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>上面 select 后面带的是<strong>星号*</strong>，也就是要求获得行数据的<strong>所有字段信息。</strong></p><p>server 层会调用 innodb 的接口，在 innodb 里的主键索引中获取到第 0 到 10 条<strong>完整行数据</strong>，依次返回给 server 层，并放到 server 层的结果集中，返回给客户端。</p><p>而当我们把 offset 搞离谱点，比如执行的是</p><div class="language-sql line-numbers-mode" data-ext="sql" data-title="sql"><pre class="language-sql"><code><span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> page <span class="token keyword">order</span> <span class="token keyword">by</span> id <span class="token keyword">limit</span> <span class="token number">6000000</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>server 层会调用 innodb 的接口，由于这次的 offset=6000000，会在 innodb 里的主键索引中获取到第 0 到（6000000 + 10）条<strong>完整行数据</strong>，<strong>返回给 server 层之后根据 offset 的值挨个抛弃，最后只留下最后面的 size 条</strong>，也就是 10 条数据，放到 server 层的结果集中，返回给客户端。</p><p>可以看出，当 offset 非 0 时，server 层会从引擎层获取到<strong>很多无用的数据</strong>，而获取的这些无用数据都是要耗时的。</p><p>因此，我们就知道了文章开头的问题的答案，<strong>mysql 查询中 limit 1000,10 会比 limit 10 更慢。原因是 limit 1000,10 会取出 1000+10 条数据，并抛弃前 1000 条，这部分耗时更大</strong></p><br><p><strong>那这种 case 有办法优化吗？</strong></p><p>可以看出，当 offset 非 0 时，server 层会从引擎层获取到很多无用的数据，而当 select 后面是*号时，就需要拷贝完整的行信息，<strong>拷贝完整数据</strong>跟<strong>只拷贝行数据里的其中一两个列字段</strong>耗时是不同的，这就让原本就耗时的操作变得更加离谱。</p><p>因为前面的 offset 条数据最后都是不要的，就算将完整字段都拷贝来了又有什么用呢，所以我们可以将 sql 语句修改成下面这样。</p><div class="language-sql line-numbers-mode" data-ext="sql" data-title="sql"><pre class="language-sql"><code><span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> page  <span class="token keyword">where</span> id <span class="token operator">&gt;=</span><span class="token punctuation">(</span><span class="token keyword">select</span> id <span class="token keyword">from</span> page  <span class="token keyword">order</span> <span class="token keyword">by</span> id <span class="token keyword">limit</span> <span class="token number">6000000</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token keyword">order</span> <span class="token keyword">by</span> id <span class="token keyword">limit</span> <span class="token number">10</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>上面这条 sql 语句，里面先执行子查询 <code>select id from page order by id limit 6000000, 1</code>, 这个操作，其实也是将在 innodb 中的主键索引中获取到<code>6000000+1</code>条数据，然后 server 层会抛弃前 6000000 条，只保留最后一条数据的 id。</p><p>但不同的地方在于，在返回 server 层的过程中，只会拷贝数据行内的 id 这一列，而不会拷贝数据行的所有列，当数据量较大时，这部分的耗时还是比较明显的。</p><p>在拿到了上面的 id 之后，假设这个 id 正好等于 6000000，那 sql 就变成了</p><div class="language-sql line-numbers-mode" data-ext="sql" data-title="sql"><pre class="language-sql"><code><span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> page  <span class="token keyword">where</span> id <span class="token operator">&gt;=</span><span class="token punctuation">(</span><span class="token number">6000000</span><span class="token punctuation">)</span> <span class="token keyword">order</span> <span class="token keyword">by</span> id <span class="token keyword">limit</span> <span class="token number">10</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>这样 innodb 再走一次<strong>主键索引</strong>，通过 B+树快速定位到 id=6000000 的行数据，时间复杂度是 lg(n)，然后向后取 10 条数据。</p><p>这样性能确实是提升了，亲测能快一倍左右，属于那种耗时从 3s 变成 1.5s 的操作。</p><p>这······</p><p>属实有些杯水车薪，有点搓，属于没办法中的办法。</p><br><h3 id="基于非主键索引的-limit-执行过程" tabindex="-1"><a class="header-anchor" href="#基于非主键索引的-limit-执行过程"><span>基于非主键索引的 limit 执行过程</span></a></h3><p>上面提到的是主键索引的执行过程，我们再来看下基于<strong>非主键索引</strong>的 limit 执行过程。</p><p>比如下面的 sql 语句</p><div class="language-sql line-numbers-mode" data-ext="sql" data-title="sql"><pre class="language-sql"><code><span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> page <span class="token keyword">order</span> <span class="token keyword">by</span> user_name  <span class="token keyword">limit</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>server 层会调用 innodb 的接口，在 innodb 里的非主键索引中获取到第 0 条数据对应的主键 id 后，<strong>回表</strong>到主键索引中找到对应的完整行数据，然后返回给 server 层，server 层将其放到结果集中，返回给客户端。</p><p>而当 offset&gt;0 时，且 offset 的值较小时，逻辑也类似，区别在于，offset&gt;0 时会丢弃前面的 offset 条数据。</p><p>也就是说<strong>非主键索引的 limit 过程，比主键索引的 limit 过程，多了个回表的消耗。</strong></p><p>但当 offset 变得非常大时，比如 600 万，此时执行 explain。</p><figure><img src="https://cdn.xiaobaidebug.top/image/非主键索引offset值超大时走全表扫描.png" alt="非主键索引offset值超大时走全表扫描" tabindex="0" loading="lazy"><figcaption>非主键索引offset值超大时走全表扫描</figcaption></figure><p>可以看到 type 那一栏显示的是 ALL，也就是<strong>全表扫描</strong>。</p><p>这是因为 server 层的<strong>优化器</strong>，会在执行器执行 sql 语句前，判断下哪种执行计划的代价更小。</p><p>很明显，优化器在看到非主键索引的 600w 次回表之后，摇了摇头，还不如全表一条条记录去判断算了，于是选择了全表扫描。</p><p>因此，<strong>当 limit offset 过大时，非主键索引查询非常容易变成全表扫描。是真·性能杀手</strong>。</p><br><p>这种情况也能通过一些方式去优化。比如</p><div class="language-sql line-numbers-mode" data-ext="sql" data-title="sql"><pre class="language-sql"><code><span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> page t1<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token keyword">select</span> id <span class="token keyword">from</span> page <span class="token keyword">order</span> <span class="token keyword">by</span> user_name <span class="token keyword">limit</span> <span class="token number">6000000</span><span class="token punctuation">,</span> <span class="token number">100</span><span class="token punctuation">)</span> t2  <span class="token keyword">WHERE</span> t1<span class="token punctuation">.</span>id <span class="token operator">=</span> t2<span class="token punctuation">.</span>id<span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>通过<code>select id from page order by user_name limit 6000000, 100</code>。 先走 innodb 层的 user_name 非主键索引取出 id，因为只拿主键 id，<strong>不需要回表</strong>，所以这块性能会稍微快点，在返回 server 层之后，同样抛弃前 600w 条数据，保留最后的 100 个 id。然后再用这 100 个 id 去跟 t1 表做 id 匹配，此时走的是主键索引，将匹配到的 100 条行数据返回。这样就绕开了之前的 600w 条数据的回表。</p><p>当然，跟上面的 case 一样，还是没有解决要白拿 600w 条数据然后抛弃的问题，这也是非常挫的优化。</p><br><p>像这种，当 offset 变得超大时，比如到了百万千万的量级，问题就突然变得严肃了。</p><p>这里就产生了个专门的术语，叫<strong>深度分页</strong>。</p><br><h2 id="深度分页问题" tabindex="-1"><a class="header-anchor" href="#深度分页问题"><span>深度分页问题</span></a></h2><p>深度分页问题，是个很恶心的问题，恶心就恶心在，这个问题，它其实<strong>无解</strong>。</p><p>不管你是用 mysql 还是 es，你都只能通过一些手段去&quot;减缓&quot;问题的严重性。</p><p>遇到这个问题，我们就该回过头来想想。</p><p>为什么我们的代码会产生深度分页问题？</p><p><strong>它背后的原始需求是什么</strong>，我们可以根据这个做一些规避。</p><br><h3 id="如果你是想取出全表的数据" tabindex="-1"><a class="header-anchor" href="#如果你是想取出全表的数据"><span>如果你是想取出全表的数据</span></a></h3><p>有些需求是这样的，我们有一张数据库表，但我们希望将这个数据库表里的所有数据取出，异构到 es，或者 hive 里，这时候如果直接执行</p><div class="language-sql line-numbers-mode" data-ext="sql" data-title="sql"><pre class="language-sql"><code><span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> page<span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>这个 sql 一执行，狗看了都摇头。</p><p>因为数据量较大，mysql 根本没办法一次性获取到全部数据，妥妥<strong>超时报错</strong>。</p><p>于是不少 mysql 小白会通过<code>limit offset size</code>分页的形式去分批获取，刚开始都是好的，等慢慢地，哪天数据表变得奇大无比，就有可能出现前面提到的<strong>深度分页</strong>问题。</p><p>这种场景是最好解决的。</p><p>我们可以将所有的数据<strong>根据 id 主键进行排序</strong>，然后分批次取，将当前批次的最大 id 作为下次筛选的条件进行查询。</p><p>可以看下伪代码</p><figure><img src="https://cdn.xiaobaidebug.top/image/batch获取数据.png" alt="batch获取数据" tabindex="0" loading="lazy"><figcaption>batch获取数据</figcaption></figure><p>这个操作，可以通过主键索引，每次定位到 id 在哪，然后往后遍历 100 个数据，这样不管是多少万的数据，查询性能都很稳定。</p><figure><img src="https://cdn.xiaobaidebug.top/image/batch分批获取user表.drawio.png" alt="batch分批获取user表" tabindex="0" loading="lazy"><figcaption>batch分批获取user表</figcaption></figure><br><h3 id="如果是给用户做分页展示" tabindex="-1"><a class="header-anchor" href="#如果是给用户做分页展示"><span>如果是给用户做分页展示</span></a></h3><p>如果深度分页背后的原始需求只是产品经理希望做一个展示页的功能，比如商品展示页，那么我们就应该好好跟产品经理 battle 一下了。</p><p>什么样的翻页，需要翻到 10 多万以后，这明显是不合理的需求。</p><p>是不是可以改一下需求，让它更接近用户的使用行为？</p><p>比如，我们在使用谷歌搜索时看到的翻页功能。</p><figure><img src="https://cdn.xiaobaidebug.top/image/image-20220502222159101.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>一般来说，谷歌搜索基本上都在 20 页以内，作为一个用户，我就很少会翻到第 10 页之后。</p><p>作为参考。</p><p>如果我们要做搜索或筛选类的页面的话，就别用 mysql 了，用 es，并且也需要控制展示的结果数，比如一万以内，这样不至于让分页过深。</p><p>如果因为各种原因，必须使用 mysql。那同样，也需要控制下返回结果数量，比如数量 1k 以内。</p><p>这样就能勉强支持各种翻页，跳页（比如突然跳到第 6 页然后再跳到第 106 页）。</p><br><p>但如果能从产品的形式上就做成不支持跳页会更好，比如<strong>只支持上一页或下一页</strong>。</p><figure><img src="https://cdn.xiaobaidebug.top/image/上下页的形式.drawio.png" alt="上下页的形式" tabindex="0" loading="lazy"><figcaption>上下页的形式</figcaption></figure><p>这样我们就可以使用上面提到的 start_id 方式，采用分批获取，每批数据以 start_id 为起始位置。这个解法最大的好处是不管翻到多少页，查询速度永远稳定。</p><p>听起来很挫？</p><p>怎么会呢，把这个功能包装一下。</p><p>变成像抖音那样只能上划或下划，专业点，叫<strong>瀑布流</strong>。</p><p>是不是就不挫了？</p><figure><img src="https://cdn.xiaobaidebug.top/image/image-20220503134616713.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><br><h2 id="总结" tabindex="-1"><a class="header-anchor" href="#总结"><span>总结</span></a></h2><ul><li><p><code>limit offset, size</code> 比 <code>limit size</code> 要慢，且 offset 的值越大，sql 的执行速度越慢。</p></li><li><p>当 offset 过大，会引发<strong>深度分页</strong>问题，目前不管是 mysql 还是 es 都没有很好的方法去解决这个问题。只能通过限制查询数量或分批获取的方式进行规避。</p></li><li><p>遇到深度分页的问题，多思考其原始需求，大部分时候是不应该出现深度分页的场景的，必要时多去影响产品经理。</p></li><li><p>如果数据量很少，比如 1k 的量级，且长期不太可能有巨大的增长，还是用<code>limit offset, size</code> 的方案吧，整挺好，能用就行。</p></li></ul><br><h2 id="参考资料" tabindex="-1"><a class="header-anchor" href="#参考资料"><span>参考资料</span></a></h2>`,142),c={href:"https://blog.csdn.net/qq_34115899/article/details/120727513",target:"_blank",rel:"noopener noreferrer"},g=t('<br><h2 id="最后" tabindex="-1"><a class="header-anchor" href="#最后"><span>最后</span></a></h2><p>关于深度分页，如果大家有更好的想法，欢迎评论区说出来。</p><p>这道题，是我无能！</p><p><strong>告辞！！</strong></p><br><p>最近原创更文的阅读量稳步下跌，思前想后，夜里辗转反侧。</p><p>我有个不成熟的请求。</p><figure><img src="https://cdn.xiaobaidebug.top/image/u=2281575747,3550568508&amp;fm=253&amp;fmt=auto&amp;app=120&amp;f=JPEG.jpeg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><br><p><strong>离开广东好长时间了，好久没人叫我靓仔了。</strong></p><p>大家可以在<strong>评论区</strong>里，叫我一靓仔吗？</p><p>我这么善良质朴的愿望，能被满足吗？</p><p>如果实在叫不出口的话，能帮我点下右下角的<strong>点赞和在看</strong>吗？</p><br><h5 id="别说了-一起在知识的海洋里呛水吧" tabindex="-1"><a class="header-anchor" href="#别说了-一起在知识的海洋里呛水吧"><span>别说了，一起在知识的海洋里呛水吧</span></a></h5><p><strong>点击</strong>下方名片，关注公众号:【小白 debug】<br><img src="https://cdn.xiaobaidebug.top/1696069689495.png" alt="" loading="lazy"></p><br><p>不满足于在留言区说骚话？</p><p>加我，我们建了个划水吹牛皮群，在群里，你可以跟你下次跳槽可能遇到的同事或面试官聊点有意思的话题。就<strong>超！开！心！</strong></p><img src="https://cdn.xiaobaidebug.top/image-20220522162616202.png" width="50%" align="center"><figure><img src="https://cdn.xiaobaidebug.top/image/006APoFYly1g5q9gn2jipg308w08wqdi.gif" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><h2 id="文章推荐" tabindex="-1"><a class="header-anchor" href="#文章推荐"><span>文章推荐：</span></a></h2>',23),m={href:"https://mp.weixin.qq.com/s/PP80aD-GQp7VtgyfHj392g",target:"_blank",rel:"noopener noreferrer"},u={href:"https://mp.weixin.qq.com/s/0-YBxU1cSbDdzcZEZjmQYA",target:"_blank",rel:"noopener noreferrer"},k={href:"https://mp.weixin.qq.com/s/YpQGsRyyrGNDu1cOuMy83w",target:"_blank",rel:"noopener noreferrer"};function b(y,f){const e=p("ExternalLinkIcon");return o(),l("div",null,[d,s("p",null,[a("《MySQL 的 Limit 子句底层原理你不可不知》"),s("a",c,[a("https://blog.csdn.net/qq_34115899/article/details/120727513"),n(e)])]),g,s("ul",null,[s("li",null,[s("a",m,[a("程序员防猝死指南"),n(e)])]),s("li",null,[s("a",u,[a("TCP 粘包 数据包：我只是犯了每个数据包都会犯的错 |硬核图解"),n(e)])]),s("li",null,[s("a",k,[a("动图图解！既然 IP 层会分片，为什么 TCP 层也还要分段？"),n(e)])])])])}const E=i(r,[["render",b],["__file","mysql查询 limit 1000_10 和limit 10 速度一样快吗？.html.vue"]]),v=JSON.parse('{"path":"/%E4%B8%AD%E9%97%B4%E4%BB%B6/mysql/%E6%A0%B8%E5%BF%83%E7%9F%A5%E8%AF%86%E7%82%B9/mysql%E6%9F%A5%E8%AF%A2%20limit%201000_10%20%E5%92%8Climit%2010%20%E9%80%9F%E5%BA%A6%E4%B8%80%E6%A0%B7%E5%BF%AB%E5%90%97%EF%BC%9F.html","title":"mysql 查询 limit 1000,10 和 limit 10 速度一样快吗？如果我要分页，我该怎么办？","lang":"zh-CN","frontmatter":{"description":"mysql 查询 limit 1000,10 和 limit 10 速度一样快吗？如果我要分页，我该怎么办？ 刷网站的时候，我们经常会遇到需要分页查询的场景。 比如下图红框里的翻页功能。 我们很容易能联想到可以用 mysql 实现。 假设我们的建表 sql 是这样的 mysql建表sqlmysql建表sql 建表 sql 大家也不用扣细节，只需要知道i...","head":[["meta",{"property":"og:url","content":"https://golangguide.top/%E4%B8%AD%E9%97%B4%E4%BB%B6/mysql/%E6%A0%B8%E5%BF%83%E7%9F%A5%E8%AF%86%E7%82%B9/mysql%E6%9F%A5%E8%AF%A2%20limit%201000_10%20%E5%92%8Climit%2010%20%E9%80%9F%E5%BA%A6%E4%B8%80%E6%A0%B7%E5%BF%AB%E5%90%97%EF%BC%9F.html"}],["meta",{"property":"og:site_name","content":"golang全栈指南"}],["meta",{"property":"og:title","content":"mysql 查询 limit 1000,10 和 limit 10 速度一样快吗？如果我要分页，我该怎么办？"}],["meta",{"property":"og:description","content":"mysql 查询 limit 1000,10 和 limit 10 速度一样快吗？如果我要分页，我该怎么办？ 刷网站的时候，我们经常会遇到需要分页查询的场景。 比如下图红框里的翻页功能。 我们很容易能联想到可以用 mysql 实现。 假设我们的建表 sql 是这样的 mysql建表sqlmysql建表sql 建表 sql 大家也不用扣细节，只需要知道i..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:image","content":"https://cdn.xiaobaidebug.top/image/mysql%E5%BB%BA%E8%A1%A8sql5.png"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2024-02-19T03:57:35.000Z"}],["meta",{"name":"twitter:card","content":"summary_large_image"}],["meta",{"name":"twitter:image:alt","content":"mysql 查询 limit 1000,10 和 limit 10 速度一样快吗？如果我要分页，我该怎么办？"}],["meta",{"property":"article:author","content":"小白debug"}],["meta",{"property":"article:modified_time","content":"2024-02-19T03:57:35.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"mysql 查询 limit 1000,10 和 limit 10 速度一样快吗？如果我要分页，我该怎么办？\\",\\"image\\":[\\"https://cdn.xiaobaidebug.top/image/mysql%E5%BB%BA%E8%A1%A8sql5.png\\",\\"https://cdn.xiaobaidebug.top/image/user%E8%A1%A8%E6%95%B0%E6%8D%AE%E5%BA%93%E5%8E%9F%E5%A7%8B%E7%8A%B6%E6%80%816.drawio.png\\",\\"https://cdn.xiaobaidebug.top/image/Mysql%E6%9E%B6%E6%9E%846.drawio.png\\",\\"https://cdn.xiaobaidebug.top/image/%E5%88%86%E9%A1%B5%E6%9F%A5%E8%AF%A2offset=0.png\\",\\"https://cdn.xiaobaidebug.top/B%E5%8A%A0%E6%A0%91%E7%BB%93%E6%9E%842d.png\\",\\"https://cdn.xiaobaidebug.top/image/%E5%9B%9E%E8%A1%A8.drawio.png\\",\\"https://cdn.xiaobaidebug.top/image/%E9%9D%9E%E4%B8%BB%E9%94%AE%E7%B4%A2%E5%BC%95offset%E5%80%BC%E8%B6%85%E5%A4%A7%E6%97%B6%E8%B5%B0%E5%85%A8%E8%A1%A8%E6%89%AB%E6%8F%8F.png\\",\\"https://cdn.xiaobaidebug.top/image/batch%E8%8E%B7%E5%8F%96%E6%95%B0%E6%8D%AE.png\\",\\"https://cdn.xiaobaidebug.top/image/batch分批获取user表.drawio.png\\",\\"https://cdn.xiaobaidebug.top/image/image-20220502222159101.png\\",\\"https://cdn.xiaobaidebug.top/image/%E4%B8%8A%E4%B8%8B%E9%A1%B5%E7%9A%84%E5%BD%A2%E5%BC%8F.drawio.png\\",\\"https://cdn.xiaobaidebug.top/image/image-20220503134616713.png\\",\\"https://cdn.xiaobaidebug.top/image/u=2281575747,3550568508&fm=253&fmt=auto&app=120&f=JPEG.jpeg\\",\\"https://cdn.xiaobaidebug.top/1696069689495.png\\",\\"https://cdn.xiaobaidebug.top/image/006APoFYly1g5q9gn2jipg308w08wqdi.gif\\"],\\"dateModified\\":\\"2024-02-19T03:57:35.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"小白debug\\",\\"url\\":\\"https://xiaobaidebug.top/\\"}]}"],["link",{"rel":"canonical","href":"https://golangguide.top/%E4%B8%AD%E9%97%B4%E4%BB%B6/mysql/%E6%A0%B8%E5%BF%83%E7%9F%A5%E8%AF%86%E7%82%B9/mysql%E6%9F%A5%E8%AF%A2%20limit%201000_10%20%E5%92%8Climit%2010%20%E9%80%9F%E5%BA%A6%E4%B8%80%E6%A0%B7%E5%BF%AB%E5%90%97%EF%BC%9F.html"}],["meta",{"property":"og:url","content":"https://golangguide.top/%E4%B8%AD%E9%97%B4%E4%BB%B6/mysql/%E6%A0%B8%E5%BF%83%E7%9F%A5%E8%AF%86%E7%82%B9/mysql%E6%9F%A5%E8%AF%A2%20limit%201000_10%20%E5%92%8Climit%2010%20%E9%80%9F%E5%BA%A6%E4%B8%80%E6%A0%B7%E5%BF%AB%E5%90%97%EF%BC%9F.html"}],["meta",{"property":"og:site_name","content":"golang全栈指南"}],["meta",{"property":"og:title","content":"mysql 查询 limit 1000,10 和 limit 10 速度一样快吗？如果我要分页，我该怎么办？"}],["meta",{"property":"og:description","content":"mysql 查询 limit 1000,10 和 limit 10 速度一样快吗？如果我要分页，我该怎么办？ 刷网站的时候，我们经常会遇到需要分页查询的场景。 比如下图红框里的翻页功能。 我们很容易能联想到可以用 mysql 实现。 假设我们的建表 sql 是这样的 mysql建表sqlmysql建表sql 建表 sql 大家也不用扣细节，只需要知道i..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2024-02-19T03:57:35.000Z"}],["meta",{"property":"article:modified_time","content":"2024-02-19T03:57:35.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"mysql 查询 limit 1000,10 和 limit 10 速度一样快吗？如果我要分页，我该怎么办？\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2024-02-19T03:57:35.000Z\\",\\"author\\":[]}"]]},"headers":[{"level":2,"title":"两种 limit 的执行过程","slug":"两种-limit-的执行过程","link":"#两种-limit-的执行过程","children":[{"level":3,"title":"基于主键索引的 limit 执行过程","slug":"基于主键索引的-limit-执行过程","link":"#基于主键索引的-limit-执行过程","children":[]},{"level":3,"title":"基于非主键索引的 limit 执行过程","slug":"基于非主键索引的-limit-执行过程","link":"#基于非主键索引的-limit-执行过程","children":[]}]},{"level":2,"title":"深度分页问题","slug":"深度分页问题","link":"#深度分页问题","children":[{"level":3,"title":"如果你是想取出全表的数据","slug":"如果你是想取出全表的数据","link":"#如果你是想取出全表的数据","children":[]},{"level":3,"title":"如果是给用户做分页展示","slug":"如果是给用户做分页展示","link":"#如果是给用户做分页展示","children":[]}]},{"level":2,"title":"总结","slug":"总结","link":"#总结","children":[]},{"level":2,"title":"参考资料","slug":"参考资料","link":"#参考资料","children":[]},{"level":2,"title":"最后","slug":"最后","link":"#最后","children":[]},{"level":2,"title":"文章推荐：","slug":"文章推荐","link":"#文章推荐","children":[]}],"git":{"createdTime":1708315055000,"updatedTime":1708315055000,"contributors":[{"name":"xiaobai","email":"xiaobaidebug@gmail.com","commits":1}]},"readingTime":{"minutes":12.76,"words":3827},"filePathRelative":"中间件/mysql/核心知识点/mysql查询 limit 1000,10 和limit 10 速度一样快吗？.md","localizedDate":"2024年2月19日","autoDesc":true}');export{E as comp,v as data};
