import{_ as o,c as a,a as s,b as t,d as n,e as r,r as g,o as p}from"./app-YFeEz-zg.js";const l={},d={href:"https://golangguide.top/golang/%E9%9D%A2%E8%AF%95%E9%A2%98/2.Go%E8%BF%9B%E9%98%B6.html",target:"_blank",rel:"noopener noreferrer"},c={href:"https://golangguide.top/golang/%E5%B8%B8%E7%94%A8%E5%8C%85%E5%A4%A7%E5%85%A8.html",target:"_blank",rel:"noopener noreferrer"},h={href:"https://golangguide.top/golang/%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF.html",target:"_blank",rel:"noopener noreferrer"},b={href:"https://www.photo-translate.top",target:"_blank",rel:"noopener noreferrer"};function u(m,e){const i=g("ExternalLinkIcon");return p(),a("div",null,[e[6]||(e[6]=s('<h1 id="redis-是什么-架构是怎么样的" tabindex="-1"><a class="header-anchor" href="#redis-是什么-架构是怎么样的"><span>Redis 是什么？架构是怎么样的？</span></a></h1><p>你是一个程序员，你维护了一个 商品服务，它背后直连 mysql 数据库。<br> 假设商品服务需要对外提供 每秒 1w 次查询，但背后的 mysql 却只能提供每秒 5k 次查询，那 mysql 根本顶不住！分分钟会被压垮。</p><figure><img src="https://cdn.xiaobaidebug.top/1732319412954.jpeg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>这类大流量查询场景非常常见，比如双十一秒杀和春节抢车票。<br> 那么问题就来了，有没有办法在 mysql 不被压垮的同时，让商品服务支持每秒 1w 次查询 ？<br> 当然有，<strong>没有什么是加一层中间层不能解决的，如果有，那就再加一层</strong>。<br> 这次我们要加的中间层是<strong>Redis</strong>。</p><figure><img src="https://cdn.xiaobaidebug.top/1732319425969.jpeg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><h2 id="本地缓存" tabindex="-1"><a class="header-anchor" href="#本地缓存"><span>本地缓存</span></a></h2><p>我们知道，查询内存的速度比查询磁盘要快， mysql 数据主要存放在磁盘里，如果能将 mysql 里的数据放内存里，查询完全不走磁盘，那必然能大大提升查询性能。</p><p>我们很容易想到，可以在商品服务的内存中，申请一个字典，在 python 里叫 dict，在 java 里叫 map。</p><figure><img src="https://cdn.xiaobaidebug.top/1732319472953.jpeg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>key 是商品 ID，value 是商品数据。 通过商品 ID, 就能查到商品数据。</p><figure><img src="https://cdn.xiaobaidebug.top/1732319458300.jpeg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>发生查询时，优先去查内存字典，没结果再跑到 mysql 数据库里查询，再将结果顺手放内存字典里，下次就又能从内存里查出来啦。</p><figure><img src="https://cdn.xiaobaidebug.top/1732319495696.jpeg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>像这样，放在服务内部的缓存，就是所谓的<strong>本地缓存</strong>。<br> 有了本地缓存的加持，真正打到 mysql 的查询量就跟你喜欢的女生回你的消息字数一样少，将查询请求干到 1w qps 是很轻松的事情。</p><figure><img src="https://cdn.xiaobaidebug.top/1732319526612.jpeg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><h2 id="远程缓存" tabindex="-1"><a class="header-anchor" href="#远程缓存"><span>远程缓存</span></a></h2><p>但问题又来了，为了保证系统高可用，商品服务经常不止一个实例，如果每个实例都重复缓存一份本地内存，那就有些浪费内存条了。<br> 所以更好的解决方案是将这部分<strong>字典内存</strong>抽出来，单独做成一个服务。它就是所谓的<strong>远程缓存服务</strong>。</p><figure><img src="https://cdn.xiaobaidebug.top/1732319564005.jpeg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>但这就引入另外一个问题，多个商品服务通过网络去读写同一份远程缓存，会存在并发问题。怎么办呢？<br> 很简单！对外不管有多少有个网络连接，收到读写命令后，都统一塞到<strong>一个线程</strong>上，在一个线程上对字典进行读写，什么<strong>并发问题</strong>和<strong>线程切换开销</strong>，完全不存在！</p><figure><img src="https://cdn.xiaobaidebug.top/1732319554438.jpeg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>这个远程缓存服务足以满足大部分场景，但它属实过于简陋，我们来看下怎么优化它。</p><h2 id="多种数据类型支持" tabindex="-1"><a class="header-anchor" href="#多种数据类型支持"><span>多种数据类型支持</span></a></h2><p>现在缓存服务里，只有一个字典类型。key 和 value 都是字符串。但我们平时写代码的时候，还会用到很多其他内存里的数据结构，是不是也可以在缓存服务里提供类似的数据结构？<br> 于是我们对字段的 value 进行扩展，除了 <strong>字符串</strong>, 还支持先进先出的队列 <strong>List</strong> 和用于去重的 <strong>Set</strong> 类型，再加入可以做排行榜的 <strong>ZSet</strong>，现在缓存服务就更强了。</p><figure><img src="https://cdn.xiaobaidebug.top/1732319600197.jpeg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><h2 id="内存过期策略" tabindex="-1"><a class="header-anchor" href="#内存过期策略"><span>内存过期策略</span></a></h2><p>缓存服务支持的数据结构变多了之后，塞到内存里的数据就越来越多了，内存又小又贵，迟早扛不住。<br> 怎么办呢？我们可以给缓存里的数据加个<strong>过期时间</strong>，一旦数据过期，就从内存里删掉，可以很大程度缓解掉内存增长速度。<br> 但问题又又来了，我怎么知道哪些数据该设置多长过期时间呢？<br> 完全没办法，只能交给调用方去做判断，让<strong>用户通过 expire 命令的形式来指定哪些数据多久过期</strong>。</p><h2 id="缓存淘汰" tabindex="-1"><a class="header-anchor" href="#缓存淘汰"><span>缓存淘汰</span></a></h2><p>但你不能指望每个调用方都是老实人，如果都不设置过期时间，那内存还是得炸。<br> 有解法吗？<br> 有！在内存接近上限的时候，根据<strong>一些策略</strong>删除掉一些内存。比如可以将最近最少使用的内存删掉，也就是所谓的 <strong>LRU</strong>,这样不仅解决了内存过大的问题，还让 redis 里的数据<strong>全是热点数据</strong>。真是一箭双雕。</p><figure><img src="https://cdn.xiaobaidebug.top/1732319627464.jpeg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><h2 id="持久化" tabindex="-1"><a class="header-anchor" href="#持久化"><span>持久化</span></a></h2><p>现在内存过大的问题是解决了。但还有个问题，mysql 之所以过得那么舒服，那是因为前面有个缓存服务挡住了大部分流量。<br> 一旦缓存服务<strong>重启</strong>，那内存就全丢了，这时候流量会全都打到 mysql 身上，疼得它嗷嗷叫。</p><figure><img src="https://cdn.xiaobaidebug.top/1732319654263.jpeg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>所以我们还需要给 redis 加入最大程度的持久化保证。确保服务重启后不至于什么数据都没有。<br> 于是可以在缓存服务里加个<strong>异步线程</strong>，定期将全量内存数据定期<strong>持久化到磁盘文件</strong>里，而这种将内存数据生成快照保存到文件的方式，就是所谓的 <strong>RDB</strong>，<strong>Redis Database Backup</strong>。</p><figure><img src="https://cdn.xiaobaidebug.top/1732319666949.jpeg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>它可以每隔几<strong>分钟</strong>记录下缓存服务 的全量数据，类似于游戏的&quot;存档&quot;。<br> 这样就算进程挂了，重启的时候，通过加载快照文件，就能复原大部分数据。<br> 之所以说是大部分，是因为&quot;存档&quot;之后写入的数据可能会丢。<br> 那还有其他方式可以保留更多数据吗？有！<br> 全量数据备份当然耗时，那我们化整为零，在每次写入数据时，顺手将数据记录到文件缓存中，并每<strong>秒</strong>将文件缓存刷入磁盘，这种持久化机制叫 <strong>AOF</strong>，<strong>Append Only File</strong>，服务启动时跟着文件重新执行一遍就能将大部分数据还原，最大程度保证了数据持久化。</p><figure><img src="https://cdn.xiaobaidebug.top/1732319683233.jpeg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>那问题就来了，AOF 文件会不会很大？没事，定期<strong>重写</strong>压缩就行，比如 a 被依次赋值 a=1，a=2，最终保留 a=2 就够了。</p><h2 id="简化网络协议" tabindex="-1"><a class="header-anchor" href="#简化网络协议"><span>简化网络协议</span></a></h2><p>刚刚提到远程缓存服务对外提供读写能力，那是对外提供的 HTTP 接口吗？<br> 当然不是！<br> 我们知道， HTTP 是基于 TCP 做的通信，实现了很多笨重的特性。<br> 既然当初是为了性能，特地上的缓存服务，那就索性彻底点，抛弃 HTTP，直接<strong>基于 TCP</strong> 做传输就好！传输协议也设计得简单点，比如只要通过 TCP 传入 SET key value，就能完成写入。传入&quot;GET key&quot; 就能获得对应的 value。非常简洁。<br> 那传输协议的解析需要我们自己写代码去实现吗？<br> 完全不需要，redis 官方提供了一个命令行工具，<strong>redis-cli</strong>，通过它，我们可以输入一些命令，读写 Redis 服务器里的各种内存数据。</p><figure><img src="https://cdn.xiaobaidebug.top/1732319744694.jpeg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>不想用命令行也没关系，各路大神已经用各种语言将 redis-cli 支持的命令实现了一遍，完全不需要自己手写。</p><h2 id="redis-是什么" tabindex="-1"><a class="header-anchor" href="#redis-是什么"><span>Redis 是什么？</span></a></h2><p>好了，到这里，当初那个简陋的远程缓存服务，就成了一个<strong>高性能</strong>，<strong>支持多种数据类型</strong>和各种<strong>缓存淘汰策略</strong>，并提供一定<strong>持久化</strong>能力的超强缓存服务，没错，它就是我们常说的 <strong>Redis</strong>，全称 <strong>Remote Dictionary Server</strong>，这名字就很精辟了，说白了 redis 就是个远程的字典服务。</p><figure><img src="https://cdn.xiaobaidebug.top/1732319839997.jpeg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>redis 作为架构中最常用的<strong>提速</strong>神器，是万金油一般的存在，将它放在 mysql 面前挡一道查询只是最基础的用法。<br> 通过扩展插件，还能实现各种高阶玩法。<br> 比如 <strong>RedisJSON</strong> 支持复杂的 JSON 查询和更新，说白了就是内存版本的 <strong>MongoDB</strong>。<br><strong>RediSearch</strong> 支持全文搜索，说白了就是内存丐版的 <strong>es</strong>。<br><strong>RedisGraph</strong> 支持图数据库功能，类似 <strong>Neo4j</strong>，<strong>RedisTimeSeries</strong> 处理时间序列数据，也就是内存版 <strong>InfluxDB</strong>。<br> 大有一种要在内存里将所有中间件都实现一遍的味道。</p><p>现在大家通了吗？</p><h2 id="总结" tabindex="-1"><a class="header-anchor" href="#总结"><span>总结</span></a></h2><ul><li>redis 本质上就是个远程字典服务，所有读写命令等核心逻辑，都在一个线程上完成。什么并发问题和线程切换开销，完全不存在！</li><li>redis 支持多种数据类型、内存过期策略和多种缓存失效策略，通过 TCP 对外提供了一套非常简单的传输协议。</li><li>redis 加入了最大程度的持久化保证。将数据持久化为 rdb 和 AOF,确保服务重启后不至于什么数据都没有。</li><li>redis 支持多种扩展，玩法非常多，比如 RediSearch 和 RedisJSON。</li></ul><p>最后遗留一个问题，redis 到目前为止就是个<strong>单机</strong>服务，<strong>高性能</strong>是有了，但<strong>高可用</strong>和<strong>可扩展性</strong>是一点没看到。<br> 这就需要聊聊 <strong>主从</strong> 、<strong>哨兵</strong>和<strong>集群</strong>模式了，如果大家感兴趣，下期我们聊聊这个话题。<br> 我们下期见！</p><h2 id="推荐阅读" tabindex="-1"><a class="header-anchor" href="#推荐阅读"><span>推荐阅读</span></a></h2>',50)),t("ul",null,[e[4]||(e[4]=t("li",null,[t("p",null,[t("a",{href:"/%E4%B8%AD%E9%97%B4%E4%BB%B6/redis/%E9%9D%A2%E8%AF%95%E9%A2%98"},"redis面试八股文")])],-1)),e[5]||(e[5]=t("li",null,[t("p",null,[t("a",{href:"/%E8%AE%AD%E7%BB%83%E8%90%A5/%E4%BB%8B%E7%BB%8D"},"还没有offer?专注【突击面试】的【go后端开发】训练营了解一下")])],-1)),t("li",null,[t("p",null,[t("a",d,[e[0]||(e[0]=n("golang进阶面试题八股文合集")),r(i)])])]),t("li",null,[t("p",null,[t("a",c,[e[1]||(e[1]=n("golang常用标准库第三方库大全")),r(i)])])]),t("li",null,[t("p",null,[t("a",h,[e[2]||(e[2]=n("golang学习路线")),r(i)])])]),t("li",null,[t("p",null,[t("a",b,[e[3]||(e[3]=n("基于golang实现的图片翻译工具")),r(i)])])])])])}const E=o(l,[["render",u],["__file","redis是什么.html.vue"]]),B=JSON.parse('{"path":"/%E4%B8%AD%E9%97%B4%E4%BB%B6/redis/%E6%A0%B8%E5%BF%83%E7%9F%A5%E8%AF%86%E7%82%B9/redis%E6%98%AF%E4%BB%80%E4%B9%88.html","title":"Redis 是什么？架构是怎么样的？","lang":"zh-CN","frontmatter":{"description":"Redis 是什么？架构是怎么样的？ 你是一个程序员，你维护了一个 商品服务，它背后直连 mysql 数据库。 假设商品服务需要对外提供 每秒 1w 次查询，但背后的 mysql 却只能提供每秒 5k 次查询，那 mysql 根本顶不住！分分钟会被压垮。 这类大流量查询场景非常常见，比如双十一秒杀和春节抢车票。 那么问题就来了，有没有办法在 mysql...","head":[["meta",{"property":"og:url","content":"https://golangguide.top/%E4%B8%AD%E9%97%B4%E4%BB%B6/redis/%E6%A0%B8%E5%BF%83%E7%9F%A5%E8%AF%86%E7%82%B9/redis%E6%98%AF%E4%BB%80%E4%B9%88.html"}],["meta",{"property":"og:site_name","content":"golang全栈指南"}],["meta",{"property":"og:title","content":"Redis 是什么？架构是怎么样的？"}],["meta",{"property":"og:description","content":"Redis 是什么？架构是怎么样的？ 你是一个程序员，你维护了一个 商品服务，它背后直连 mysql 数据库。 假设商品服务需要对外提供 每秒 1w 次查询，但背后的 mysql 却只能提供每秒 5k 次查询，那 mysql 根本顶不住！分分钟会被压垮。 这类大流量查询场景非常常见，比如双十一秒杀和春节抢车票。 那么问题就来了，有没有办法在 mysql..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:image","content":"https://cdn.xiaobaidebug.top/1732319412954.jpeg"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2024-11-23T00:28:54.000Z"}],["meta",{"name":"twitter:card","content":"summary_large_image"}],["meta",{"name":"twitter:image:alt","content":"Redis 是什么？架构是怎么样的？"}],["meta",{"property":"article:author","content":"小白debug"}],["meta",{"property":"article:modified_time","content":"2024-11-23T00:28:54.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"Redis 是什么？架构是怎么样的？\\",\\"image\\":[\\"https://cdn.xiaobaidebug.top/1732319412954.jpeg\\",\\"https://cdn.xiaobaidebug.top/1732319425969.jpeg\\",\\"https://cdn.xiaobaidebug.top/1732319472953.jpeg\\",\\"https://cdn.xiaobaidebug.top/1732319458300.jpeg\\",\\"https://cdn.xiaobaidebug.top/1732319495696.jpeg\\",\\"https://cdn.xiaobaidebug.top/1732319526612.jpeg\\",\\"https://cdn.xiaobaidebug.top/1732319564005.jpeg\\",\\"https://cdn.xiaobaidebug.top/1732319554438.jpeg\\",\\"https://cdn.xiaobaidebug.top/1732319600197.jpeg\\",\\"https://cdn.xiaobaidebug.top/1732319627464.jpeg\\",\\"https://cdn.xiaobaidebug.top/1732319654263.jpeg\\",\\"https://cdn.xiaobaidebug.top/1732319666949.jpeg\\",\\"https://cdn.xiaobaidebug.top/1732319683233.jpeg\\",\\"https://cdn.xiaobaidebug.top/1732319744694.jpeg\\",\\"https://cdn.xiaobaidebug.top/1732319839997.jpeg\\"],\\"dateModified\\":\\"2024-11-23T00:28:54.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"小白debug\\",\\"url\\":\\"https://xiaobaidebug.top/\\"}]}"],["link",{"rel":"canonical","href":"https://golangguide.top/%E4%B8%AD%E9%97%B4%E4%BB%B6/redis/%E6%A0%B8%E5%BF%83%E7%9F%A5%E8%AF%86%E7%82%B9/redis%E6%98%AF%E4%BB%80%E4%B9%88.html"}],["meta",{"property":"og:url","content":"https://golangguide.top/%E4%B8%AD%E9%97%B4%E4%BB%B6/redis/%E6%A0%B8%E5%BF%83%E7%9F%A5%E8%AF%86%E7%82%B9/redis%E6%98%AF%E4%BB%80%E4%B9%88.html"}],["meta",{"property":"og:site_name","content":"golang全栈指南"}],["meta",{"property":"og:title","content":"Redis 是什么？架构是怎么样的？"}],["meta",{"property":"og:description","content":"Redis 是什么？架构是怎么样的？ 你是一个程序员，你维护了一个 商品服务，它背后直连 mysql 数据库。 假设商品服务需要对外提供 每秒 1w 次查询，但背后的 mysql 却只能提供每秒 5k 次查询，那 mysql 根本顶不住！分分钟会被压垮。 这类大流量查询场景非常常见，比如双十一秒杀和春节抢车票。 那么问题就来了，有没有办法在 mysql..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2024-11-23T00:28:54.000Z"}],["meta",{"property":"article:modified_time","content":"2024-11-23T00:28:54.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"Redis 是什么？架构是怎么样的？\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2024-11-23T00:28:54.000Z\\",\\"author\\":[]}"]]},"headers":[{"level":2,"title":"本地缓存","slug":"本地缓存","link":"#本地缓存","children":[]},{"level":2,"title":"远程缓存","slug":"远程缓存","link":"#远程缓存","children":[]},{"level":2,"title":"多种数据类型支持","slug":"多种数据类型支持","link":"#多种数据类型支持","children":[]},{"level":2,"title":"内存过期策略","slug":"内存过期策略","link":"#内存过期策略","children":[]},{"level":2,"title":"缓存淘汰","slug":"缓存淘汰","link":"#缓存淘汰","children":[]},{"level":2,"title":"持久化","slug":"持久化","link":"#持久化","children":[]},{"level":2,"title":"简化网络协议","slug":"简化网络协议","link":"#简化网络协议","children":[]},{"level":2,"title":"Redis 是什么？","slug":"redis-是什么","link":"#redis-是什么","children":[]},{"level":2,"title":"总结","slug":"总结","link":"#总结","children":[]},{"level":2,"title":"推荐阅读","slug":"推荐阅读","link":"#推荐阅读","children":[]}],"git":{"createdTime":1732321734000,"updatedTime":1732321734000,"contributors":[{"name":"xiaobai-tech","email":"948485496@qq.com","commits":1}]},"readingTime":{"minutes":8.15,"words":2444},"filePathRelative":"中间件/redis/核心知识点/redis是什么.md","localizedDate":"2024年11月23日","autoDesc":true}');export{E as comp,B as data};
