import{_ as s}from"./plugin-vue_export-helper-DlAUqK2U.js";import{r as t,o,c as p,a as e,b as n,d as i,e as l}from"./app-COuI7B_u.js";const c={},r=e("figure",null,[e("img",{src:"https://cdn.xiaobaidebug.top/image/2021-2-19/1613693230446-默认文件1613437659307.png",alt:"",tabindex:"0",loading:"lazy"}),e("figcaption")],-1),d={href:"https://github.com/xiaobaiTech/golangFamily",target:"_blank",rel:"noopener noreferrer"},u=l(`<img src="https://cdn.xiaobaidebug.top/image/2021-2-14/1613317170976-不要打扰我学HTTP.jpg" style="zoom:100%;"><figure><img src="https://cdn.xiaobaidebug.top/image/2021-2-16/1613436372639-b站撸猫大图.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><h1 id="什么是-http" tabindex="-1"><a class="header-anchor" href="#什么是-http"><span>什么是 HTTP</span></a></h1><p>HTTP 全称<strong>超⽂文本传输协议</strong>，也就是<strong>H</strong>yper<strong>T</strong>ext <strong>T</strong>ransfer <strong>P</strong>rotocol。<br> 其中我们常见的<strong>文本，图片，视频</strong>这些东西都可以用超文本进行表示，而我常看的猫片，也属于超文本，所以大家不要再说我偷偷看猫片了，我只是在看超文本。HTTP 只是定义了一套传输超文本的规则，只要符合了这一套规则，不管你是用 iphone，还是用老爷机，都可以实现猫片的传输。</p><figure><img src="https://cdn.xiaobaidebug.top/image/2021-2-11/1613041437612-http传输示例漫画.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><h1 id="七层网络" tabindex="-1"><a class="header-anchor" href="#七层网络"><span>七层网络</span></a></h1><figure><img src="https://cdn.xiaobaidebug.top/image/2021-2-11/1613013885789-image.png" alt="网络协议" tabindex="0" loading="lazy"><figcaption>网络协议</figcaption></figure><p>大概了解了<strong>HTTP</strong>后，给大家看看它在它们家族里的地位。HTTP 位于<strong>应用层</strong>，跟它类似的协议还有常见的<strong>FTP 协议</strong>，常见的<strong>某影天堂</strong>的下载链接曾经经常是以<strong>FTP 开头</strong>的。</p><figure><img src="https://cdn.xiaobaidebug.top/image/2021-2-11/1613007117086-image.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><h1 id="http-报文格式" tabindex="-1"><a class="header-anchor" href="#http-报文格式"><span>HTTP 报文格式</span></a></h1><figure><img src="https://cdn.xiaobaidebug.top/image/2021-2-11/1613021710607-http报文解析.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><img src="https://cdn.xiaobaidebug.top/image/2021-2-11/1613041939151-image.png" style="zoom:100%;"><p>有点抽象？不知道小白说的啥？那实操一下，用<code>wireshark</code>抓包看一下猫片里的请求报文和响应报文具体长什么样子吧</p><h1 id="请求报文" tabindex="-1"><a class="header-anchor" href="#请求报文"><span>请求报文</span></a></h1><div class="language-http line-numbers-mode" data-ext="http" data-title="http"><pre class="language-http"><code><span class="token request-line"><span class="token method property">GET</span> <span class="token request-target url">/cmaskboss/164203142_30_1.enhance.webmask</span> <span class="token http-version property">HTTP/1.1</span></span>
<span class="token header"><span class="token header-name keyword">Host</span><span class="token punctuation">:</span> <span class="token header-value">upos-sz-staticks3.bilivideo.com</span></span>
<span class="token header"><span class="token header-name keyword">Connection</span><span class="token punctuation">:</span> <span class="token header-value">keep-alive</span></span>
<span class="token header"><span class="token header-name keyword">User-Agent</span><span class="token punctuation">:</span> <span class="token header-value">Mozilla/5.0 (Macintosh; Intel Mac OS X 10_14_3) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/88.0.4324.150 Safari/537.36</span></span>
<span class="token header"><span class="token header-name keyword">Accept</span><span class="token punctuation">:</span> <span class="token header-value">*/*</span></span>
<span class="token header"><span class="token header-name keyword">Origin</span><span class="token punctuation">:</span> <span class="token header-value">https://www.bilibili.com</span></span>
<span class="token header"><span class="token header-name keyword">Sec-Fetch-Site</span><span class="token punctuation">:</span> <span class="token header-value">cross-site</span></span>
<span class="token header"><span class="token header-name keyword">Sec-Fetch-Mode</span><span class="token punctuation">:</span> <span class="token header-value">cors</span></span>
<span class="token header"><span class="token header-name keyword">Sec-Fetch-Dest</span><span class="token punctuation">:</span> <span class="token header-value">empty</span></span>
<span class="token header"><span class="token header-name keyword">Referer</span><span class="token punctuation">:</span> <span class="token header-value">https://www.bilibili.com/</span></span>
<span class="token header"><span class="token header-name keyword">Accept-Encoding</span><span class="token punctuation">:</span> <span class="token header-value">identity</span></span>
<span class="token header"><span class="token header-name keyword">Accept-Language</span><span class="token punctuation">:</span> <span class="token header-value">zh-CN,zh;q=0.9</span></span>
<span class="token header"><span class="token header-name keyword">Range</span><span class="token punctuation">:</span> <span class="token header-value">bytes=0-16</span></span>

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这上面第一行的 GET 就是<strong>请求方法</strong>，<code>/cmaskboss/164203142_30_1.enhance.webmask</code> 则是 <strong>URL</strong> , 而<code>HTTP/1.1</code>则是<strong>协议版本</strong>。接下来从<code>Host</code>开始到最后一行<code>Range</code>，都是<strong>Headers 头</strong>。</p><h1 id="响应报文" tabindex="-1"><a class="header-anchor" href="#响应报文"><span>响应报文</span></a></h1><div class="language-http line-numbers-mode" data-ext="http" data-title="http"><pre class="language-http"><code><span class="token response-status"><span class="token http-version property">HTTP/1.1</span> <span class="token status-code number">206</span> <span class="token reason-phrase string">Partial Content</span></span>
<span class="token header"><span class="token header-name keyword">Content-Type</span><span class="token punctuation">:</span> <span class="token header-value">application/octet-stream</span></span>
<span class="token header"><span class="token header-name keyword">Content-Length</span><span class="token punctuation">:</span> <span class="token header-value">17</span></span>
<span class="token header"><span class="token header-name keyword">Connection</span><span class="token punctuation">:</span> <span class="token header-value">keep-alive</span></span>
<span class="token header"><span class="token header-name keyword">Server</span><span class="token punctuation">:</span> <span class="token header-value">Tengine</span></span>
<span class="token header"><span class="token header-name keyword">ETag</span><span class="token punctuation">:</span> <span class="token header-value">&quot;92086de1e6d1d4791fb950a0ac7e30ba&quot;</span></span>
<span class="token header"><span class="token header-name keyword">Date</span><span class="token punctuation">:</span> <span class="token header-value">Sat, 30 Jan 2021 09:31:31 GMT</span></span>
<span class="token header"><span class="token header-name keyword">Last-Modified</span><span class="token punctuation">:</span> <span class="token header-value">Sun, 04 Oct 2020 01:54:28 GMT</span></span>
<span class="token header"><span class="token header-name keyword">Expires</span><span class="token punctuation">:</span> <span class="token header-value">Mon, 01 Mar 2021 09:31:31 GMT</span></span>
<span class="token header"><span class="token header-name keyword">Age</span><span class="token punctuation">:</span> <span class="token header-value">1018695</span></span>
<span class="token header"><span class="token header-name keyword">Content-Range</span><span class="token punctuation">:</span> <span class="token header-value">bytes 0-16/353225</span></span>
<span class="token header"><span class="token header-name keyword">Accept-Ranges</span><span class="token punctuation">:</span> <span class="token header-value">bytes</span></span>
<span class="token header"><span class="token header-name keyword">X-Application-Context</span><span class="token punctuation">:</span> <span class="token header-value">application</span></span>
<span class="token header"><span class="token header-name keyword">x-kss-request-id</span><span class="token punctuation">:</span> <span class="token header-value">75bcbfa8ab194e3c825e89c81a912692</span></span>
<span class="token header"><span class="token header-name keyword">x-kss-BucketOwner</span><span class="token punctuation">:</span> <span class="token header-value">MjAwMDAyMDEwNw==</span></span>
<span class="token header"><span class="token header-name keyword">X-Info-StorageClass</span><span class="token punctuation">:</span> <span class="token header-value">-</span></span>
<span class="token header"><span class="token header-name keyword">Content-MD5</span><span class="token punctuation">:</span> <span class="token header-value">kght4ebR1HkfuVCgrH4wug==</span></span>
<span class="token header"><span class="token header-name keyword">X-Cache-Status</span><span class="token punctuation">:</span> <span class="token header-value">HIT from KS-CLOUD-JH-MP-01-03</span></span>
<span class="token header"><span class="token header-name keyword">X-Cache-Status</span><span class="token punctuation">:</span> <span class="token header-value">HIT from KS-CLOUD-TJ-UN-14-13</span></span>
<span class="token header"><span class="token header-name keyword">X-Cache-Status</span><span class="token punctuation">:</span> <span class="token header-value">HIT from KS-CLOUD-LF-UN-11-25</span></span>
<span class="token header"><span class="token header-name keyword">Access-Control-Allow-Origin</span><span class="token punctuation">:</span> <span class="token header-value">https://www.bilibili.com</span></span>
<span class="token header"><span class="token header-name keyword">Access-Control-Allow-Headers</span><span class="token punctuation">:</span> <span class="token header-value">Origin,X-Requested-With,Content-Type,Accept,range</span></span>
<span class="token header"><span class="token header-name keyword">X-Cdn-Request-ID</span><span class="token punctuation">:</span> <span class="token header-value">7e2c783ca7d392624118593ec1dc66bc</span></span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>类似请求报文，<code>HTTP/1.1</code>是<strong>协议版本</strong>，<code>206</code>是<strong>状态码</strong>，<code>Partial Content</code> 则是<strong>状态描述符</strong>。接下来从<code>Content-Type</code>开始到最后一行<code>X-Cdn-Request-ID</code>都是<strong>Headers 信息</strong>。</p><h1 id="报文信息解读" tabindex="-1"><a class="header-anchor" href="#报文信息解读"><span>报文信息解读</span></a></h1><p>其实上面的抓包信息，在浏览器里按 F12 就能看到，之所以要用<code>wireshark</code>可能<strong>只是装 X 效果比较好吧</strong>。按下 F12 看到的响应数据就跟下图展示的那样。</p><img src="https://cdn.xiaobaidebug.top/image/2021-2-11/1613043758890-image.png" style="zoom:100%;"><h1 id="_1-请求数据" tabindex="-1"><a class="header-anchor" href="#_1-请求数据"><span>1.请求数据</span></a></h1><img src="https://cdn.xiaobaidebug.top/image/2021-2-11/1613046030107-image.png" style="zoom:100%;"><h1 id="_2-响应数据" tabindex="-1"><a class="header-anchor" href="#_2-响应数据"><span>2.响应数据</span></a></h1><img src="https://cdn.xiaobaidebug.top/image/2021-2-11/1613046094269-image.png" style="zoom:100%;"><h1 id="_3-request-url" tabindex="-1"><a class="header-anchor" href="#_3-request-url"><span>3.Request URL</span></a></h1><h2 id="url-是什么" tabindex="-1"><a class="header-anchor" href="#url-是什么"><span>URL 是什么</span></a></h2><p>URL 代表着是统一资源定位符（Uniform Resource Locator）。作用是为了告诉使用者 某个资源在 Web 上的地址。这个资源可以是一个 HTML 页面，一个 CSS 文档，一幅图像或一个猫片等等。上面我们请求猫片的 URL 就是 <code>https://upos-sz-staticks3.bilivideo.com/cmaskboss/164203142_30_1.enhance.webmask</code> 这里面细分，又可以分为好几个部分。</p><ul><li>协议部分</li></ul><p>表示该 URL 的协议部分为 http 还是 https，会用//为分隔符。上面的 URL 表示网页用的是 HTTPS 协议，而上面提到的 X 影天堂用的则是 ftp 协议的下载链接。</p><ul><li>域名部分</li></ul><p>域名是<code>upos-sz-staticks3.bilivideo.com</code>，在发送请求前，会向 DNS 服务器解析 IP，如果已经知道 ip，还可以跳过 DNS 解析那一步，直接把 IP 当做域名部分使用。</p><ul><li>端口部分</li></ul><p>域名后面有些时候会带有端口，和域名之间用:分隔，端口不是一个 URL 的必须的部分。当网址为<strong>http://<strong>时，默认端口为</strong>80</strong></p><p>当网址为<strong>https://<strong>时，默认端口为</strong>443</strong>，以上两种都可以省略端口号。上面的 URL 其实<strong>省略了 443 端口</strong>号。</p><ul><li>虚拟目录</li></ul><p>从域名的第一个/开始到最后一个/为止，是虚拟目录的部分。虚拟目录也不是 URL 必须的部分，本例中的虚拟目录是<code>/cmaskboss/</code></p><ul><li>文件名部分</li></ul><p>从域名最后一个/开始到?为止，是文件名部分；如果没有?，则是从域名最后一个/开始到#为止，是文件名部分；如果没有?和#，那么就从域名的最后一个/从开始到结束，都是文件名部分。本例中的文件名是<code>164203142_30_1.enhance.webmask</code>，文件名也不是一个 URL 的必须部分。</p><h2 id="url-和-uri-的区别" tabindex="-1"><a class="header-anchor" href="#url-和-uri-的区别"><span>URL 和 URI 的区别</span></a></h2><ul><li><strong>URL</strong>:Uniform Resource Locator <strong>统一资源定位符</strong>；</li><li><strong>URI</strong>: Uniform Resource Identifier <strong>统一资源标识符</strong>；</li></ul><p>其实一直有个误解，很多人以为 URI 是 URL 的子集，其实应该反过来。URL 是 URI 的子集才对。简单解释下。<br> 假设&quot;小白&quot;(URI)是一种资源，而&quot;在迪丽亦巴的怀里&quot;表明了一个位置。如果你想要找到（locate）小白，那么你可以到&quot;在迪丽亦巴怀里&quot;找到小白，而&quot;在迪丽亦巴怀里的/小白&quot;才是我们常说的 URL。而&quot;在迪丽亦巴怀里的/小白&quot;（URL）显然是&quot;小白&quot;（URI）的子集，毕竟，&quot;小白&quot;还可能是&quot;在牛亦菲怀里的/小白&quot;（其他 URL）。</p><img src="https://cdn.xiaobaidebug.top/image/2021-2-11/1613045259027-Untitled Diagram (3).jpg" style="zoom:100%;"><h1 id="_4-request-method" tabindex="-1"><a class="header-anchor" href="#_4-request-method"><span>4.Request Method</span></a></h1><p>HTTP 定义了一组<strong>请求方法</strong>，以表明要对给定资源执行的操作。指示针对给定资源要执行的期望动作.。虽然他们也可以是名词，但这些请求方法有时被称为 HTTP 动词.。每一个请求方法都实现了不同的语义。</p><p>这次请求猫片的请求里用的是 GET，意味着获取。但其实 HTTP 定义了多种请求方法，来满足各种需求。除了 Get，还有几个 POST、HEAD、OPTIONS、PUT、DELETE、TRACE 和 CONNECT。</p><img src="https://cdn.xiaobaidebug.top/image/2021-2-11/1613055907068-GET跟我一样的还有7个.jpg" style="zoom:100%;"><p>常见的各个请求方法的具体功能如下：</p><h2 id="get" tabindex="-1"><a class="header-anchor" href="#get"><span>GET</span></a></h2><p>请求指定的页面信息，并返回消息主体(body)+头信息(header)。</p><h2 id="head" tabindex="-1"><a class="header-anchor" href="#head"><span>HEAD：</span></a></h2><p>HEAD 和 GET 本质是一样的，区别在于 HEAD 只返回头信息(header)，不返回消息主体(body)。大家不要以为它没用，它跟 GET 和 POST 一样，在 http/1.0 的时候就存在了，实属三元老之一了。主要用途</p><ul><li><p>如果想要判断某个资源是否存在，虽然用 GET 也能做到，但这里用 HEAD 还省下拿 body 的消耗，返回状态码 200 就是有 404 就是无</p></li><li><p>如果请求的是一个比较大的资源，比如一个超大视频和文件，你只想知道它到底有多大，而不需要整个下载下来，这时候使用 HEAD 请求，返回的 headers 会带有文件的大小（<code>content-lenght</code>）。</p></li></ul><h2 id="post" tabindex="-1"><a class="header-anchor" href="#post"><span>POST</span></a></h2><p>向服务器提交数据。这个方法用途广泛，几乎目前所有的提交操作都是靠这个完成。POST 跟 GET 最常用，但最大的区别在于，POST 每次调用都可能会修改数据，是非幂等的，而 GET 类似于只读，是幂等的。</p><h2 id="put" tabindex="-1"><a class="header-anchor" href="#put"><span>PUT：</span></a></h2><p>这个方法比较少见。在 HTTP 规范中 POST 是非等幂的，多次调用会产生不同的结果。比如：创建一个用户,由于网络原因或是其他原因多创建了几次,那么将会有多个用户被创建。而 PUT id/xiaobai 则会创建一个 id 为 xiaobai 的用户，多次调用还是会创建的结果是一样的，所以 PUT 是等幂的。但是一般为了避免造成心智负担，实战中也会使用 POST 替代 PUT。</p><h2 id="delete" tabindex="-1"><a class="header-anchor" href="#delete"><span>DELETE：</span></a></h2><p>删除某一个资源。基本上这个也很少见，一般实战中如果是删除操作，也是使用 POST 来替代。</p><h2 id="options" tabindex="-1"><a class="header-anchor" href="#options"><span>OPTIONS：</span></a></h2><h3 id="options-是什么" tabindex="-1"><a class="header-anchor" href="#options-是什么"><span>options 是什么</span></a></h3><p>它用于获取当前 URL 所支持的方法。若请求成功，则它会在 HTTP 响应头部中带上给各种“Allow”的头，表明某个请求在对应的服务器中都支持哪种请求方法。比如下图：</p><img src="https://cdn.xiaobaidebug.top/image/2021-2-11/1613058818793-image.png" style="zoom:100%;"><p>这里面需要关注的点有两个</p><ul><li><p>Request Header 里的关键字段</p><figure><img src="https://cdn.xiaobaidebug.top/image/2021-2-12/1613060189629-options请求字段 (2).jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure></li><li><p>Response Header 里的关键字段</p><figure><img src="https://cdn.xiaobaidebug.top/image/2021-2-13/1613174205328-_options响应字段 (1).jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure></li></ul><p><code>Options</code>堪称是网络协议中的老实人，就好像老实人刚谈了个女朋友，每次牵手前都要问下人家 “我可以牵你的手吗？”， “我可以抱你吗？”，得到了答应后才会下手。差点被这老实人气质感动得留下了不争气的泪水。</p><img src="https://cdn.xiaobaidebug.top/image/2021-2-11/1613057652579-加冕为王.jpg" style="zoom:100%;"><h3 id="什么时候需要使用-options" tabindex="-1"><a class="header-anchor" href="#什么时候需要使用-options"><span>什么时候需要使用 options</span></a></h3><p>在<strong>跨域</strong>（记住这个词，待会解释）的情况下，浏览器发起<strong>复杂请求前</strong>会<strong>自动</strong>发起 options 请求。跨域共享标准规范要求，对那些可能对服务器数据产生副作用的 HTTP 请求方法（特别是 GET 以外的 HTTP 请求，或者搭配某些 MIME 类型的 POST 请求），浏览器必须首先使用 options 方法发起一个预检请求，从而获知服务端是否允许该跨域请求。服务器确认允许之后，才发起实际的 HTTP 请求。</p><p>这里提到了两个关键词：</p><ul><li>跨域</li><li>复杂请求</li></ul><h3 id="什么是简单请求和复杂请求。" tabindex="-1"><a class="header-anchor" href="#什么是简单请求和复杂请求。"><span>什么是简单请求和复杂请求。</span></a></h3><p>某些请求不会触发 CORS 预检请求，这样的请求一般称为&quot;简单请求&quot;，而会触发预检的请求则为&quot;复杂请求&quot;。</p><p>1.简单请求</p><ul><li><p>请求方法为<code>GET、HEAD、POST</code></p></li><li><p>只有以下<code>Headers</code>字段</p><ul><li><code>Accept</code></li><li><code>Accept-Language</code></li><li><code>Content-Language</code></li><li><code>Content-Type</code></li><li><code>DPR/Downlink/Save-Data/Viewport-Width/Width</code> (这些不常见，放在一起)</li></ul></li><li><p><code>Content-Type</code> 只有以下三种</p><ul><li><code>application/x-www-form-urlencoded</code></li><li><code>multipart/form-data</code></li><li><code>text/plain</code></li></ul></li><li><p>请求中的任意 XMLHttpRequestUpload 对象均没有注册任何事件监听器；</p></li><li><p>请求中没有使用 ReadableStream 对象。</p><p>2.复杂请求</p></li><li><p>不满足简单请求的，都是复杂请求</p></li></ul><p>由此可见，因为上述请求在获取网上资源的请求 Headers 里带有 <code>Access-Control-Request-Headers: range</code> , 而<code>range</code>正好不在简单请求的条件 2 中提到的 Headers 范围里，因此属于<strong>复杂请求</strong>，于是触发预检 options 请求。</p><h3 id="什么是跨域" tabindex="-1"><a class="header-anchor" href="#什么是跨域"><span>什么是跨域</span></a></h3><p>刚刚提到了一个词叫<strong>跨域</strong>，那什么是跨域呢？在了解跨域之前，首先要了解一个概念：<strong>同源</strong>。所谓<strong>同源</strong>是指，<strong>域名、协议、端口均相同</strong>。</p><img src="https://cdn.xiaobaidebug.top/image/2021-2-11/1613041939151-image.png" style="zoom:100%;"><p>不明白没关系，举个例子。</p><figure><img src="https://cdn.xiaobaidebug.top/image/2021-2-14/1613311181978-是否同源.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>需要特别注意的是，localhost 和 127.0.0.1 虽然都指向本机，但也<strong>不属于同源</strong>。</p><p>而<strong>非同源</strong>之间网页调用就是我们所说的<strong>跨域</strong>。在<strong>浏览器</strong>同源策略限制下，向不同<strong>源</strong>发送 XHR 请求，<strong>浏览器</strong>认为该请求不受信任，禁止请求，具体表现为请求后不正常响应。</p><h3 id="options-带来什么问题" tabindex="-1"><a class="header-anchor" href="#options-带来什么问题"><span>options 带来什么问题</span></a></h3><p>由此可见，复杂请求的条件其实非常容易满足，而一旦满足复杂请求的条件，则浏览器便会发送 2 次请求（一次预检 options，一次复杂请求），这一次 options 就一来一回（一个 RTT），显然会导致延迟和不必要的网络资源浪费，高并发情况下则可能为服务器带来严重的性能消耗。</p><img src="https://cdn.xiaobaidebug.top/image/2021-2-13/1613176456625-加冕为王 (2).jpg" style="zoom:100%;"><h3 id="如何优化-options" tabindex="-1"><a class="header-anchor" href="#如何优化-options"><span>如何优化 options</span></a></h3><p>每次复杂请求前都会调用一次 options，这其实非常没有必要。因为大部分时候相同的请求，短时间内获得的结果是不会变的，是否可以通过浏览器缓存省掉这一次查询？</p><p><code>Access-Control-Max-Age</code>就是优化这个流程中使用的一个 Header。它的作用是当你每次请求<code>options</code>方法时，服务端返回调用支持的方法（Access-Control-Allow-Methods ）和 Headers（Access-Control-Allow-Headers）有哪些，同时告诉你，它在接下来 <code>Access-Control-Max-Age</code>时间（单位是秒）里都支持，则这段时间内，不再需要使用 options 进行请求。特别注意的是，当<code>Access-Control-Max-Age</code>的值为-1 时，表示禁用缓存，每一次请求都需要发送预检请求，即用 OPTIONS 请求进行检测。</p><figure><img src="https://cdn.xiaobaidebug.top/image/options优化后.jpg" alt="options优化后" tabindex="0" loading="lazy"><figcaption>options优化后</figcaption></figure><h1 id="_5-status-code" tabindex="-1"><a class="header-anchor" href="#_5-status-code"><span>5.Status Code</span></a></h1><h2 id="状态码是什么" tabindex="-1"><a class="header-anchor" href="#状态码是什么"><span>状态码是什么</span></a></h2><p>HTTP Status Code 是常说的 HTTP 状态码。当用户访问一个网页时，浏览器会向网页所在服务器发出请求。服务器则会根据请求作出响应，而状态码则是响应的一部分，代表着本次请求的结果。所有状态码的第一个数字代表了响应的大概含义，组合上第二第三个数字则可以表示更具体的原因。如果请求失败了，通过这个状态码，大概初步判断出这次请求失败的原因。以下是五类状态码的含义。</p><figure><img src="https://cdn.xiaobaidebug.top/image/2021-2-11/1613045090544-状态码表格.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><h2 id="状态码流程" tabindex="-1"><a class="header-anchor" href="#状态码流程"><span>状态码流程</span></a></h2><p>可以根据以下流程图了解下各类状态码间的关系。</p><img src="https://cdn.xiaobaidebug.top/image/2021-2-15/1613345953784-Copy of 2xx流程图.jpg" style="zoom:150%;"><ul><li>2xx 和 3xx 之间的流程关系</li></ul><figure><img src="https://cdn.xiaobaidebug.top/image/2021-2-16/1613439607255-2xx流程图 (2).jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><ul><li>4xx 的状态流程</li></ul><img src="https://cdn.xiaobaidebug.top/image/2021-2-15/1613403987304-4xx流程.jpg" style="zoom:100%;"><ul><li>5xx 的状态流程</li></ul><img src="https://cdn.xiaobaidebug.top/image/2021-2-16/1613406108083-5xx流程图 (1).jpg" style="zoom:100%;"><h2 id="常见状态码介绍" tabindex="-1"><a class="header-anchor" href="#常见状态码介绍"><span>常见状态码介绍</span></a></h2><ul><li>200 OK</li></ul><p>这是最常见的状态码。代表请求已成功，数据也正常返回。而请求猫片虽然响应成功了，但却不是 200，而是 206，是为什么呢，接下去继续看看。</p><ul><li>206 Partial Content</li></ul><p>这个状态码在上面请求的响应结果。服务器已经成功处理了部分 GET 请求。类似于看视频或者迅雷这类的 HTTP 下载工具都是使用此类响应实现断点续传或者将一个大文档分解为多个下载段同时下载。</p><ul><li><p>307 Temporary Redirect</p><p>内部重定向。重定向的意思是，当你输入一个网址的时候，浏览器会自动帮你跳转到另外一个网址上。比如，当你在浏览器输入框输入<code>http://www.baidu.com/</code>时。由于使用 http 并不安全，百度会自动帮你跳转到它对应的 https 网页上。而此时，需要重定向的地址，会通过<code>Response Headers</code>的<code>Location</code>返回</p><img src="https://cdn.xiaobaidebug.top/image/2021-2-13/1613187421644-image.png" style="zoom:100%;"></li><li><p>404 Not Found</p><p>请求失败，请求所希望得到的资源未被在服务器上发现。出现这个错误的最有可能的原因是服务器端没有这个页面，或者是 Request Method 与注册 URL 的 Method 不一致，比如我有一个 URL 在服务端注册的 Request Method 为 <strong>POST</strong>，但调用的时候却错误用了<strong>GET</strong>，则也会出现 404 错误。</p></li><li><p>499 Client has closed connection</p><p>网络请求过程中，由于服务端处理时间过长，客户端超时。一般常见于，后端服务器处理时间过长，而客户端也设置了一个超时等待时间，客户端等得“不耐烦”了，主动关掉连接时报出。</p><figure><img src="https://cdn.xiaobaidebug.top/image/2021-2-20/1613777634555-Get和Post (1).jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure></li><li><p>502 Bad Gateway</p><p>服务器方面无法给予正常的响应。一般常见于服务器崩溃后，nginx 无法正常收到服务端的响应，给客户端返回 502 状态码。</p><figure><img src="https://cdn.xiaobaidebug.top/image/2021-2-20/1613777745819-502的过程.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure></li><li><p>504 Gateway Timeout</p><p>网络请求过程中，由于服务端处理时间过长，网关超时。一般常见于，后端服务器逻辑处理时间过长，甚至长于 nginx 设置的最长等待时间时报错。它跟 499 状态码非常像，区别在于 499 表示的是客户端超时，504 是网关超时。如果是 499 超时，可以考虑修改客户端的代码调整超时时间，如果是 504，则考虑调整 nginx 的超时配置。</p><figure><img src="https://cdn.xiaobaidebug.top/image/2021-2-20/1613777517520-504的过程 (1).jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure></li></ul><h1 id="_6-headers" tabindex="-1"><a class="header-anchor" href="#_6-headers"><span>6. Headers</span></a></h1><h2 id="content-length" tabindex="-1"><a class="header-anchor" href="#content-length"><span>Content-Length</span></a></h2><p><code>Content-Length</code>是 HTTP 的消息长度, 用<strong>十进制数字</strong>表示。<code>Content-Length</code>首部指出报文中消息的当前实际字节大小。如果消息文本进行了 gzip 压缩的话， <code>Content-Length</code>指的就是压缩后的大小而不是原始大小。</p><p>正常情况下<code>Content-Length</code>是不需要手动去设置的，大部分语言的网络库都会自动封装好，但是如果在一些特殊情况下，出现<code>Content-Length</code>与实际要发送的消息大小不一致，就会出现一些问题。</p><ul><li><p>如果<code>Content-Length</code> &lt; 实际长度</p><p>下面启动一个 HTTP 服务器，所有语言都一样，示例里使用了 golang。</p><div class="language-go line-numbers-mode" data-ext="go" data-title="go"><pre class="language-go"><code><span class="token keyword">package</span> main

<span class="token keyword">import</span> <span class="token punctuation">(</span>
	<span class="token string">&quot;fmt&quot;</span>
	<span class="token string">&quot;io/ioutil&quot;</span>
	<span class="token string">&quot;log&quot;</span>
	<span class="token string">&quot;net/http&quot;</span>
<span class="token punctuation">)</span>

<span class="token comment">// w表示response对象，返回给客户端的内容都在对象里处理</span>
<span class="token comment">// r表示客户端请求对象，包含了请求头，请求参数等等</span>
<span class="token keyword">func</span> <span class="token function">index</span><span class="token punctuation">(</span>w http<span class="token punctuation">.</span>ResponseWriter<span class="token punctuation">,</span> r <span class="token operator">*</span>http<span class="token punctuation">.</span>Request<span class="token punctuation">)</span> <span class="token punctuation">{</span>
	b<span class="token punctuation">,</span> <span class="token boolean">_</span> <span class="token operator">:=</span> ioutil<span class="token punctuation">.</span><span class="token function">ReadAll</span><span class="token punctuation">(</span>r<span class="token punctuation">.</span>Body<span class="token punctuation">)</span>
	fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">&quot;request body=%#v, content_length=%v \\nheaders=%v&quot;</span><span class="token punctuation">,</span><span class="token function">string</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span><span class="token punctuation">,</span> r<span class="token punctuation">.</span>ContentLength<span class="token punctuation">,</span> r<span class="token punctuation">.</span>Header<span class="token punctuation">)</span>
	<span class="token comment">// 往w里写入内容，就会在浏览器里输出</span>
	fmt<span class="token punctuation">.</span><span class="token function">Fprintf</span><span class="token punctuation">(</span>w<span class="token punctuation">,</span> <span class="token function">string</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>

<span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
	<span class="token comment">// 设置路由，如果访问/，则调用index方法</span>
	http<span class="token punctuation">.</span><span class="token function">HandleFunc</span><span class="token punctuation">(</span><span class="token string">&quot;/&quot;</span><span class="token punctuation">,</span> index<span class="token punctuation">)</span>

	<span class="token comment">// 启动web服务，监听9090端口</span>
	err <span class="token operator">:=</span> http<span class="token punctuation">.</span><span class="token function">ListenAndServe</span><span class="token punctuation">(</span><span class="token string">&quot;:9999&quot;</span><span class="token punctuation">,</span> <span class="token boolean">nil</span><span class="token punctuation">)</span>
	<span class="token keyword">if</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>
		log<span class="token punctuation">.</span><span class="token function">Fatal</span><span class="token punctuation">(</span><span class="token string">&quot;ListenAndServe: &quot;</span><span class="token punctuation">,</span> err<span class="token punctuation">)</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在控制台输入</p><div class="language-bash line-numbers-mode" data-ext="sh" data-title="sh"><pre class="language-bash"><code>$ $ <span class="token function">curl</span> <span class="token parameter variable">-L</span> <span class="token parameter variable">-X</span> POST <span class="token string">&#39;http://127.0.0.1:9999&#39;</span> <span class="token parameter variable">-H</span> <span class="token string">&#39;Content-Type: application/json&#39;</span> <span class="token parameter variable">-H</span> <span class="token string">&#39;Content-Length: 5&#39;</span> <span class="token parameter variable">-d</span> <span class="token string">&#39;1234567&#39;</span> <span class="token operator">|</span>  jq
  % Total    % Received % Xferd  Average Speed   Time    Time     Time  Current
                                 Dload  Upload   Total   Spent    Left  Speed
<span class="token number">100</span>    <span class="token number">12</span>  <span class="token number">100</span>     <span class="token number">5</span>  <span class="token number">100</span>     <span class="token number">7</span>    <span class="token number">828</span>   <span class="token number">1160</span> --:--:-- --:--:-- --:--:--  <span class="token number">1400</span>
<span class="token number">12345</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>输入的 body 是 <code>1234567</code>，共<strong>7 个数字</strong>，但是输入的 <code>Content-Length</code>为 5。到了服务器那，收到了 <code>12345</code>，共<strong>5 个数字</strong>，数量上跟输入的<code>Content-Length</code>一致。 由此可见当<code>Content-Length</code> &lt; 实际长度， 消息会被截断。</p></li><li><p>如果<code>Content-Length</code> &gt; 实际长度</p><p>还是上面的服务端代码，但是控制台输入以下命令</p><div class="language-bash line-numbers-mode" data-ext="sh" data-title="sh"><pre class="language-bash"><code>$ <span class="token function">curl</span> <span class="token parameter variable">-L</span> <span class="token parameter variable">-X</span> POST <span class="token string">&#39;http://127.0.0.1:9999&#39;</span> <span class="token parameter variable">-H</span> <span class="token string">&#39;Content-Type: application/json&#39;</span> <span class="token parameter variable">-H</span> <span class="token string">&#39;Content-Length: 100&#39;</span> <span class="token parameter variable">-d</span> <span class="token string">&#39;1234567&#39;</span> <span class="token operator">|</span> jq
  % Total    % Received % Xferd  Average Speed   Time    Time     Time  Current
                                 Dload  Upload   Total   Spent    Left  Speed
<span class="token number">100</span>     <span class="token number">7</span>    <span class="token number">0</span>     <span class="token number">0</span>    <span class="token number">0</span>     <span class="token number">7</span>      <span class="token number">0</span>      <span class="token number">0</span> --:--:--  <span class="token number">0</span>:01:19 --:--:--     <span class="token number">0</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这次情况不太一样，会发现请求一直阻塞没有返回。这是因为输入的 body 是 <code>1234567</code>，共<strong>7 个数字</strong>，但是输入的 <code>Content-Length</code>为 100。也就是服务端一直认为这次的 body<strong>长度为 100</strong>，但是目前只收到了<strong>部分消息（长度为 7）</strong>，剩余的长度为 93 的消息由于各种原因<strong>还在路上</strong>，因此选择<strong>傻傻等待剩下的消息</strong>，就造成了上面提到的阻塞。</p></li></ul><h2 id="range" tabindex="-1"><a class="header-anchor" href="#range"><span>Range</span></a></h2><img src="https://cdn.xiaobaidebug.top/image/2021-2-14/1613299089850-image.png" style="zoom:100%;"><p>视频播放需要支持用户调整播放进度，支持让用户选择直接跳到中间部分开始播放。为了实现这个功能，需要通过 HTTP Range Requests 协议用于指定需要获取视频片段。而 Request Header 里的 range 头则是用于指定要请求文件的起始和结束位置。</p><img src="https://cdn.xiaobaidebug.top/image/2021-2-14/1613298634191-image.png" style="zoom:100%;"><img src="https://cdn.xiaobaidebug.top/image/2021-2-14/1613298705993-image.png" style="zoom:100%;"><ul><li>如果服务器不支持，直接忽略 Range 头，浏览器会正常按流式加载整个视频文件，以状态码 200 响应即可。另外，当我们在 html 中放一个 video 标签，浏览器会直接发起一个 <code>Range: bytes=0-</code> 的请求，向服务器请求从开始到结尾的完整文件。</li><li>如果服务器支持 Range Requests，会读取视频文件，并将他的第 162653 ～ 242638 字节提取出来，响应码为 206，则浏览器会在接收到足够字节（比如当前播放进度往后推 20s）时结束掉请求，以节省网络流量；当播放进度继续往前，缓存不够时，浏览器会发起一个新的 Range Requests 请求，请求的 Range 直接从缓存结尾的字节开始，只加载剩余的部分文件。同时返回的 Response Headers 中有一个 content-range 的字段域，用于告诉了客户端发送了多少数据。content-range 描述了响应覆盖的范围和整个实体长度。一般格式：<code>Content-Range：开始字节位置-结束字节位置／文件大小（byte）</code>。</li></ul><h2 id="connection" tabindex="-1"><a class="header-anchor" href="#connection"><span>Connection</span></a></h2><h3 id="长连接和短连接" tabindex="-1"><a class="header-anchor" href="#长连接和短连接"><span>长连接和短连接</span></a></h3><ul><li><p>Connection: close</p><p>表示请求响应完成之后立即关闭连接，这是 HTTP/1.0 请求的默认值。每次请求都经过“创建 tcp 连接 -&gt; 请求资源 -&gt; 响应资源 -&gt; 释放连接”这样的过程</p></li><li><p>Connection: keep-alive</p><p>表示连接不立即关闭，可以继续响应下一个请求。HTTP/1.1 的请求默认使用一个持久连接。可以做到只建立一次连接，多次资源请求都复用该连接，完成后关闭。流程上是 建立 tcp 连接 -&gt; 请求资源 -&gt; 响应资源 -&gt; ... （保持连接）... -&gt; 第 n 次请求资源 -&gt; 第 n 次响应资源 -&gt; 释放连接。</p></li></ul><p>在 http1.1 中 Request Header 和 Reponse Header 中都有可能出现一个 Connection: keep-alive 头信息。Request Header 里的 Connection: keep-alive 头是为了告诉服务端，客户端想要以长连接形式进行通信。而 Response Header 里的 Connection: keep-alive 头是服务端告诉客户端，我的服务器支持以长连接的方式进行通信。如果不能使用长连接，会<strong>返回 Connection: close ，相当于告诉客户端“我不支持长连接，你死了这条心，老老实实用短连接吧</strong>” 。</p><h3 id="http-为什么要使用长连接" tabindex="-1"><a class="header-anchor" href="#http-为什么要使用长连接"><span>HTTP 为什么要使用长连接</span></a></h3><p>我们知道 HTTP 建立在 TCP 传输层协议之上，而 TCP 的建立需要三次握手，关闭需要四次挥手，这些步骤都需要时间，带给 HTTP 的就是请求响应时延。如果使用短连接，那么每次数据传输都需要经历一次上面提到的几个步骤，如果能只连接一次，保持住这个连接不断开，期间通信就可以省下建立连接和断开连接的过程，对于提升 HTTP 性能有很大的帮助。</p><img src="https://cdn.xiaobaidebug.top/image/2021-2-14/1613290339498-http短连接.jpg" style="zoom:100%;"><ul><li>可以看到，在使用 Connection: close 通信时，每次都需要重新经历一次握手挥手。可以通过 Connection: keep-alive 省下这部分的资源消耗。</li></ul><img src="https://cdn.xiaobaidebug.top/image/2021-2-14/1613292366161-http长连接.jpg" style="zoom:100%;"><ul><li><strong>长连接</strong>可以<strong>省去较多的 TCP 建立和关闭的操作，减少浪费，节约时间</strong>。对于频繁请求资源的客户来说，较适用长连接。但是在长连接的应用场景下，需要有一方主动关闭连接。如果客户端和服务端之间的连接一直不关闭的话，连接数则会越来越多，严重的时候会造成资源占用过高。</li><li>解决方案也比较简单。如果这些连接其实长时间内并没有任何数据传输的话，那其实属于空闲连接，这时候可以在服务端设置空闲连接的存活时间，超过一定时间后由服务端主动断掉，从而保证无用连接及时释放。</li></ul><h2 id="cookies" tabindex="-1"><a class="header-anchor" href="#cookies"><span>Cookies</span></a></h2><h3 id="cookies-是什么" tabindex="-1"><a class="header-anchor" href="#cookies-是什么"><span>Cookies 是什么</span></a></h3><ol><li><p>Cookie 是浏览器访问服务器后，服务器传给浏览器的一段数据。里面一般带有该浏览器的身份信息。</p></li><li><p>浏览器需要保存这段数据，不得轻易删除。</p></li><li><p>此后每次浏览器访问该服务器，都必须带上这段数据。服务器用使用这段数据确认浏览器身份信息。</p></li></ol><h3 id="cookie-的作用" tabindex="-1"><a class="header-anchor" href="#cookie-的作用"><span>Cookie 的作用</span></a></h3><p>Cookie 一般有两个作用。</p><p>1.识别用户身份。</p><ul><li><p>举个例子。用户 A 用浏览器访问了“猫猫网”，“猫猫网”的服务器就会立刻给 A 返回一段 Cookie 数据，内含「uid=a」。</p></li><li><p>当 A 再次访问“猫猫网”下的其他页面时，比如跳转到“猫猫交友评论”，就会附带上「uid=a」这段数据。</p></li><li><p>同理，用户 B 用浏览器访问“猫猫网” 时，就给 B 分配了一段 Cookie 数据，内含「uid=b」。B 之后访问“猫猫网”的时候，就会一直带上「uid=b」这段数据。</p></li><li><p>因此“猫猫网”的服务器通过 Cookie 数据就能区分 A 和 B 两个用户了。</p><p>2.持久化用户信息。</p></li><li><p>因为 cookies 的数据会被用户浏览器保存到本地下。因此可以利用这一特点保持一些简单的用户数据。</p></li><li><p>比如一些博客网站，可以通过 cookies 记录下用户的性别年龄等信息，以此进行一些个性化展示。</p></li><li><p>当然上面提到的都是一些比较粗糙的场景，是为了方便大家理解 cookies 的功能。实际使用 cookies 会非常谨慎。</p></li></ul><h2 id="referrer-policy-和-referrer" tabindex="-1"><a class="header-anchor" href="#referrer-policy-和-referrer"><span>Referrer Policy 和 Referrer</span></a></h2><img src="https://cdn.xiaobaidebug.top/image/2021-2-1/1612146090912-image.png" style="zoom:100%;"><h3 id="referrer-是什么" tabindex="-1"><a class="header-anchor" href="#referrer-是什么"><span>Referrer 是什么</span></a></h3><p>Referrer 是 HTTP 请求 header 的报文头，用于指明当前流量的来源参考页面，常被用于分析用户来源等信息。通过这个信息，我们可以知道访客是怎么来到当前页面的。比如在上面的请求截图里，可以看出我是使用<code>https://www.bilibili.com/</code>访问的视频资源。</p><h3 id="referrer-policy-是什么" tabindex="-1"><a class="header-anchor" href="#referrer-policy-是什么"><span>Referrer Policy 是什么</span></a></h3><ul><li><p>Referrer 字段，会用来指定该请求是从哪个页面跳转页来的，里面的信息是浏览器填的。</p></li><li><p>而 Referrer Policy 则是用于控制 Referrer 信息传不传、传哪些信息、在什么时候传的策略。</p></li></ul><p>为什么要这么麻烦呢？因为有些网站一些用户敏感信息，比如 sessionid 或是 token 放在地址栏里，如果当做 Referrer 字段全部传递的话，那第三方网站就会拿到这些信息，会有一定的安全隐患。所以就有了 Referrer Policy，用于过滤 Referrer 报头内容。</p><p>比如在上面的请求截图里，可以看出我是使用<code>strict-origin-when-cross-origin</code>策略，含义是跨域时将当前页面 URL 过滤掉参数及路径部分，仅将协议、域名和端口（如果有的话）当作 Referrer。否则 Referrer 还是传递当前页的全路径。同时当发生降级（比如从 https:// 跳转到 http:// ）时，不传递 Referrer 报头。</p><h2 id="cache-control" tabindex="-1"><a class="header-anchor" href="#cache-control"><span>Cache-control</span></a></h2><h3 id="什么是-cache-control" tabindex="-1"><a class="header-anchor" href="#什么是-cache-control"><span>什么是 cache-control</span></a></h3><p>cache-control，用于控制浏览器缓存。简而言之，当某人访问网站时，其浏览器将在本地保存某些资源，例如图像和网站数据。当该用户重新访问同一网站时，缓存控制设置的规则会确定该用户是否从本地缓存中加载这些资源，或者浏览器是否必须向服务器发送新资源的请求。</p><h3 id="什么是浏览器缓存" tabindex="-1"><a class="header-anchor" href="#什么是浏览器缓存"><span>什么是浏览器缓存</span></a></h3><p>浏览器缓存是指浏览器本地保存网站资源，以便不必再次通过网络从服务器获取它们。例如，“猫猫网”的背景图像可以保存到本地缓存中，这样在用户第二次访问该页面时，该图像将从用户的本地文件加载，剩下网络获取资源的时间，页面加载速度就会更快。</p><p>但是浏览器也不会永远把这些网站资源放在本地，否则本地磁盘就会炸，所以会限定保存资源的时间，这叫生存时间（TTL）。如果 TTL 过期后用户请求缓存的资源，浏览器必须再次通过网络与服务器建立连接并重新下载这个资源。</p><h3 id="常见的缓存控制策略" tabindex="-1"><a class="header-anchor" href="#常见的缓存控制策略"><span>常见的缓存控制策略</span></a></h3><ul><li><p>cache-control: private<br> 具有“private”指令的响应只能由客户端缓存，不能由中间代理（例如 CDN 或代理）缓存。这些资源通常是包含私密数据的资源，例如显示用户个人信息的网站。</p></li><li><p>cache-control: public<br> 相反，“public”指令表示资源可以由任何缓存存储。</p></li><li><p>cache-control: no-store<br> 带有“no-store”指令的响应无法缓存到任何位置，也永不缓存。也就是说，用户每次请求此数据时，都必须将请求发送到源站服务器以获取新副本。此指令通常保留给包含极其敏感数据的资源，例如银行帐户信息。</p></li><li><p>cache-control: max-age<br> 此指令指定了生存时间，也就是资源在下载后可以缓存多少秒钟。例如，如果将最大期限设置为 1800，则首次从服务器请求资源后的 1800 秒（30 分钟）内，后续请求都会向用户提供该资源的缓存版本。如果 30 分钟后用户再次请求资源，则客户端需要向服务器重新请求该资源。</p></li><li><p>cache-control: no-cache</p><p>从网页截图里可以看出，使用的缓存控制指令是<code>cache-control: no-cache</code>。它表示，只有先检查资源没有更新版本后，才可使用所请求资源的缓存版本。那么问题来了，怎么判断资源是否有更新版本呢？这就需要 <code>ETag</code>。</p></li></ul><h2 id="etag" tabindex="-1"><a class="header-anchor" href="#etag"><span>ETag</span></a></h2><img src="https://cdn.xiaobaidebug.top/image/2021-2-14/1613297647760-image.png" style="zoom:100%;"><p>Etag 是 Entity tag 的缩写，是服务端的一个资源版本的令牌标识。在 HTTP 响应头中将其传送到客户端。每当资源更新时，此令牌会更新。</p><p>比如，浏览器第一次请求资源的时候，服务端返回了这个资源的<code>ETag: &quot;095933fff2323351d3b495f2f879616f1762f752&quot;</code>。</p><p>当浏览器再次请求这个资源的时候，浏览器会将<code>If-None-Match: &quot;095933fff2323351d3b495f2f879616f1762f752&quot;</code> 传输给服务端，服务端拿到该 ETAG，对比资源是否发生变化。</p><ul><li>如果资源未发生改变，则返回 304HTTP 状态码，不返回具体的资源。</li><li>否则表示资源已经更新，浏览器需要下载新版本以提供给用户。</li></ul><p>此过程可确保用户始终获得资源的最新版本，并且无需进行不必要的下载。</p><h1 id="最后" tabindex="-1"><a class="header-anchor" href="#最后"><span>最后</span></a></h1><p>看个猫片都能学到这么多硬核知识。接下来我打算去舞蹈区看看有没有适合你们的知识点。</p><img src="https://cdn.xiaobaidebug.top/image/2021-2-14/1613314979045-脸红开心.jpg" style="zoom:100%;"><p>我是小白，有空？一起在知识的海洋里呛水啊，懂我意思？</p><img src="https://cdn.xiaobaidebug.top/image/2021-1-10/1610269930614-640.png" style="zoom:100%;"><img src="https://cdn.xiaobaidebug.top/1696069689495.png" style="zoom:100%;"><h1 id="参考资料" tabindex="-1"><a class="header-anchor" href="#参考资料"><span>参考资料</span></a></h1><p>- [1] 计算机网络自动向下</p><p>- [2] 极客时间-趣谈网络协议</p><p>- [3] 极客时间-透视 HTTP</p><p>- [4] 图解 HTTP</p><p>- [5] 漫画形象-小肥柴</p>`,173);function g(h,m){const a=t("ExternalLinkIcon");return o(),p("div",null,[r,e("blockquote",null,[e("p",null,[n("文章持续更新，可以微信搜一搜「小白 debug」第一时间阅读，回复【面试】获免费面试题集。本文已经收录在 GitHub "),e("a",d,[n("https://github.com/xiaobaiTech/golangFamily"),i(a)]),n(" , 有大厂面试完整考点和成长路线，欢迎 Star。")])]),u])}const v=s(c,[["render",g],["__file","硬核！漫画图解HTTP知识点_面试题.html.vue"]]),T=JSON.parse('{"path":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/%E6%A0%B8%E5%BF%83%E7%9F%A5%E8%AF%86%E7%82%B9/%E7%A1%AC%E6%A0%B8%EF%BC%81%E6%BC%AB%E7%94%BB%E5%9B%BE%E8%A7%A3HTTP%E7%9F%A5%E8%AF%86%E7%82%B9_%E9%9D%A2%E8%AF%95%E9%A2%98.html","title":"硬核！漫画图解HTTP基础+面试题","lang":"zh-CN","frontmatter":{"title":"硬核！漫画图解HTTP基础+面试题","date":"2021-02-25T22:57:55.000Z","tags":null,"categories":"图解网络","description":" 文章持续更新，可以微信搜一搜「小白 debug」第一时间阅读，回复【面试】获免费面试题集。本文已经收录在 GitHub https://github.com/xiaobaiTech/golangFamily , 有大厂面试完整考点和成长路线，欢迎 Star。 什么是 HTTP HTTP 全称超⽂文本传输协议，也就是HyperText Transfer...","head":[["meta",{"property":"og:url","content":"https://golangguide.top/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/%E6%A0%B8%E5%BF%83%E7%9F%A5%E8%AF%86%E7%82%B9/%E7%A1%AC%E6%A0%B8%EF%BC%81%E6%BC%AB%E7%94%BB%E5%9B%BE%E8%A7%A3HTTP%E7%9F%A5%E8%AF%86%E7%82%B9_%E9%9D%A2%E8%AF%95%E9%A2%98.html"}],["meta",{"property":"og:site_name","content":"golang全栈指南"}],["meta",{"property":"og:title","content":"硬核！漫画图解HTTP基础+面试题"}],["meta",{"property":"og:description","content":" 文章持续更新，可以微信搜一搜「小白 debug」第一时间阅读，回复【面试】获免费面试题集。本文已经收录在 GitHub https://github.com/xiaobaiTech/golangFamily , 有大厂面试完整考点和成长路线，欢迎 Star。 什么是 HTTP HTTP 全称超⽂文本传输协议，也就是HyperText Transfer..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:image","content":"https://cdn.xiaobaidebug.top/image/2021-2-19/1613693230446-%E9%BB%98%E8%AE%A4%E6%96%87%E4%BB%B61613437659307.png"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2024-02-19T03:57:35.000Z"}],["meta",{"name":"twitter:card","content":"summary_large_image"}],["meta",{"name":"twitter:image:alt","content":"硬核！漫画图解HTTP基础+面试题"}],["meta",{"property":"article:author","content":"小白debug"}],["meta",{"property":"article:published_time","content":"2021-02-25T22:57:55.000Z"}],["meta",{"property":"article:modified_time","content":"2024-02-19T03:57:35.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"硬核！漫画图解HTTP基础+面试题\\",\\"image\\":[\\"https://cdn.xiaobaidebug.top/image/2021-2-19/1613693230446-%E9%BB%98%E8%AE%A4%E6%96%87%E4%BB%B61613437659307.png\\",\\"https://cdn.xiaobaidebug.top/image/2021-2-16/1613436372639-b%E7%AB%99%E6%92%B8%E7%8C%AB%E5%A4%A7%E5%9B%BE.png\\",\\"https://cdn.xiaobaidebug.top/image/2021-2-11/1613041437612-http%E4%BC%A0%E8%BE%93%E7%A4%BA%E4%BE%8B%E6%BC%AB%E7%94%BB.jpg\\",\\"https://cdn.xiaobaidebug.top/image/2021-2-11/1613013885789-image.png\\",\\"https://cdn.xiaobaidebug.top/image/2021-2-11/1613007117086-image.png\\",\\"https://cdn.xiaobaidebug.top/image/2021-2-11/1613021710607-http%E6%8A%A5%E6%96%87%E8%A7%A3%E6%9E%90.jpg\\",\\"https://cdn.xiaobaidebug.top/image/2021-2-14/1613311181978-%E6%98%AF%E5%90%A6%E5%90%8C%E6%BA%90.jpg\\",\\"https://cdn.xiaobaidebug.top/image/options%E4%BC%98%E5%8C%96%E5%90%8E.jpg\\",\\"https://cdn.xiaobaidebug.top/image/2021-2-11/1613045090544-%E7%8A%B6%E6%80%81%E7%A0%81%E8%A1%A8%E6%A0%BC.jpg\\",\\"https://cdn.xiaobaidebug.top/image/2021-2-20/1613777745819-502%E7%9A%84%E8%BF%87%E7%A8%8B.jpg\\"],\\"datePublished\\":\\"2021-02-25T22:57:55.000Z\\",\\"dateModified\\":\\"2024-02-19T03:57:35.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"小白debug\\",\\"url\\":\\"https://xiaobaidebug.top/\\"}]}"],["link",{"rel":"canonical","href":"https://golangguide.top/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/%E6%A0%B8%E5%BF%83%E7%9F%A5%E8%AF%86%E7%82%B9/%E7%A1%AC%E6%A0%B8%EF%BC%81%E6%BC%AB%E7%94%BB%E5%9B%BE%E8%A7%A3HTTP%E7%9F%A5%E8%AF%86%E7%82%B9_%E9%9D%A2%E8%AF%95%E9%A2%98.html"}],["meta",{"property":"og:url","content":"https://golangguide.top/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/%E6%A0%B8%E5%BF%83%E7%9F%A5%E8%AF%86%E7%82%B9/%E7%A1%AC%E6%A0%B8%EF%BC%81%E6%BC%AB%E7%94%BB%E5%9B%BE%E8%A7%A3HTTP%E7%9F%A5%E8%AF%86%E7%82%B9_%E9%9D%A2%E8%AF%95%E9%A2%98.html"}],["meta",{"property":"og:site_name","content":"golang全栈指南"}],["meta",{"property":"og:title","content":"硬核！漫画图解HTTP基础+面试题"}],["meta",{"property":"og:description","content":" 文章持续更新，可以微信搜一搜「小白 debug」第一时间阅读，回复【面试】获免费面试题集。本文已经收录在 GitHub https://github.com/xiaobaiTech/golangFamily , 有大厂面试完整考点和成长路线，欢迎 Star。 什么是 HTTP HTTP 全称超⽂文本传输协议，也就是HyperText Transfer..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2024-02-19T03:57:35.000Z"}],["meta",{"property":"article:published_time","content":"2021-02-25T22:57:55.000Z"}],["meta",{"property":"article:modified_time","content":"2024-02-19T03:57:35.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"硬核！漫画图解HTTP基础+面试题\\",\\"image\\":[\\"\\"],\\"datePublished\\":\\"2021-02-25T22:57:55.000Z\\",\\"dateModified\\":\\"2024-02-19T03:57:35.000Z\\",\\"author\\":[]}"]]},"headers":[{"level":2,"title":"URL 是什么","slug":"url-是什么","link":"#url-是什么","children":[]},{"level":2,"title":"URL 和 URI 的区别","slug":"url-和-uri-的区别","link":"#url-和-uri-的区别","children":[]},{"level":2,"title":"GET","slug":"get","link":"#get","children":[]},{"level":2,"title":"HEAD：","slug":"head","link":"#head","children":[]},{"level":2,"title":"POST","slug":"post","link":"#post","children":[]},{"level":2,"title":"PUT：","slug":"put","link":"#put","children":[]},{"level":2,"title":"DELETE：","slug":"delete","link":"#delete","children":[]},{"level":2,"title":"OPTIONS：","slug":"options","link":"#options","children":[{"level":3,"title":"options 是什么","slug":"options-是什么","link":"#options-是什么","children":[]},{"level":3,"title":"什么时候需要使用 options","slug":"什么时候需要使用-options","link":"#什么时候需要使用-options","children":[]},{"level":3,"title":"什么是简单请求和复杂请求。","slug":"什么是简单请求和复杂请求。","link":"#什么是简单请求和复杂请求。","children":[]},{"level":3,"title":"什么是跨域","slug":"什么是跨域","link":"#什么是跨域","children":[]},{"level":3,"title":"options 带来什么问题","slug":"options-带来什么问题","link":"#options-带来什么问题","children":[]},{"level":3,"title":"如何优化 options","slug":"如何优化-options","link":"#如何优化-options","children":[]}]},{"level":2,"title":"状态码是什么","slug":"状态码是什么","link":"#状态码是什么","children":[]},{"level":2,"title":"状态码流程","slug":"状态码流程","link":"#状态码流程","children":[]},{"level":2,"title":"常见状态码介绍","slug":"常见状态码介绍","link":"#常见状态码介绍","children":[]},{"level":2,"title":"Content-Length","slug":"content-length","link":"#content-length","children":[]},{"level":2,"title":"Range","slug":"range","link":"#range","children":[]},{"level":2,"title":"Connection","slug":"connection","link":"#connection","children":[{"level":3,"title":"长连接和短连接","slug":"长连接和短连接","link":"#长连接和短连接","children":[]},{"level":3,"title":"HTTP 为什么要使用长连接","slug":"http-为什么要使用长连接","link":"#http-为什么要使用长连接","children":[]}]},{"level":2,"title":"Cookies","slug":"cookies","link":"#cookies","children":[{"level":3,"title":"Cookies 是什么","slug":"cookies-是什么","link":"#cookies-是什么","children":[]},{"level":3,"title":"Cookie 的作用","slug":"cookie-的作用","link":"#cookie-的作用","children":[]}]},{"level":2,"title":"Referrer Policy 和 Referrer","slug":"referrer-policy-和-referrer","link":"#referrer-policy-和-referrer","children":[{"level":3,"title":"Referrer 是什么","slug":"referrer-是什么","link":"#referrer-是什么","children":[]},{"level":3,"title":"Referrer Policy 是什么","slug":"referrer-policy-是什么","link":"#referrer-policy-是什么","children":[]}]},{"level":2,"title":"Cache-control","slug":"cache-control","link":"#cache-control","children":[{"level":3,"title":"什么是 cache-control","slug":"什么是-cache-control","link":"#什么是-cache-control","children":[]},{"level":3,"title":"什么是浏览器缓存","slug":"什么是浏览器缓存","link":"#什么是浏览器缓存","children":[]},{"level":3,"title":"常见的缓存控制策略","slug":"常见的缓存控制策略","link":"#常见的缓存控制策略","children":[]}]},{"level":2,"title":"ETag","slug":"etag","link":"#etag","children":[]}],"git":{"createdTime":1708315055000,"updatedTime":1708315055000,"contributors":[{"name":"xiaobai","email":"xiaobaidebug@gmail.com","commits":1}]},"readingTime":{"minutes":26.55,"words":7965},"filePathRelative":"计算机基础/网络基础/核心知识点/硬核！漫画图解HTTP知识点+面试题.md","localizedDate":"2021年2月25日","autoDesc":true}');export{v as comp,T as data};
