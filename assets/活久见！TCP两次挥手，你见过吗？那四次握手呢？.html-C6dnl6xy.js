import{_ as e}from"./plugin-vue_export-helper-DlAUqK2U.js";import{r as p,o,c,a as n,b as a,d as t,e as i}from"./app-Dn9HY-uS.js";const l={},d=i(`<p>我们都知道，TCP 是个<strong>面向连接的、可靠的、基于字节流的传输层</strong>通信协议。</p><figure><img src="https://cdn.xiaobaidebug.top/image/tcp是什么2.png" alt="TCP是什么" tabindex="0" loading="lazy"><figcaption>TCP是什么</figcaption></figure><p>那这里面提到的&quot;<strong>面向连接</strong>&quot;，意味着需要 建立连接，使用连接，释放连接。</p><p><strong>建立连接</strong>是指我们熟知的<strong>TCP 三次握手</strong>。</p><p>而<strong>使用连接</strong>，则是通过一发送、一确认的形式，进行<strong>数据传输</strong>。</p><p>还有就是<strong>释放连接</strong>，也就是我们常见的<strong>TCP 四次挥手</strong>。</p><p><strong>TCP 四次挥手</strong>大家应该比较了解了，但大家见过<strong>三次挥手</strong>吗？还有<strong>两次挥手</strong>呢？</p><p>都见过？ 那<strong>四次握手</strong>呢？</p><p>今天这个话题，不想只是猎奇，也不想搞冷知识。</p><p>我们从四次挥手开始说起，搞点实用的知识点。</p><br><h1 id="tcp-四次挥手" tabindex="-1"><a class="header-anchor" href="#tcp-四次挥手"><span>TCP 四次挥手</span></a></h1><p>简单回顾下 TCP 四次挥手。</p><figure><img src="https://cdn.xiaobaidebug.top/image/TCP四次挥手7.png" alt="TCP四次挥手" tabindex="0" loading="lazy"><figcaption>TCP四次挥手</figcaption></figure><p>正常情况下。只要数据传输完了，<strong>不管是客户端还是服务端，都可以主动发起四次挥手</strong>，释放连接。</p><p>就跟上图画的一样，假设，这次四次挥手是由客户端主动发起的，那它就是<strong>主动方</strong>。服务器是被动接收客户端的挥手请求的，叫<strong>被动方</strong>。</p><p>客户端和服务器，一开始，都是处于<code>ESTABLISHED</code>状态。</p><p><strong>第一次挥手</strong>：一般情况下，主动方执行<code>close()</code>或 <code>shutdown()</code>方法，会发个<code>FIN报文</code>出来，表示&quot;<strong>我不再发送数据了</strong>&quot;。</p><p><strong>第二次挥手</strong>：在收到主动方的<code>FIN</code>报文后，被动方立马回应一个<code>ACK</code>，意思是&quot;我收到你的 FIN 了，也知道你不再发数据了&quot;。</p><p>上面提到的是<strong>主动方</strong>不再发送数据了。但如果这时候，<strong>被动方</strong>还有数据要发，那就继续发。注意，虽然第二次和第三次挥手之间，被动方是能发数据到主动方的，但主动方能不能正常收就不一定了，这个待会说。</p><p><strong>第三次挥手</strong>：在被动方在感知到第二次挥手之后，会做了一系列的收尾工作，最后也调用一个 <code>close()</code>, 这时候就会发出第三次挥手的 <code>FIN-ACK</code>。</p><p><strong>第四次挥手</strong>：主动方回一个<code>ACK</code>，意思是收到了。</p><p>其中第一次挥手和第三次挥手，都是我们在应用程序中主动触发的（比如调用<code>close()</code>方法），也就是我们平时写代码需要关注的地方。</p><p>第二和第四次挥手，都是内核协议栈自动帮我们完成的，我们写代码的时候碰不到这地方，因此也不需要太关心。</p><p>另外不管是主动还是被动，每方发出了一个 <code>FIN</code> 和一个<code>ACK</code> 。也收到了一个 <code>FIN</code> 和一个<code>ACK</code> 。<strong>这一点大家关注下，待会还会提到。</strong></p><h2 id="fin-一定要程序执行-close-或-shutdown-才能发出吗" tabindex="-1"><a class="header-anchor" href="#fin-一定要程序执行-close-或-shutdown-才能发出吗"><span>FIN 一定要程序执行 close()或 shutdown()才能发出吗？</span></a></h2><p><strong>不一定</strong>。一般情况下，通过对<code>socket</code>执行 <code>close()</code> 或 <code>shutdown()</code> 方法会发出<code>FIN</code>。但实际上，只要应用程序退出，不管是<strong>主动</strong>退出，还是<strong>被动</strong>退出（因为一些莫名其妙的原因被<code>kill</code>了）, <strong>都会</strong>发出 <code>FIN</code>。</p><blockquote><p>FIN 是指&quot;我不再发送数据&quot;，因此<code>shutdown()</code> 关闭读不会给对方发 FIN, 关闭写才会发 FIN。</p></blockquote><br><h2 id="如果机器上-fin-wait-2-状态特别多-是为什么" tabindex="-1"><a class="header-anchor" href="#如果机器上-fin-wait-2-状态特别多-是为什么"><span>如果机器上 FIN-WAIT-2 状态特别多，是为什么</span></a></h2><p>根据上面的四次挥手图，可以看出，<code>FIN-WAIT-2</code>是<strong>主动方</strong>那边的状态。</p><p>处于这个状态的程序，一直在等<strong>第三次挥手</strong>的<code>FIN</code>。而第三次挥手需要由被动方在代码里执行<code>close()</code> 发出。</p><p>因此当机器上<code>FIN-WAIT-2</code>状态特别多，那一般来说，另外一台机器上会有大量的 <code>CLOSE_WAIT</code>。需要检查有大量的 <code>CLOSE_WAIT</code>的那台机器，为什么迟迟不愿调用<code>close()</code>关闭连接。</p><p>所以，如果机器上<code>FIN-WAIT-2</code>状态特别多，一般是因为对端一直不执行<code>close()</code>方法发出第三次挥手。</p><figure><img src="https://cdn.xiaobaidebug.top/image/FIN-WAIT-2特别多的原因.png" alt="FIN-WAIT-2特别多的原因" tabindex="0" loading="lazy"><figcaption>FIN-WAIT-2特别多的原因</figcaption></figure><br><h2 id="主动方在-close-之后收到的数据-会怎么处理" tabindex="-1"><a class="header-anchor" href="#主动方在-close-之后收到的数据-会怎么处理"><span>主动方在 close 之后收到的数据，会怎么处理</span></a></h2><p>之前写的一篇文章《代码执行 send 成功后，数据就发出去了吗？》中，从源码的角度提到了，<strong>一般情况下</strong>，程序主动执行<code>close()</code>的时候；</p><ul><li>如果当前连接对应的<code>socket</code>的<strong>接收缓冲区</strong>有数据，会发<code>RST</code>。</li><li>如果<strong>发送缓冲区</strong>有数据，那会等待发送完，再发第一次挥手的<code>FIN</code>。</li></ul><p>大家知道，TCP 是<strong>全双工通信</strong>，意思是发送数据的同时，还可以接收数据。</p><p><code>Close()</code>的含义是，此时要同时<strong>关闭发送和接收</strong>消息的功能。</p><p>也就是说，虽然<strong>理论上</strong>，第二次和第三次挥手之间，被动方是可以传数据给主动方的。</p><p>但如果 主动方的四次挥手是通过 <code>close()</code> 触发的，那主动方是不会去收这个消息的。而且还会回一个 <code>RST</code>。直接结束掉这次连接。</p><figure><img src="https://cdn.xiaobaidebug.top/image/close()触发TCP四次挥手5.png" alt="close()触发TCP四次挥手" tabindex="0" loading="lazy"><figcaption>close()触发TCP四次挥手</figcaption></figure><br><h2 id="第二第三次挥手之间-不能传输数据吗" tabindex="-1"><a class="header-anchor" href="#第二第三次挥手之间-不能传输数据吗"><span>第二第三次挥手之间，不能传输数据吗？</span></a></h2><p>也不是。前面提到<code>Close()</code>的含义是，要同时<strong>关闭发送和接收</strong>消息的功能。</p><p>那如果能做到<strong>只关闭发送消息</strong>，<strong>不关闭接收消息</strong>的功能，那就能继续收消息了。这种 <code>half-close</code> 的功能，通过调用<code>shutdown()</code> 方法就能做到。</p><div class="language-c line-numbers-mode" data-ext="c" data-title="c"><pre class="language-c"><code><span class="token keyword">int</span> <span class="token function">shutdown</span><span class="token punctuation">(</span><span class="token keyword">int</span> sock<span class="token punctuation">,</span> <span class="token keyword">int</span> howto<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><blockquote><p>其中 howto 为断开方式。有以下取值：</p><ul><li>SHUT_RD：关闭读。这时应用层不应该再尝试接收数据，内核协议栈中就算接收缓冲区收到数据也会被丢弃。</li><li>SHUT_WR：关闭写。如果发送缓冲区中还有数据没发，会将将数据传递到目标主机。</li><li>SHUT_RDWR：关闭读和写。相当于<code>close()</code>了。</li></ul></blockquote><figure><img src="https://cdn.xiaobaidebug.top/image/shutdown触发的TCP四次挥手.png" alt="shutdown触发的TCP四次挥手" tabindex="0" loading="lazy"><figcaption>shutdown触发的TCP四次挥手</figcaption></figure><br><h2 id="怎么知道对端-socket-执行了-close-还是-shutdown" tabindex="-1"><a class="header-anchor" href="#怎么知道对端-socket-执行了-close-还是-shutdown"><span>怎么知道对端 socket 执行了 close 还是 shutdown</span></a></h2><p>不管<strong>主动</strong>关闭方调用的是<code>close()</code>还是<code>shutdown()</code>，对于被动方来说，收到的就只有一个<code>FIN</code>。</p><p><strong>被动</strong>关闭方<strong>就懵了</strong>，&quot;我怎么知道对方让不让我继续发数据？&quot;</p><figure><img src="https://cdn.xiaobaidebug.top/image/e18d20c94006dfe0-feec70b0eb485633-f0e01cf6d9cce2bccba34029f1ca10e0-20210808141929988.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>其实，大可不必纠结，该发就发。</p><p>第二次挥手和第三次挥手之间，如果<strong>被动</strong>关闭方想发数据，那么在代码层面上，就是执行了 <code>send()</code> 方法。</p><div class="language-c line-numbers-mode" data-ext="c" data-title="c"><pre class="language-c"><code><span class="token keyword">int</span> <span class="token function">send</span><span class="token punctuation">(</span> SOCKET s<span class="token punctuation">,</span><span class="token keyword">const</span> <span class="token keyword">char</span><span class="token operator">*</span> buf<span class="token punctuation">,</span><span class="token keyword">int</span> len<span class="token punctuation">,</span><span class="token keyword">int</span> flags<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p><code>send()</code> 会把数据拷贝到本机的<strong>发送缓冲区</strong>。如果发送缓冲区没出问题，都能拷贝进去，所以正常情况下，<code>send()</code><strong>一般</strong>都会返回成功。</p><figure><img src="https://cdn.xiaobaidebug.top/image/tcp_sendmsg逻辑2.png" alt="tcp_sendmsg逻辑" tabindex="0" loading="lazy"><figcaption>tcp_sendmsg逻辑</figcaption></figure><p>然后<strong>被动方</strong>内核协议栈会把数据发给<strong>主动</strong>关闭方。</p><ul><li><p>如果上一次<strong>主动</strong>关闭方调用的是<code>shutdown(socket_fd, SHUT_WR)</code>。那此时，<strong>主动关闭方</strong>不再发送消息，但能接收<strong>被动方</strong>的消息，一切如常，皆大欢喜。</p></li><li><p>如果上一次<strong>主动</strong>关闭方调用的是<code>close()</code>。那<strong>主动方</strong>在收到<strong>被动方</strong>的数据后会直接<strong>丢弃</strong>，然后回一个<code>RST</code>。</p></li></ul><p>针对第二种情况。</p><p>被动方<strong>内核协议栈</strong>收到了<code>RST</code>，会把连接关闭。但内核连接关闭了，应用层也不知道（除非被通知）。</p><p>此时被动方<strong>应用层</strong>接下来的操作，无非就是<strong>读或写</strong>。</p><ul><li><p>如果是读，则会返回<code>RST</code>的报错，也就是我们常见的<code>Connection reset by peer</code>。</p></li><li><p>如果是写，那么程序会产生<code>SIGPIPE</code>信号，应用层代码可以捕获并处理信号，如果不处理，则默认情况下进程会终止，异常退出。</p></li></ul><br><p><strong>总结一下</strong>，当被动关闭方 <code>recv()</code> 返回<code>EOF</code>时，说明主动方通过 <code>close()</code>或 <code>shutdown(fd, SHUT_WR)</code> 发起了第一次挥手。</p><p>如果此时被动方执行<strong>两次</strong> <code>send()</code>。</p><ul><li><p>第一次<code>send()</code>, 一般会成功返回。</p></li><li><p>第二次<code>send()</code>时。如果主动方是通过 <code>shutdown(fd, SHUT_WR)</code> 发起的第一次挥手，那此时<code>send()</code>还是会成功。如果主动方通过 <code>close()</code>发起的第一次挥手，那此时会产生<code>SIGPIPE</code>信号，进程默认会终止，异常退出。不想异常退出的话，记得捕获处理这个信号。</p></li></ul><br><h2 id="如果被动方一直不发第三次挥手-会怎么样" tabindex="-1"><a class="header-anchor" href="#如果被动方一直不发第三次挥手-会怎么样"><span>如果被动方一直不发第三次挥手，会怎么样</span></a></h2><p>第三次挥手，是由<strong>被动方</strong>主动触发的，比如调用<code>close()</code>。</p><p>如果由于代码错误或者其他一些原因，被动方就是不执行第三次挥手。</p><p>这时候，主动方会根据自身第一次挥手的时候用的是 <code>close()</code> 还是 <code>shutdown(fd, SHUT_WR)</code> ，有不同的行为表现。</p><ul><li><p>如果是 <code>shutdown(fd, SHUT_WR)</code> ，说明主动方其实只关闭了写，但还可以读，此时会一直处于 <code>FIN-WAIT-2</code>， 死等被动方的第三次挥手。</p></li><li><p>如果是 <code>close()</code>， 说明主动方读写都关闭了，这时候会处于 <code>FIN-WAIT-2</code>一段时间，这个时间由 <code>net.ipv4.tcp_fin_timeout</code> 控制，一般是 <code>60s</code>，这个值正好跟<code>2MSL</code>一样 。<strong>超过这段时间之后，状态不会变成 <code>TIME-WAIT</code>，而是直接变成<code>CLOSED</code>。</strong></p></li></ul><div class="language-bash line-numbers-mode" data-ext="sh" data-title="sh"><pre class="language-bash"><code><span class="token comment"># cat /proc/sys/net/ipv4/tcp_fin_timeout</span>
<span class="token number">60</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><figure><img src="https://cdn.xiaobaidebug.top/image/一直不发第三次挥手的情况3.png" alt="一直不发第三次挥手的情况" tabindex="0" loading="lazy"><figcaption>一直不发第三次挥手的情况</figcaption></figure><br><h1 id="tcp-三次挥手" tabindex="-1"><a class="header-anchor" href="#tcp-三次挥手"><span>TCP 三次挥手</span></a></h1><p>四次挥手聊完了，那有没有可能出现三次挥手？</p><p><strong>是可能的。</strong></p><p>我们知道，TCP 四次挥手里，第二次和第三次挥手之间，是有可能有数据传输的。第三次挥手的目的是为了告诉主动方，&quot;被动方没有数据要发了&quot;。</p><p>所以，在第一次挥手之后，如果被动方没有数据要发给主动方。第二和第三次挥手是<strong>有可能</strong>合并传输的。这样就出现了三次挥手。</p><figure><img src="https://cdn.xiaobaidebug.top/image/TCP三次挥手.png" alt="TCP三次挥手" tabindex="0" loading="lazy"><figcaption>TCP三次挥手</figcaption></figure><br><h2 id="如果有数据要发-就不能是三次挥手了吗" tabindex="-1"><a class="header-anchor" href="#如果有数据要发-就不能是三次挥手了吗"><span>如果有数据要发，就不能是三次挥手了吗</span></a></h2><p>上面提到的是<strong>没有数据要发</strong>的情况，如果第二、第三次挥手之间<strong>有数据</strong>要发，就不可能变成三次挥手了吗？</p><p><strong>并不是</strong>。TCP 中还有个特性叫<strong>延迟确认</strong>。可以简单理解为：<strong>接收方收到数据以后不需要立刻马上回复 ACK 确认包。</strong></p><p>在此基础上，<strong>不是每一次发送数据包都能对应收到一个 <code>ACK</code> 确认包，因为接收方可以合并确认。</strong></p><p>而这个合并确认，放在四次挥手里，可以把第二次挥手、第三次挥手，以及他们之间的数据传输都合并在一起发送。因此也就出现了三次挥手。</p><figure><img src="https://cdn.xiaobaidebug.top/image/TCP三次挥手延迟确认.png" alt="TCP三次挥手延迟确认" tabindex="0" loading="lazy"><figcaption>TCP三次挥手延迟确认</figcaption></figure><br><h1 id="tcp-两次挥手" tabindex="-1"><a class="header-anchor" href="#tcp-两次挥手"><span>TCP 两次挥手</span></a></h1><p>前面在四次挥手中提到，关闭的时候双方都<strong>发出了一个 FIN 和收到了一个 ACK</strong>。</p><p>正常情况下 TCP 连接的两端，是不同<strong>IP+端口</strong>的进程。</p><p>但如果 TCP 连接的两端，<strong>IP+端口</strong>是一样的情况下，那么在关闭连接的时候，也同样做到了<strong>一端发出了一个 FIN，也收到了一个 ACK</strong>，只不过正好这两端其实是<code>同一个socket</code> 。</p><figure><img src="https://cdn.xiaobaidebug.top/image/TCP两次挥手2.png" alt="TCP两次挥手" tabindex="0" loading="lazy"><figcaption>TCP两次挥手</figcaption></figure><p>而这种两端<strong>IP+端口</strong>都一样的连接，叫<strong>TCP 自连接</strong>。</p><p>是的，你没看错，我也没打错别字。<strong>同一个 socket 确实可以自己连自己，形成一个连接。</strong></p><br><h2 id="一个-socket-能建立连接" tabindex="-1"><a class="header-anchor" href="#一个-socket-能建立连接"><span>一个 socket 能建立连接？</span></a></h2><p>上面提到了，同一个客户端 socket，自己对自己发起连接请求。是可以成功建立连接的。这样的连接，叫<strong>TCP 自连接</strong>。</p><p>下面我们尝试下复现。</p><p>注意我是在以下系统进行的实验。在<code>mac</code>上多半无法复现。</p><div class="language-bash line-numbers-mode" data-ext="sh" data-title="sh"><pre class="language-bash"><code><span class="token comment">#  cat /etc/os-release</span>
<span class="token assign-left variable">NAME</span><span class="token operator">=</span><span class="token string">&quot;CentOS Linux&quot;</span>
<span class="token assign-left variable">VERSION</span><span class="token operator">=</span><span class="token string">&quot;7 (Core)&quot;</span>
<span class="token assign-left variable">ID</span><span class="token operator">=</span><span class="token string">&quot;centos&quot;</span>
<span class="token assign-left variable">ID_LIKE</span><span class="token operator">=</span><span class="token string">&quot;rhel fedora&quot;</span>
<span class="token assign-left variable">VERSION_ID</span><span class="token operator">=</span><span class="token string">&quot;7&quot;</span>
<span class="token assign-left variable">PRETTY_NAME</span><span class="token operator">=</span><span class="token string">&quot;CentOS Linux 7 (Core)&quot;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>通过<code>nc</code>命令可以很简单的创建一个<strong>TCP 自连接</strong></p><div class="language-bash line-numbers-mode" data-ext="sh" data-title="sh"><pre class="language-bash"><code><span class="token comment"># nc -p 6666 127.0.0.1 6666</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>上面的 <code>-p</code> 可以指定源端口号。也就是指定了一个端口号为<code>6666</code>的客户端去连接 <code>127.0.0.1:6666</code> 。</p><div class="language-bash line-numbers-mode" data-ext="sh" data-title="sh"><pre class="language-bash"><code><span class="token comment"># netstat -nt | grep 6666</span>
tcp        <span class="token number">0</span>      <span class="token number">0</span> <span class="token number">127.0</span>.0.1:6666          <span class="token number">127.0</span>.0.1:6666          ESTABLISHED
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>整个过程中，都没有服务端参与</strong>。可以抓个包看下。</p><figure><img src="https://cdn.xiaobaidebug.top/image/image-20210810093309117.png" alt="image-20210810093309117" tabindex="0" loading="lazy"><figcaption>image-20210810093309117</figcaption></figure><p>可以看到，<strong>相同的 socket，自己连自己的时候，握手是三次的。挥手是两次的。</strong></p><figure><img src="https://cdn.xiaobaidebug.top/image/TCP自连接2.png" alt="TCP自连接" tabindex="0" loading="lazy"><figcaption>TCP自连接</figcaption></figure><p>上面这张图里，左右都是同一个客户端，把它画成两个是为了方便大家理解状态的迁移。</p><p>我们可以拿自连接的握手状态<strong>对比下</strong>正常情况下的 TCP 三次握手。</p><figure><img src="https://cdn.xiaobaidebug.top/image/正常情况下的TCP三次握手2.png" alt="正常情况下的TCP三次握手" tabindex="0" loading="lazy"><figcaption>正常情况下的TCP三次握手</figcaption></figure><p>看了自连接的状态图，再看看下面几个问题。</p><br><h3 id="一端发出第一次握手后-如果又收到了第一次握手的-syn-包-tcp-连接状态会怎么变化" tabindex="-1"><a class="header-anchor" href="#一端发出第一次握手后-如果又收到了第一次握手的-syn-包-tcp-连接状态会怎么变化"><span>一端发出第一次握手后，如果又收到了第一次握手的 SYN 包，TCP 连接状态会怎么变化？</span></a></h3><p>第一次握手过后，连接状态就变成了<code>SYN_SENT</code>状态。如果此时又收到了第一次握手的 SYN 包，那么连接状态就会从<code>SYN_SENT</code>状态变成<code>SYN_RCVD</code>。</p><div class="language-c line-numbers-mode" data-ext="c" data-title="c"><pre class="language-c"><code><span class="token comment">// net/ipv4/tcp_input.c</span>
<span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">tcp_rcv_synsent_state_process</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token comment">// SYN_SENT状态下，收到SYN包</span>
	<span class="token keyword">if</span> <span class="token punctuation">(</span>th<span class="token operator">-&gt;</span>syn<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// 状态置为 SYN_RCVD</span>
		<span class="token function">tcp_set_state</span><span class="token punctuation">(</span>sk<span class="token punctuation">,</span> TCP_SYN_RECV<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span>

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><br><h3 id="一端发出第二次握手后-如果又收到第二次握手的-syn-ack-包-tcp-连接状态会怎么变化" tabindex="-1"><a class="header-anchor" href="#一端发出第二次握手后-如果又收到第二次握手的-syn-ack-包-tcp-连接状态会怎么变化"><span>一端发出第二次握手后，如果又收到第二次握手的 SYN+ACK 包，TCP 连接状态会怎么变化？</span></a></h3><p>第二握手过后，连接状态就变为<code>SYN_RCVD</code>了，此时如果再收到第二次握手的<code>SYN+ACK</code>包。连接状态会变为<code>ESTABLISHED</code>。</p><div class="language-c line-numbers-mode" data-ext="c" data-title="c"><pre class="language-c"><code><span class="token comment">// net/ipv4/tcp_input.c</span>
<span class="token keyword">int</span> <span class="token function">tcp_rcv_state_process</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token comment">// 前面省略很多逻辑，能走到这就认为肯定有ACK</span>
	<span class="token keyword">if</span> <span class="token punctuation">(</span>true<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// 判断下这个ack是否合法</span>
		<span class="token keyword">int</span> acceptable <span class="token operator">=</span> <span class="token function">tcp_ack</span><span class="token punctuation">(</span>sk<span class="token punctuation">,</span> skb<span class="token punctuation">,</span> FLAG_SLOWPATH <span class="token operator">|</span> FLAG_UPDATE_TS_RECENT<span class="token punctuation">)</span> <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">;</span>
		<span class="token keyword">switch</span> <span class="token punctuation">(</span>sk<span class="token operator">-&gt;</span>sk_state<span class="token punctuation">)</span> <span class="token punctuation">{</span>
		<span class="token keyword">case</span> TCP_SYN_RECV<span class="token operator">:</span>
			<span class="token keyword">if</span> <span class="token punctuation">(</span>acceptable<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// 状态从 SYN_RCVD 转为 ESTABLISHED</span>
				<span class="token function">tcp_set_state</span><span class="token punctuation">(</span>sk<span class="token punctuation">,</span> TCP_ESTABLISHED<span class="token punctuation">)</span><span class="token punctuation">;</span>
			<span class="token punctuation">}</span>
		<span class="token punctuation">}</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><br><h3 id="一端第一次挥手后-又收到第一次挥手的包-tcp-连接状态会怎么变化" tabindex="-1"><a class="header-anchor" href="#一端第一次挥手后-又收到第一次挥手的包-tcp-连接状态会怎么变化"><span>一端第一次挥手后，又收到第一次挥手的包，TCP 连接状态会怎么变化？</span></a></h3><p>第一次挥手过后，一端状态就会变成 <code>FIN-WAIT-1</code>。正常情况下，是要等待第二次挥手的<code>ACK</code>。但实际上却等来了 一个第一次挥手的 <code>FIN</code>包， 这时候连接状态就会变为<code>CLOSING</code>。</p><div class="language-c line-numbers-mode" data-ext="c" data-title="c"><pre class="language-c"><code><span class="token comment">// net/</span>
<span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">tcp_fin</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">sock</span> <span class="token operator">*</span>sk<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
	<span class="token keyword">switch</span> <span class="token punctuation">(</span>sk<span class="token operator">-&gt;</span>sk_state<span class="token punctuation">)</span> <span class="token punctuation">{</span>
	<span class="token keyword">case</span> TCP_FIN_WAIT1<span class="token operator">:</span>
		<span class="token function">tcp_send_ack</span><span class="token punctuation">(</span>sk<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// FIN-WAIT-1状态下，收到了FIN，转为 CLOSING</span>
		<span class="token function">tcp_set_state</span><span class="token punctuation">(</span>sk<span class="token punctuation">,</span> TCP_CLOSING<span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token keyword">break</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这可以说是<strong>隐藏剧情</strong>了。</p><p><code>CLOSING</code> 很少见，除了出现在<strong>自连接关闭</strong>外，一般还会出现在 TCP 两端<strong>同时关闭</strong>连接的情况下。</p><p>处于<code>CLOSING</code>状态下时，只要再收到一个<code>ACK</code>，就能进入 <code>TIME-WAIT</code> 状态，然后等个<code>2MSL</code>，连接就彻底断开了。这跟正常的四次挥手还是有些差别的。大家可以滑到文章开头的 TCP 四次挥手再对比下。</p><br><h3 id="代码复现自连接" tabindex="-1"><a class="header-anchor" href="#代码复现自连接"><span>代码复现自连接</span></a></h3><p>可能大家会产生怀疑，这是不是<code>nc</code>这个软件本身的<code>bug</code>。</p><p>那我们可以尝试下用<code>strace</code>看看它内部都做了啥。</p><div class="language-bash line-numbers-mode" data-ext="sh" data-title="sh"><pre class="language-bash"><code><span class="token comment"># strace nc -p 6666 127.0.0.1 6666</span>
// <span class="token punctuation">..</span>.
socket<span class="token punctuation">(</span>AF_INET, SOCK_STREAM, IPPROTO_TCP<span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token number">3</span>
fcntl<span class="token punctuation">(</span><span class="token number">3</span>, F_GETFL<span class="token punctuation">)</span>                       <span class="token operator">=</span> 0x2 <span class="token punctuation">(</span>flags O_RDWR<span class="token punctuation">)</span>
fcntl<span class="token punctuation">(</span><span class="token number">3</span>, F_SETFL, O_RDWR<span class="token operator">|</span>O_NONBLOCK<span class="token punctuation">)</span>    <span class="token operator">=</span> <span class="token number">0</span>
setsockopt<span class="token punctuation">(</span><span class="token number">3</span>, SOL_SOCKET, SO_REUSEADDR, <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span>, <span class="token number">4</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token number">0</span>
bind<span class="token punctuation">(</span><span class="token number">3</span>, <span class="token punctuation">{</span>sa_family<span class="token operator">=</span>AF_INET, <span class="token assign-left variable">sin_port</span><span class="token operator">=</span>htons<span class="token punctuation">(</span><span class="token number">6666</span><span class="token punctuation">)</span>, <span class="token assign-left variable">sin_addr</span><span class="token operator">=</span>inet_addr<span class="token punctuation">(</span><span class="token string">&quot;0.0.0.0&quot;</span><span class="token punctuation">)</span><span class="token punctuation">}</span>, <span class="token number">16</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token number">0</span>
connect<span class="token punctuation">(</span><span class="token number">3</span>, <span class="token punctuation">{</span>sa_family<span class="token operator">=</span>AF_INET, <span class="token assign-left variable">sin_port</span><span class="token operator">=</span>htons<span class="token punctuation">(</span><span class="token number">6666</span><span class="token punctuation">)</span>, <span class="token assign-left variable">sin_addr</span><span class="token operator">=</span>inet_addr<span class="token punctuation">(</span><span class="token string">&quot;127.0.0.1&quot;</span><span class="token punctuation">)</span><span class="token punctuation">}</span>, <span class="token number">16</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token parameter variable">-1</span> EINPROGRESS <span class="token punctuation">(</span>Operation now <span class="token keyword">in</span> progress<span class="token punctuation">)</span>
// <span class="token punctuation">..</span>.
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>无非就是以创建了一个客户端<code>socket</code>句柄，然后对这个句柄执行 <code>bind</code>, 绑定它的端口号是<code>6666</code>，然后再向 <code>127.0.0.1:6666</code>发起<code>connect</code>方法。</p><p>我们可以尝试用<code>C语言</code>去复现一遍。</p><p><strong>下面的代码，只用于复现问题。直接跳过也完全不影响阅读。</strong></p><div class="language-c line-numbers-mode" data-ext="c" data-title="c"><pre class="language-c"><code><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;unistd.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;sys/socket.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdlib.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;arpa/inet.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;ctype.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;string.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;strings.h&gt;</span></span>


<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">int</span> lfd<span class="token punctuation">,</span> cfd<span class="token punctuation">;</span>
    <span class="token keyword">struct</span> <span class="token class-name">sockaddr_in</span> serv_addr<span class="token punctuation">,</span> clie_addr<span class="token punctuation">;</span>
    <span class="token class-name">socklen_t</span> clie_addr_len<span class="token punctuation">;</span>
    <span class="token keyword">char</span> buf<span class="token punctuation">[</span>BUFSIZ<span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token keyword">int</span> n <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> ret <span class="token operator">=</span> <span class="token number">0</span> <span class="token punctuation">;</span>
    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">&quot;This is a client \\n&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment">/*Step 1: 创建客户端端socket描述符cfd*/</span>
    cfd <span class="token operator">=</span> <span class="token function">socket</span><span class="token punctuation">(</span>AF_INET<span class="token punctuation">,</span> SOCK_STREAM<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span>cfd <span class="token operator">==</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        <span class="token function">perror</span><span class="token punctuation">(</span><span class="token string">&quot;socket error&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">exit</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">int</span> flag<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">,</span>len<span class="token operator">=</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">if</span><span class="token punctuation">(</span> <span class="token function">setsockopt</span><span class="token punctuation">(</span>cfd<span class="token punctuation">,</span> SOL_SOCKET<span class="token punctuation">,</span> SO_REUSEADDR<span class="token punctuation">,</span> <span class="token operator">&amp;</span>flag<span class="token punctuation">,</span> len<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span>
	<span class="token punctuation">{</span>
		<span class="token function">perror</span><span class="token punctuation">(</span><span class="token string">&quot;setsockopt&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token function">exit</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>


    <span class="token function">bzero</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>clie_addr<span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>clie_addr<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    clie_addr<span class="token punctuation">.</span>sin_family <span class="token operator">=</span> AF_INET<span class="token punctuation">;</span>
    clie_addr<span class="token punctuation">.</span>sin_port <span class="token operator">=</span> <span class="token function">htons</span><span class="token punctuation">(</span><span class="token number">6666</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">inet_pton</span><span class="token punctuation">(</span>AF_INET<span class="token punctuation">,</span><span class="token string">&quot;127.0.0.1&quot;</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>clie_addr<span class="token punctuation">.</span>sin_addr<span class="token punctuation">.</span>s_addr<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment">/*Step 2: 客户端使用bind绑定客户端的IP和端口*/</span>
    ret <span class="token operator">=</span> <span class="token function">bind</span><span class="token punctuation">(</span>cfd<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">sockaddr</span><span class="token operator">*</span> <span class="token punctuation">)</span><span class="token operator">&amp;</span>clie_addr<span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>clie_addr<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span>ret <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        <span class="token function">perror</span><span class="token punctuation">(</span><span class="token string">&quot;bind error&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">exit</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token comment">/*Step 3: connect链接服务器端的IP和端口号*/</span>
    <span class="token function">bzero</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>serv_addr<span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>serv_addr<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    serv_addr<span class="token punctuation">.</span>sin_family <span class="token operator">=</span> AF_INET<span class="token punctuation">;</span>
    serv_addr<span class="token punctuation">.</span>sin_port <span class="token operator">=</span> <span class="token function">htons</span><span class="token punctuation">(</span><span class="token number">6666</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">inet_pton</span><span class="token punctuation">(</span>AF_INET<span class="token punctuation">,</span><span class="token string">&quot;127.0.0.1&quot;</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>serv_addr<span class="token punctuation">.</span>sin_addr<span class="token punctuation">.</span>s_addr<span class="token punctuation">)</span><span class="token punctuation">;</span>
    ret <span class="token operator">=</span> <span class="token function">connect</span><span class="token punctuation">(</span>cfd<span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">sockaddr</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token operator">&amp;</span>serv_addr<span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>serv_addr<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span>ret <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        <span class="token function">perror</span><span class="token punctuation">(</span><span class="token string">&quot;connect error&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">exit</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token comment">/*Step 4: 向服务器端写数据*/</span>
    <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        <span class="token function">fgets</span><span class="token punctuation">(</span>buf<span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>buf<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token constant">stdin</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">write</span><span class="token punctuation">(</span>cfd<span class="token punctuation">,</span> buf<span class="token punctuation">,</span> <span class="token function">strlen</span><span class="token punctuation">(</span>buf<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        n <span class="token operator">=</span> <span class="token function">read</span><span class="token punctuation">(</span>cfd<span class="token punctuation">,</span> buf<span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>buf<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">write</span><span class="token punctuation">(</span>STDOUT_FILENO<span class="token punctuation">,</span> buf<span class="token punctuation">,</span> n<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//写到屏幕上</span>
    <span class="token punctuation">}</span>
    <span class="token comment">/*Step 5: 关闭socket描述符*/</span>
    <span class="token function">close</span><span class="token punctuation">(</span>cfd<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>保存为 <code>client.c</code> 文件，然后执行下面命令，会发现连接成功。</p><div class="language-bash line-numbers-mode" data-ext="sh" data-title="sh"><pre class="language-bash"><code><span class="token comment"># gcc client.c -o client &amp;&amp; ./client</span>
This is a client
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><div class="language-bash line-numbers-mode" data-ext="sh" data-title="sh"><pre class="language-bash"><code><span class="token comment"># netstat -nt | grep 6666</span>
tcp        <span class="token number">0</span>      <span class="token number">0</span> <span class="token number">127.0</span>.0.1:6666          <span class="token number">127.0</span>.0.1:6666          ESTABLISHED
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>说明，这不是 nc 的 bug。事实上，这也是内核允许的一种情况。</p><br><h3 id="自连接的解决方案" tabindex="-1"><a class="header-anchor" href="#自连接的解决方案"><span>自连接的解决方案</span></a></h3><p>自连接一般不太常见，但遇到了也不难解决。</p><p>解决方案比较简单，只要能保证客户端和服务端的端口不一致就行。</p><p>事实上，我们写代码的时候一般不会去指定客户端的端口，系统会随机给客户端分配某个范围内的端口。而这个范围，可以通过下面的命令进行查询</p><div class="language-bash line-numbers-mode" data-ext="sh" data-title="sh"><pre class="language-bash"><code><span class="token comment"># cat /proc/sys/net/ipv4/ip_local_port_range</span>
<span class="token number">32768</span>   <span class="token number">60999</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>也就是只要我们的服务器端口不在<code>32768-60999</code>这个范围内，比如设置为<code>8888</code>。就可以规避掉这个问题。</p><p>另外一个解决方案，可以参考<code>golang</code>标准网络库的实现，在连接建立完成之后判断下 IP 和端口是否一致，如果遇到自连接，则断开重试。</p><div class="language-go line-numbers-mode" data-ext="go" data-title="go"><pre class="language-go"><code><span class="token keyword">func</span> <span class="token function">dialTCP</span><span class="token punctuation">(</span>net <span class="token builtin">string</span><span class="token punctuation">,</span> laddr<span class="token punctuation">,</span> raddr <span class="token operator">*</span>TCPAddr<span class="token punctuation">,</span> deadline time<span class="token punctuation">.</span>Time<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token operator">*</span>TCPConn<span class="token punctuation">,</span> <span class="token builtin">error</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
	<span class="token comment">// 如果是自连接，这里会重试</span>
	<span class="token keyword">for</span> i <span class="token operator">:=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">2</span> <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span>laddr <span class="token operator">==</span> <span class="token boolean">nil</span> <span class="token operator">||</span> laddr<span class="token punctuation">.</span>Port <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span><span class="token function">selfConnect</span><span class="token punctuation">(</span>fd<span class="token punctuation">,</span> err<span class="token punctuation">)</span> <span class="token operator">||</span> <span class="token function">spuriousENOTAVAIL</span><span class="token punctuation">(</span>err<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> i<span class="token operator">++</span> <span class="token punctuation">{</span>
		<span class="token keyword">if</span> err <span class="token operator">==</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>
			fd<span class="token punctuation">.</span><span class="token function">Close</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
		<span class="token punctuation">}</span>
		fd<span class="token punctuation">,</span> err <span class="token operator">=</span> <span class="token function">internetSocket</span><span class="token punctuation">(</span>net<span class="token punctuation">,</span> laddr<span class="token punctuation">,</span> raddr<span class="token punctuation">,</span> deadline<span class="token punctuation">,</span> syscall<span class="token punctuation">.</span>SOCK_STREAM<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token string">&quot;dial&quot;</span><span class="token punctuation">,</span> sockaddrToTCP<span class="token punctuation">)</span>
	<span class="token punctuation">}</span>
    <span class="token comment">// ...</span>
<span class="token punctuation">}</span>

<span class="token keyword">func</span> <span class="token function">selfConnect</span><span class="token punctuation">(</span>fd <span class="token operator">*</span>netFD<span class="token punctuation">,</span> err <span class="token builtin">error</span><span class="token punctuation">)</span> <span class="token builtin">bool</span> <span class="token punctuation">{</span>
	<span class="token comment">// 判断是否端口、IP一致</span>
	<span class="token keyword">return</span> l<span class="token punctuation">.</span>Port <span class="token operator">==</span> r<span class="token punctuation">.</span>Port <span class="token operator">&amp;&amp;</span> l<span class="token punctuation">.</span>IP<span class="token punctuation">.</span><span class="token function">Equal</span><span class="token punctuation">(</span>r<span class="token punctuation">.</span>IP<span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><br><h1 id="四次握手" tabindex="-1"><a class="header-anchor" href="#四次握手"><span>四次握手</span></a></h1><p>前面提到的<code>TCP</code>自连接是一个客户端自己连自己的场景。那不同客户端之间是否可以互联？</p><p>答案是<strong>可以的</strong>，有一种情况叫<strong>TCP 同时打开</strong>。</p><figure><img src="https://cdn.xiaobaidebug.top/image/TCP同时打开2.png" alt="TCP同时打开" tabindex="0" loading="lazy"><figcaption>TCP同时打开</figcaption></figure><p>大家可以对比下，<strong>TCP 同时打开</strong>在握手时的状态变化，跟 TCP 自连接是非常的像。</p><p>比如<code>SYN_SENT</code>状态下，又收到了一个<code>SYN</code>，其实就相当于自连接里，在发出了第一次握手后，又收到了第一次握手的请求。结果都是变成 <code>SYN_RCVD</code>。</p><p>在 <code>SYN_RCVD</code> 状态下收到了 <code>SYN+ACK</code>，就相当于自连接里，在发出第二次握手后，又收到第二次握手的请求，结果都是变成 <code>ESTABLISHED</code>。<strong>他们的源码其实都是同一块逻辑。</strong></p><br><h3 id="复现-tcp-同时打开" tabindex="-1"><a class="header-anchor" href="#复现-tcp-同时打开"><span>复现 TCP 同时打开</span></a></h3><p>分别在<strong>两个控制台</strong>下，分别执行下面两行命令。</p><div class="language-bash line-numbers-mode" data-ext="sh" data-title="sh"><pre class="language-bash"><code><span class="token keyword">while</span> <span class="token boolean">true</span><span class="token punctuation">;</span> <span class="token keyword">do</span> <span class="token function">nc</span> <span class="token parameter variable">-p</span> <span class="token number">2224</span> <span class="token number">127.0</span>.0.1 <span class="token number">2223</span> -v<span class="token punctuation">;</span><span class="token keyword">done</span>

<span class="token keyword">while</span> <span class="token boolean">true</span><span class="token punctuation">;</span> <span class="token keyword">do</span> <span class="token function">nc</span> <span class="token parameter variable">-p</span> <span class="token number">2223</span> <span class="token number">127.0</span>.0.1 <span class="token number">2224</span> -v<span class="token punctuation">;</span><span class="token keyword">done</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面两个命令的含义也比较简单，两个客户端互相请求连接对方的端口号，如果失败了则不停重试。</p><p>执行后看到的现象是，一开始会疯狂失败，重试。一段时间后，连接建立完成。</p><div class="language-bash line-numbers-mode" data-ext="sh" data-title="sh"><pre class="language-bash"><code><span class="token comment"># netstat -an | grep  2223</span>
Proto Recv-Q Send-Q Local Address           Foreign Address         State
tcp        <span class="token number">0</span>      <span class="token number">0</span> <span class="token number">127.0</span>.0.1:2224          <span class="token number">127.0</span>.0.1:2223          ESTABLISHED
tcp        <span class="token number">0</span>      <span class="token number">0</span> <span class="token number">127.0</span>.0.1:2223          <span class="token number">127.0</span>.0.1:2224          ESTABLISHED
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>期间抓包获得下面的结果。</p><figure><img src="https://cdn.xiaobaidebug.top/image/image-20210815090301418.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>可以看到，这里面建立连接用了四次交互。因此可以说这是通过**&quot;四次握手&quot;**建立的连接。</p><p>而且更重要的是，这里面只涉及两个客户端，<strong>没有服务端</strong>。</p><p>看到这里，不知道大家有没有跟我一样，被刷新了一波认知，对<code>socket</code>有了重新的认识。</p><p>在以前的观念里，建立连接，必须要有一个客户端和一个服务端，并且服务端还要执行一个<code>listen()</code>和一个<code>accept()</code>。而实际上，这些都不是必须的。</p><p>那么下次，面试官问你**&quot;没有<code>listen()</code>， TCP 能建立连接吗？&quot;**， 我想大家应该知道该怎么回答了。</p><p>但问题又来了，只有两个客户端，没有<code>listen()</code> ，为什么能建立<code>TCP</code>连接？</p><p>如果大家感兴趣，我们以后有机会再填上这个坑。</p><br><h1 id="总结" tabindex="-1"><a class="header-anchor" href="#总结"><span>总结</span></a></h1><ul><li><p><strong>四次挥手</strong>中，不管是程序主动执行<code>close()</code>，还是进程被杀，都有可能发出第一次挥手<code>FIN</code>包。如果机器上<code>FIN-WAIT-2</code>状态特别多，一般是因为对端一直不执行<code>close()</code>方法发出第三次挥手。</p></li><li><p><code>Close()</code>会<strong>同时关闭</strong>发送和接收消息的功能。<code>shutdown()</code> 能<strong>单独关闭</strong>发送或接受消息。</p></li><li><p>第二、第三次挥手，是有可能合在一起的。于是四次挥手就变成<strong>三次挥手</strong>了。</p></li><li><p>同一个 socket 自己连自己，会产生<strong>TCP 自连接</strong>，自连接的挥手是<strong>两次挥手</strong>。</p></li><li><p>没有<code>listen</code>，两个客户端之间也能建立连接。这种情况叫<strong>TCP 同时打开</strong>，它由<strong>四次握手</strong>产生。</p></li></ul><br><h1 id="最后" tabindex="-1"><a class="header-anchor" href="#最后"><span>最后</span></a></h1><p>今天提到的，不管是<strong>两次挥手</strong>，还是<strong>自连接</strong>，或是<strong>TCP 同时打开</strong>什么的。</p><p>咋一看，可能对日常搬砖没什么用，实际上也确实没什么用。</p><p>并且在面试上大概率也不会被问到。</p><p><strong>毕竟一般面试官也不在意茴字有几种写法。</strong></p><p>这篇文章的目的，主要是想从另外一个角度让大家重新认识下<code>socket</code>。原来<code>TCP</code>是可以自己连自己的，甚至两个客户端之间，不用服务端也能连起来。</p><p>这实在是，太出乎意料了。</p><br><br><p><strong>如果文章对你有帮助，欢迎.....</strong></p><p>算了。</p><p>兄弟们都是自家人，点不<strong>点赞</strong>，在不<strong>在看</strong>什么的，没关系的，大家看开心了就好。</p><p><strong>在看，点赞</strong>什么的，我不是特别在意，真的，真的，别不信啊。</p><p>不三连也真的没关系的。</p><p>兄弟们不要在意啊。</p><p>我是<strong>虚伪</strong>的小白，我们下期见！</p><br><h5 id="别说了-一起在知识的海洋里呛水吧" tabindex="-1"><a class="header-anchor" href="#别说了-一起在知识的海洋里呛水吧"><span>别说了，一起在知识的海洋里呛水吧</span></a></h5><p><strong>点击</strong>下方名片，关注公众号:【小白 debug】<br><img src="https://cdn.xiaobaidebug.top/1696069689495.png" alt="" loading="lazy"></p><br><p>不满足于在留言区说骚话？</p><p>加我，我们建了个划水吹牛皮群，在群里，你可以跟你下次跳槽可能遇到的同事或面试官聊点阳间的话题。就<strong>超！开！心！</strong></p><img src="https://cdn.xiaobaidebug.top/image-20220522162616202.png" width="50%" align="center"><h2 id="文章推荐" tabindex="-1"><a class="header-anchor" href="#文章推荐"><span>文章推荐：</span></a></h2>`,208),r={href:"https://mp.weixin.qq.com/s/0H8WL6QeZ2VbO1hHPkn8Ug",target:"_blank",rel:"noopener noreferrer"},u={href:"https://golangguide.top/golang/%E6%A0%B8%E5%BF%83%E7%9F%A5%E8%AF%86%E7%82%B9/%E7%BB%99%E5%A4%A7%E5%AE%B6%E4%B8%A2%E8%84%B8%E4%BA%86%EF%BC%8C%E7%94%A8%E4%BA%86%E4%B8%89%E5%B9%B4golang%EF%BC%8C%E6%88%91%E8%BF%98%E6%98%AF%E6%B2%A1%E7%AD%94%E5%AF%B9%E8%BF%99%E9%81%93%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%E9%A2%98.html",target:"_blank",rel:"noopener noreferrer"},k=n("li",null,[n("p",null,[n("a",{href:"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/%E6%A0%B8%E5%BF%83%E7%9F%A5%E8%AF%86%E7%82%B9/%E7%A1%AC%E6%A0%B8%EF%BC%81%E6%BC%AB%E7%94%BB%E5%9B%BE%E8%A7%A3HTTP%E7%9F%A5%E8%AF%86%E7%82%B9_%E9%9D%A2%E8%AF%95%E9%A2%98"},"硬核！漫画图解 HTTP 知识点+面试题")])],-1),g={href:"https://mp.weixin.qq.com/s/BJqp72EyEMahxi2XOfSrBQ",target:"_blank",rel:"noopener noreferrer"};function m(b,v){const s=p("ExternalLinkIcon");return o(),c("div",null,[d,n("ul",null,[n("li",null,[n("p",null,[n("a",r,[a("TCP 粘包 数据包：我只是犯了每个数据包都会犯的错 |硬核图解"),t(s)])])]),n("li",null,[n("p",null,[n("a",u,[a("给大家丢脸了，用了三年 golang，我还是没答对这道内存泄漏题"),t(s)])])]),k,n("li",null,[n("p",null,[n("a",g,[a("硬核图解！30 张图带你搞懂！路由器，集线器，交换机，网桥，光猫有啥区别？"),t(s)])])])])])}const f=e(l,[["render",m],["__file","活久见！TCP两次挥手，你见过吗？那四次握手呢？.html.vue"]]),C=JSON.parse('{"path":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/%E6%A0%B8%E5%BF%83%E7%9F%A5%E8%AF%86%E7%82%B9/%E6%B4%BB%E4%B9%85%E8%A7%81%EF%BC%81TCP%E4%B8%A4%E6%AC%A1%E6%8C%A5%E6%89%8B%EF%BC%8C%E4%BD%A0%E8%A7%81%E8%BF%87%E5%90%97%EF%BC%9F%E9%82%A3%E5%9B%9B%E6%AC%A1%E6%8F%A1%E6%89%8B%E5%91%A2%EF%BC%9F.html","title":"活久见！TCP两次挥手，你见过吗？那四次握手呢？","lang":"zh-CN","frontmatter":{"title":"活久见！TCP两次挥手，你见过吗？那四次握手呢？","date":"2021-09-25T22:57:55.000Z","tags":null,"categories":"图解网络","description":"我们都知道，TCP 是个面向连接的、可靠的、基于字节流的传输层通信协议。 TCP是什么TCP是什么 那这里面提到的\\"面向连接\\"，意味着需要 建立连接，使用连接，释放连接。 建立连接是指我们熟知的TCP 三次握手。 而使用连接，则是通过一发送、一确认的形式，进行数据传输。 还有就是释放连接，也就是我们常见的TCP 四次挥手。 TCP 四次挥手大家应该比较...","head":[["meta",{"property":"og:url","content":"https://golangguide.top/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/%E6%A0%B8%E5%BF%83%E7%9F%A5%E8%AF%86%E7%82%B9/%E6%B4%BB%E4%B9%85%E8%A7%81%EF%BC%81TCP%E4%B8%A4%E6%AC%A1%E6%8C%A5%E6%89%8B%EF%BC%8C%E4%BD%A0%E8%A7%81%E8%BF%87%E5%90%97%EF%BC%9F%E9%82%A3%E5%9B%9B%E6%AC%A1%E6%8F%A1%E6%89%8B%E5%91%A2%EF%BC%9F.html"}],["meta",{"property":"og:site_name","content":"golang全栈指南"}],["meta",{"property":"og:title","content":"活久见！TCP两次挥手，你见过吗？那四次握手呢？"}],["meta",{"property":"og:description","content":"我们都知道，TCP 是个面向连接的、可靠的、基于字节流的传输层通信协议。 TCP是什么TCP是什么 那这里面提到的\\"面向连接\\"，意味着需要 建立连接，使用连接，释放连接。 建立连接是指我们熟知的TCP 三次握手。 而使用连接，则是通过一发送、一确认的形式，进行数据传输。 还有就是释放连接，也就是我们常见的TCP 四次挥手。 TCP 四次挥手大家应该比较..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:image","content":"https://cdn.xiaobaidebug.top/image/tcp%E6%98%AF%E4%BB%80%E4%B9%882.png"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2024-03-04T07:59:24.000Z"}],["meta",{"name":"twitter:card","content":"summary_large_image"}],["meta",{"name":"twitter:image:alt","content":"活久见！TCP两次挥手，你见过吗？那四次握手呢？"}],["meta",{"property":"article:author","content":"小白debug"}],["meta",{"property":"article:published_time","content":"2021-09-25T22:57:55.000Z"}],["meta",{"property":"article:modified_time","content":"2024-03-04T07:59:24.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"活久见！TCP两次挥手，你见过吗？那四次握手呢？\\",\\"image\\":[\\"https://cdn.xiaobaidebug.top/image/tcp%E6%98%AF%E4%BB%80%E4%B9%882.png\\",\\"https://cdn.xiaobaidebug.top/image/TCP%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B7.png\\",\\"https://cdn.xiaobaidebug.top/image/FIN-WAIT-2%E7%89%B9%E5%88%AB%E5%A4%9A%E7%9A%84%E5%8E%9F%E5%9B%A0.png\\",\\"https://cdn.xiaobaidebug.top/image/shutdown%E8%A7%A6%E5%8F%91%E7%9A%84TCP%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B.png\\",\\"https://cdn.xiaobaidebug.top/image/e18d20c94006dfe0-feec70b0eb485633-f0e01cf6d9cce2bccba34029f1ca10e0-20210808141929988.jpg\\",\\"https://cdn.xiaobaidebug.top/image/tcp_sendmsg%E9%80%BB%E8%BE%912.png\\",\\"https://cdn.xiaobaidebug.top/image/%E4%B8%80%E7%9B%B4%E4%B8%8D%E5%8F%91%E7%AC%AC%E4%B8%89%E6%AC%A1%E6%8C%A5%E6%89%8B%E7%9A%84%E6%83%85%E5%86%B53.png\\",\\"https://cdn.xiaobaidebug.top/image/TCP%E4%B8%89%E6%AC%A1%E6%8C%A5%E6%89%8B.png\\",\\"https://cdn.xiaobaidebug.top/image/TCP%E4%B8%89%E6%AC%A1%E6%8C%A5%E6%89%8B%E5%BB%B6%E8%BF%9F%E7%A1%AE%E8%AE%A4.png\\",\\"https://cdn.xiaobaidebug.top/image/TCP%E4%B8%A4%E6%AC%A1%E6%8C%A5%E6%89%8B2.png\\",\\"https://cdn.xiaobaidebug.top/image/image-20210810093309117.png\\",\\"https://cdn.xiaobaidebug.top/image/TCP%E8%87%AA%E8%BF%9E%E6%8E%A52.png\\",\\"https://cdn.xiaobaidebug.top/image/正常情况下的TCP三次握手2.png\\",\\"https://cdn.xiaobaidebug.top/image/TCP%E5%90%8C%E6%97%B6%E6%89%93%E5%BC%802.png\\",\\"https://cdn.xiaobaidebug.top/image/image-20210815090301418.png\\",\\"https://cdn.xiaobaidebug.top/1696069689495.png\\"],\\"datePublished\\":\\"2021-09-25T22:57:55.000Z\\",\\"dateModified\\":\\"2024-03-04T07:59:24.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"小白debug\\",\\"url\\":\\"https://xiaobaidebug.top/\\"}]}"],["link",{"rel":"canonical","href":"https://golangguide.top/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/%E6%A0%B8%E5%BF%83%E7%9F%A5%E8%AF%86%E7%82%B9/%E6%B4%BB%E4%B9%85%E8%A7%81%EF%BC%81TCP%E4%B8%A4%E6%AC%A1%E6%8C%A5%E6%89%8B%EF%BC%8C%E4%BD%A0%E8%A7%81%E8%BF%87%E5%90%97%EF%BC%9F%E9%82%A3%E5%9B%9B%E6%AC%A1%E6%8F%A1%E6%89%8B%E5%91%A2%EF%BC%9F.html"}],["meta",{"property":"og:url","content":"https://golangguide.top/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/%E6%A0%B8%E5%BF%83%E7%9F%A5%E8%AF%86%E7%82%B9/%E6%B4%BB%E4%B9%85%E8%A7%81%EF%BC%81TCP%E4%B8%A4%E6%AC%A1%E6%8C%A5%E6%89%8B%EF%BC%8C%E4%BD%A0%E8%A7%81%E8%BF%87%E5%90%97%EF%BC%9F%E9%82%A3%E5%9B%9B%E6%AC%A1%E6%8F%A1%E6%89%8B%E5%91%A2%EF%BC%9F.html"}],["meta",{"property":"og:site_name","content":"golang全栈指南"}],["meta",{"property":"og:title","content":"活久见！TCP两次挥手，你见过吗？那四次握手呢？"}],["meta",{"property":"og:description","content":"我们都知道，TCP 是个面向连接的、可靠的、基于字节流的传输层通信协议。 TCP是什么TCP是什么 那这里面提到的\\"面向连接\\"，意味着需要 建立连接，使用连接，释放连接。 建立连接是指我们熟知的TCP 三次握手。 而使用连接，则是通过一发送、一确认的形式，进行数据传输。 还有就是释放连接，也就是我们常见的TCP 四次挥手。 TCP 四次挥手大家应该比较..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2024-03-04T07:59:24.000Z"}],["meta",{"property":"article:published_time","content":"2021-09-25T22:57:55.000Z"}],["meta",{"property":"article:modified_time","content":"2024-03-04T07:59:24.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"活久见！TCP两次挥手，你见过吗？那四次握手呢？\\",\\"image\\":[\\"\\"],\\"datePublished\\":\\"2021-09-25T22:57:55.000Z\\",\\"dateModified\\":\\"2024-03-04T07:59:24.000Z\\",\\"author\\":[]}"]]},"headers":[{"level":2,"title":"FIN 一定要程序执行 close()或 shutdown()才能发出吗？","slug":"fin-一定要程序执行-close-或-shutdown-才能发出吗","link":"#fin-一定要程序执行-close-或-shutdown-才能发出吗","children":[]},{"level":2,"title":"如果机器上 FIN-WAIT-2 状态特别多，是为什么","slug":"如果机器上-fin-wait-2-状态特别多-是为什么","link":"#如果机器上-fin-wait-2-状态特别多-是为什么","children":[]},{"level":2,"title":"主动方在 close 之后收到的数据，会怎么处理","slug":"主动方在-close-之后收到的数据-会怎么处理","link":"#主动方在-close-之后收到的数据-会怎么处理","children":[]},{"level":2,"title":"第二第三次挥手之间，不能传输数据吗？","slug":"第二第三次挥手之间-不能传输数据吗","link":"#第二第三次挥手之间-不能传输数据吗","children":[]},{"level":2,"title":"怎么知道对端 socket 执行了 close 还是 shutdown","slug":"怎么知道对端-socket-执行了-close-还是-shutdown","link":"#怎么知道对端-socket-执行了-close-还是-shutdown","children":[]},{"level":2,"title":"如果被动方一直不发第三次挥手，会怎么样","slug":"如果被动方一直不发第三次挥手-会怎么样","link":"#如果被动方一直不发第三次挥手-会怎么样","children":[]},{"level":2,"title":"如果有数据要发，就不能是三次挥手了吗","slug":"如果有数据要发-就不能是三次挥手了吗","link":"#如果有数据要发-就不能是三次挥手了吗","children":[]},{"level":2,"title":"一个 socket 能建立连接？","slug":"一个-socket-能建立连接","link":"#一个-socket-能建立连接","children":[{"level":3,"title":"一端发出第一次握手后，如果又收到了第一次握手的 SYN 包，TCP 连接状态会怎么变化？","slug":"一端发出第一次握手后-如果又收到了第一次握手的-syn-包-tcp-连接状态会怎么变化","link":"#一端发出第一次握手后-如果又收到了第一次握手的-syn-包-tcp-连接状态会怎么变化","children":[]},{"level":3,"title":"一端发出第二次握手后，如果又收到第二次握手的 SYN+ACK 包，TCP 连接状态会怎么变化？","slug":"一端发出第二次握手后-如果又收到第二次握手的-syn-ack-包-tcp-连接状态会怎么变化","link":"#一端发出第二次握手后-如果又收到第二次握手的-syn-ack-包-tcp-连接状态会怎么变化","children":[]},{"level":3,"title":"一端第一次挥手后，又收到第一次挥手的包，TCP 连接状态会怎么变化？","slug":"一端第一次挥手后-又收到第一次挥手的包-tcp-连接状态会怎么变化","link":"#一端第一次挥手后-又收到第一次挥手的包-tcp-连接状态会怎么变化","children":[]},{"level":3,"title":"代码复现自连接","slug":"代码复现自连接","link":"#代码复现自连接","children":[]},{"level":3,"title":"自连接的解决方案","slug":"自连接的解决方案","link":"#自连接的解决方案","children":[]},{"level":3,"title":"复现 TCP 同时打开","slug":"复现-tcp-同时打开","link":"#复现-tcp-同时打开","children":[]}]},{"level":2,"title":"文章推荐：","slug":"文章推荐","link":"#文章推荐","children":[]}],"git":{"createdTime":1708315055000,"updatedTime":1709539164000,"contributors":[{"name":"xiaobai","email":"xiaobaidebug@gmail.com","commits":3}]},"readingTime":{"minutes":20.24,"words":6071},"filePathRelative":"计算机基础/网络基础/核心知识点/活久见！TCP两次挥手，你见过吗？那四次握手呢？.md","localizedDate":"2021年9月25日","autoDesc":true}');export{f as comp,C as data};
