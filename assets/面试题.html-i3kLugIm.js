import{_ as a}from"./plugin-vue_export-helper-DlAUqK2U.js";import{o as e,c as s,e as t}from"./app-BXLseW7v.js";const n={},c=t(`<h1 id="elasticsearch面试题" tabindex="-1"><a class="header-anchor" href="#elasticsearch面试题"><span>Elasticsearch面试题</span></a></h1><h2 id="elasticsearch-读取数据" tabindex="-1"><a class="header-anchor" href="#elasticsearch-读取数据"><span>Elasticsearch 读取数据</span></a></h2><p>使用 RestFul API 向对应的 node 发送查询请求，根据 did 来判断在哪个 shard 上，返回的是 primary 和 replica 的 node 节点集合。 这样会负载均衡地把查询发送到对应节点，之后对应节点接收到请求，将</p><p>document 数据返回协调节点，协调节点把 document 返回给客户端。</p><figure><img src="https://cdn.jsdelivr.net/gh/xiaobaiTech/image/Aspose.Words.11373988-27b3-4612-8bb0-f73e9596f59b.002.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><h2 id="您能解释一下-x-pack-for-elasticsearch-的功能和重要性吗" tabindex="-1"><a class="header-anchor" href="#您能解释一下-x-pack-for-elasticsearch-的功能和重要性吗"><span>您能解释一下 X-Pack for Elasticsearch 的功能和重要性吗？</span></a></h2><p>X-Pack 是与 Elasticsearch 一起安装的扩展程序。</p><p>X-Pack 的各种功能包括安全性（基于角色的访问，特权/权限，角色和用户安 全性），监视，报告，警报等。</p><h2 id="elasticsearch-中的节点-比如共-20-个-其中的-10-个选了-一个-master-另外-10-个选了另一个-master-怎么办" tabindex="-1"><a class="header-anchor" href="#elasticsearch-中的节点-比如共-20-个-其中的-10-个选了-一个-master-另外-10-个选了另一个-master-怎么办"><span>Elasticsearch 中的节点（比如共 20 个），其中的 10 个选了 一个 master，另外 10 个选了另一个 master，怎么办？</span></a></h2><ul><li>当集群 master 候选数量不小于 3 个时，可以通过设置最少投票通过数量</li></ul><p>（discovery.zen.minimum_master_nodes）超过所有候选节点一半以上 来解决脑裂问题；</p><ul><li>当候选数量为两个时，只能修改为唯一的一个 master 候选，其他作为data 节点，避免脑裂问题。</li></ul><h2 id="解释一下-elasticsearch-集群中的-索引的概念" tabindex="-1"><a class="header-anchor" href="#解释一下-elasticsearch-集群中的-索引的概念"><span>解释一下 Elasticsearch 集群中的 索引的概念 ？</span></a></h2><p>Elasticsearch 集群可以包含多个索引，与关系数据库相比，它们相当于数据库 表。</p><h2 id="你可以列出-elasticsearch-各种类型的分析器吗" tabindex="-1"><a class="header-anchor" href="#你可以列出-elasticsearch-各种类型的分析器吗"><span>你可以列出 Elasticsearch 各种类型的分析器吗？</span></a></h2><p>Elasticsearch Analyzer 的类型为内置分析器和自定义分析器。</p><p><strong>Standard Analyzer</strong> 标准分析器是默认分词器，如果未指定，则使用该分词器。 它基于 Unicode 文本分割算法，适用于大多数语言。</p><p><strong>Whitespace Analyzer</strong></p><p>基于空格字符切词。</p><p><strong>Stop Analyzer</strong></p><p>在 simple Analyzer 的基础上，移除停用词。</p><p><strong>Keyword Analyzer</strong> 不切词，将输入的整个串一起返回。</p><p><strong>自定义分词器的模板</strong></p><p>自定义分词器的在 Mapping 的 Setting 部分设置：</p><div class="language-json line-numbers-mode" data-ext="json" data-title="json"><pre class="language-json"><code>PUT my\\_custom\\_index 
<span class="token punctuation">{</span>
    <span class="token property">&quot;settings&quot;</span><span class="token operator">:</span><span class="token punctuation">{</span>
        <span class="token property">&quot;analysis&quot;</span><span class="token operator">:</span><span class="token punctuation">{</span>
            <span class="token property">&quot;char\\_filter&quot;</span><span class="token operator">:</span><span class="token punctuation">{</span>

            <span class="token punctuation">}</span><span class="token punctuation">,</span>
            <span class="token property">&quot;tokenizer&quot;</span><span class="token operator">:</span><span class="token punctuation">{</span>

            <span class="token punctuation">}</span><span class="token punctuation">,</span>
            <span class="token property">&quot;filter&quot;</span><span class="token operator">:</span><span class="token punctuation">{</span>

            <span class="token punctuation">}</span><span class="token punctuation">,</span>
            <span class="token property">&quot;analyzer&quot;</span><span class="token operator">:</span><span class="token punctuation">{</span>

            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>其中： “char_filter”:{},——对应字符过滤部分； “tokenizer”:{},——对应文本切分为分词部分；</p><p>“filter”:{},——对应分词后再过滤部分； “analyzer”:{}——对应分词器组成部分，其中会包含：1. 2. 3。</p><h2 id="解释一下-elasticsearch-node" tabindex="-1"><a class="header-anchor" href="#解释一下-elasticsearch-node"><span>解释一下 Elasticsearch Node？</span></a></h2><p>节点是 Elasticsearch 的实例。实际业务中，我们会说：ES 集群包含 3 个节 点、7 个节点。</p><p>这里节点实际就是：一个独立的 Elasticsearch 进程，一般将一个节点部署到 一台独立的服务器或者虚拟机、容器中。 不同节点根据角色不同，可以划分为：</p><p><strong>主节点</strong></p><p>帮助配置和管理在整个集群中添加和删除节点。</p><p><strong>数据节点</strong></p><p>存储数据并执行诸如 CRUD（创建/读取/更新/删除）操作，对数据进行搜索和 聚合的操作。</p><p><strong>客户端节点</strong>（或者说：协调节点）</p><p>将集群请求转发到主节点，将与数据相 关的请求转发到数据节点。</p><p><strong>摄取节点</strong></p><p>用于在索引之前对文档进行预处理。</p><h2 id="在安装-elasticsearch-时-请说明不同的软件包及其重要性" tabindex="-1"><a class="header-anchor" href="#在安装-elasticsearch-时-请说明不同的软件包及其重要性"><span>在安装 Elasticsearch 时，请说明不同的软件包及其重要性？</span></a></h2><p>这个貌似没什么好说的，去官方文档下载对应操作系统安装包即可。 部分功能是收费的，如机器学习、高级别 kerberos 认证安全等选型要知悉。</p><h2 id="elasticsearch-在部署时-对-linux-的设置有哪些优化方法" tabindex="-1"><a class="header-anchor" href="#elasticsearch-在部署时-对-linux-的设置有哪些优化方法"><span>Elasticsearch 在部署时，对 Linux 的设置有哪些优化方法？</span></a></h2><p>关闭缓存 swap;</p><p>堆内存设置为：Min（节点内存/2, 32GB）;</p><p>设置最大文件句柄数；</p><p>线程池+队列大小根据业务需要做调整；</p><p>磁盘存储 raid 方式——存储有条件使用 RAID10，增加单节点性能以及避 免单节点存储故障。</p><h2 id="请解释有关-elasticsearch-的-nrt" tabindex="-1"><a class="header-anchor" href="#请解释有关-elasticsearch-的-nrt"><span>请解释有关 Elasticsearch 的 NRT？</span></a></h2><p>从文档索引（写入）到可搜索到之间的延迟默认一秒钟，因此 Elasticsearch 是 近实时（NRT）搜索平台。</p><p>也就是说：文档写入，最快一秒钟被索引到，不能再快了。 写入调优的时候，我们通常会动态调整：refresh_interval = 30s 或者更达 值，以使得写入数据更晚一点时间被搜索到。</p><h2 id="elasticsearch-的-document-设计" tabindex="-1"><a class="header-anchor" href="#elasticsearch-的-document-设计"><span>elasticsearch 的 document 设计</span></a></h2><p>在使用 es 时 避免使用复杂的查询语句（Join 、聚合），就是在建立索引时， 就根据查询语句建立好对应的元数据。</p>`,51),i=[c];function r(l,p){return e(),s("div",null,i)}const d=a(n,[["render",r],["__file","面试题.html.vue"]]),u=JSON.parse('{"path":"/%E4%B8%AD%E9%97%B4%E4%BB%B6/es/%E9%9D%A2%E8%AF%95%E9%A2%98.html","title":"Elasticsearch面试题","lang":"zh-CN","frontmatter":{"description":"Elasticsearch面试题 Elasticsearch 读取数据 使用 RestFul API 向对应的 node 发送查询请求，根据 did 来判断在哪个 shard 上，返回的是 primary 和 replica 的 node 节点集合。 这样会负载均衡地把查询发送到对应节点，之后对应节点接收到请求，将 document 数据返回协调节点，...","head":[["meta",{"property":"og:url","content":"https://golangguide.top/%E4%B8%AD%E9%97%B4%E4%BB%B6/es/%E9%9D%A2%E8%AF%95%E9%A2%98.html"}],["meta",{"property":"og:site_name","content":"golang全栈指南"}],["meta",{"property":"og:title","content":"Elasticsearch面试题"}],["meta",{"property":"og:description","content":"Elasticsearch面试题 Elasticsearch 读取数据 使用 RestFul API 向对应的 node 发送查询请求，根据 did 来判断在哪个 shard 上，返回的是 primary 和 replica 的 node 节点集合。 这样会负载均衡地把查询发送到对应节点，之后对应节点接收到请求，将 document 数据返回协调节点，..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:image","content":"https://cdn.jsdelivr.net/gh/xiaobaiTech/image/Aspose.Words.11373988-27b3-4612-8bb0-f73e9596f59b.002.png"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2024-02-13T08:18:41.000Z"}],["meta",{"name":"twitter:card","content":"summary_large_image"}],["meta",{"name":"twitter:image:alt","content":"Elasticsearch面试题"}],["meta",{"property":"article:author","content":"小白debug"}],["meta",{"property":"article:modified_time","content":"2024-02-13T08:18:41.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"Elasticsearch面试题\\",\\"image\\":[\\"https://cdn.jsdelivr.net/gh/xiaobaiTech/image/Aspose.Words.11373988-27b3-4612-8bb0-f73e9596f59b.002.png\\"],\\"dateModified\\":\\"2024-02-13T08:18:41.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"小白debug\\",\\"url\\":\\"https://xiaobaidebug.top/\\"}]}"]]},"headers":[{"level":2,"title":"Elasticsearch  读取数据","slug":"elasticsearch-读取数据","link":"#elasticsearch-读取数据","children":[]},{"level":2,"title":"您能解释一下 X-Pack for Elasticsearch 的功能和重要性吗？","slug":"您能解释一下-x-pack-for-elasticsearch-的功能和重要性吗","link":"#您能解释一下-x-pack-for-elasticsearch-的功能和重要性吗","children":[]},{"level":2,"title":"Elasticsearch  中的节点（比如共  20  个），其中的  10  个选了 一个 master，另外  10  个选了另一个  master，怎么办？","slug":"elasticsearch-中的节点-比如共-20-个-其中的-10-个选了-一个-master-另外-10-个选了另一个-master-怎么办","link":"#elasticsearch-中的节点-比如共-20-个-其中的-10-个选了-一个-master-另外-10-个选了另一个-master-怎么办","children":[]},{"level":2,"title":"解释一下  Elasticsearch 集群中的  索引的概念  ？","slug":"解释一下-elasticsearch-集群中的-索引的概念","link":"#解释一下-elasticsearch-集群中的-索引的概念","children":[]},{"level":2,"title":"你可以列出  Elasticsearch  各种类型的分析器吗？","slug":"你可以列出-elasticsearch-各种类型的分析器吗","link":"#你可以列出-elasticsearch-各种类型的分析器吗","children":[]},{"level":2,"title":"解释一下  Elasticsearch Node？","slug":"解释一下-elasticsearch-node","link":"#解释一下-elasticsearch-node","children":[]},{"level":2,"title":"在安装 Elasticsearch 时，请说明不同的软件包及其重要性？","slug":"在安装-elasticsearch-时-请说明不同的软件包及其重要性","link":"#在安装-elasticsearch-时-请说明不同的软件包及其重要性","children":[]},{"level":2,"title":"Elasticsearch 在部署时，对 Linux 的设置有哪些优化方法？","slug":"elasticsearch-在部署时-对-linux-的设置有哪些优化方法","link":"#elasticsearch-在部署时-对-linux-的设置有哪些优化方法","children":[]},{"level":2,"title":"请解释有关  Elasticsearch 的  NRT？","slug":"请解释有关-elasticsearch-的-nrt","link":"#请解释有关-elasticsearch-的-nrt","children":[]},{"level":2,"title":"elasticsearch  的  document 设计","slug":"elasticsearch-的-document-设计","link":"#elasticsearch-的-document-设计","children":[]}],"git":{"createdTime":1707812321000,"updatedTime":1707812321000,"contributors":[{"name":"xiaobai","email":"xiaobaidebug@gmail.com","commits":1}]},"readingTime":{"minutes":3.58,"words":1074},"filePathRelative":"中间件/es/面试题.md","localizedDate":"2024年2月13日","autoDesc":true}');export{d as comp,u as data};
