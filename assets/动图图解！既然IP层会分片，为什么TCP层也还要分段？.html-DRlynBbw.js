import{_ as s}from"./plugin-vue_export-helper-DlAUqK2U.js";import{r as o,o as p,c as r,a as e,b as a,d as n,e as i}from"./app-CbjCfMt9.js";const l={},g=i(`<figure><img src="https://cdn.xiaobaidebug.top/image/目录.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><h2 id="什么是-tcp-分段和-ip-分片" tabindex="-1"><a class="header-anchor" href="#什么是-tcp-分段和-ip-分片"><span>什么是 TCP 分段和 IP 分片</span></a></h2><p>我们知道网络就像一根管子，而管子吧，就会有粗细。</p><p>一个数据包想从管子的一端到另一端，得过这个管子。<s>（废话）</s></p><p>但数据包的量<strong>有大有小</strong>，想过管子，数据包不能大于这根管子的粗细。</p><p>问题来了，数据包过大时怎么办？</p><p>答案比较简单。会把数据包切分小块。这样数据就可以由大变小，顺利传输。</p><figure><img src="https://cdn.xiaobaidebug.top/image/数据分片2.png" alt="数据分片" tabindex="0" loading="lazy"><figcaption>数据分片</figcaption></figure><p>回去看下网络分层协议，数据先过传输层，再到网络层。</p><p>这个行为在<strong>传输层和网络层</strong>都有可能发生。</p><p>在传输层（<code>TCP</code>协议）里，叫<strong>分段</strong>。</p><p>在网络层（<code>IP</code>层），叫<strong>分片</strong>。（注意以下提到的 IP 没有特殊说明的情况下，都是指<strong>IPV4</strong>）</p><p>那么不管是分片还是分段，肯定需要<strong>按照一定的长度</strong>切分。</p><p>在<code>TCP</code>里，这个长度是<code>MSS</code>。</p><p>在<code>IP</code>层里，这个长度是<code>MTU</code>。</p><p>那<strong>MSS 和 MTU 是什么关系</strong>呢？这个在<a href="/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/%E6%A0%B8%E5%BF%83%E7%9F%A5%E8%AF%86%E7%82%B9/TCP%E7%B2%98%E5%8C%85%EF%BC%81%E6%95%B0%E6%8D%AE%E5%8C%85%EF%BC%9A%E6%88%91%E5%8F%AA%E6%98%AF%E7%8A%AF%E4%BA%86%E6%AF%8F%E4%B8%AA%E6%95%B0%E6%8D%AE%E5%8C%85%E9%83%BD%E4%BC%9A%E7%8A%AF%E7%9A%84%E9%94%99%EF%BC%8C%E7%A1%AC%E6%A0%B8%E5%9B%BE%E8%A7%A3">之前的文章</a>里简单提到过。这里单独拿出来。</p><h2 id="mss-是什么" tabindex="-1"><a class="header-anchor" href="#mss-是什么"><span>MSS 是什么</span></a></h2><p><strong>MSS：Maximum Segment Size</strong> 。 TCP 提交给 IP 层最大分段大小，不包含 TCP Header 和 TCP Option，只包含 TCP Payload ，MSS 是 TCP 用来限制应用层最大的发送字节数。<br> 假设 MTU= 1500 byte，那么 <strong>MSS = 1500- 20(IP Header) -20 (TCP Header) = 1460 byte</strong>，如果应用层有 <strong>2000 byte</strong> 发送，那么需要两个切片才可以完成发送，第一个 TCP 切片 = 1460，第二个 TCP 切片 = 540。</p><figure><img src="https://cdn.xiaobaidebug.top/image/MSS分包.gif" alt="MSS分包" tabindex="0" loading="lazy"><figcaption>MSS分包</figcaption></figure><h3 id="如何查看-mss" tabindex="-1"><a class="header-anchor" href="#如何查看-mss"><span>如何查看 MSS？</span></a></h3><p>我们都知道 TCP 三次握手，而<code>MSS</code>会在三次握手的过程中传递给对方，用于通知对端本地最大可以接收的 TCP 报文数据大小（不包含 TCP 和 IP 报文首部）。</p><figure><img src="https://cdn.xiaobaidebug.top/image/抓包mss.png" alt="抓包mss" tabindex="0" loading="lazy"><figcaption>抓包mss</figcaption></figure><p>比如上图中，B 将自己的 MSS 发送给 A，建议 A 在发数据给 B 的时候，采用<code>MSS=1420</code>进行分段。而 B 在发数据给 A 的时候，同样会带上<code>MSS=1372</code>。两者在对比后，会采用<strong>小的</strong>那个值（1372）作为通信的<code>MSS值</code>，这个过程叫<code>MSS协商</code>。</p><blockquote><p>另外，一般情况下 MSS + 20（TCP 头）+ 20（IP 头）= MTU，上面抓包的图里对应的 MTU 分别是 1372+40 和 1420+40。 同一个路径上，<strong>MTU 不一定是对称的</strong>，也就是说 A 到 B 和 B 到 A，两条路径上的 MTU 可以是不同的，对应的 MSS 也一样。</p></blockquote><h3 id="三次握手中协商了-mss-就不会改变了吗" tabindex="-1"><a class="header-anchor" href="#三次握手中协商了-mss-就不会改变了吗"><span>三次握手中协商了 MSS 就不会改变了吗？</span></a></h3><p>当然不是，每次执行 TCP 发送消息的函数时，会重新计算一次 MSS，再进行分段操作。</p><h3 id="对端不传-mss-会怎么样" tabindex="-1"><a class="header-anchor" href="#对端不传-mss-会怎么样"><span>对端不传 MSS 会怎么样？</span></a></h3><p>我们再看 TCP 的报头。</p><figure><img src="https://cdn.xiaobaidebug.top/image/tcp报头5.png" alt="TCP报头" tabindex="0" loading="lazy"><figcaption>TCP报头</figcaption></figure><p>其实 MSS 是作为可选项引入的，只不过一般情况下 MSS 都会传，但是万一遇到了哪台机器的实现上比较调皮，<strong>不传 MSS</strong>这个可选项。那对端该怎么办？</p><p><strong>如果没有接收到对端 TCP 的 MSS，本端 TCP 默认采用 MSS=536Byte</strong>。</p><p>那为什么会是<code>536</code>？</p><div class="language-bash line-numbers-mode" data-ext="sh" data-title="sh"><pre class="language-bash"><code><span class="token number">536</span>（data） + <span class="token number">20</span>（tcp头）+20（ip头）<span class="token operator">=</span> 576Byte
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>前面提到了 IP 会切片，那会切片，也就会重组，而这个 576 正好是 IP 最小重组缓冲区的大小。</p><h2 id="mtu-是什么" tabindex="-1"><a class="header-anchor" href="#mtu-是什么"><span>MTU 是什么</span></a></h2><p><strong>MTU: Maximum Transmit Unit</strong>，最大传输单元。 其实这个是由<strong>数据链路层</strong>提供，为了告诉上层 IP 层，自己的传输能力是多大。IP 层就会根据它进行数据包切分。一般 MTU=<strong>1500 Byte</strong>。<br> 假设 IP 层有 &lt;= <code>1500</code> byte 需要发送，只需要一个 IP 包就可以完成发送任务；假设 IP 层有 &gt; <code>1500</code> byte 数据需要发送，需要分片才能完成发送，分片后的 IP Header ID 相同，同时为了分片后能在接收端把切片组装起来，还需要在分片后的 IP 包里加上各种信息。比如这个分片在原来的 IP 包里的偏移 offset。</p><figure><img src="https://cdn.xiaobaidebug.top/image/mtu分包.gif" alt="MTU分包" tabindex="0" loading="lazy"><figcaption>MTU分包</figcaption></figure><h3 id="如何查看-mtu" tabindex="-1"><a class="header-anchor" href="#如何查看-mtu"><span>如何查看 MTU</span></a></h3><p>在<code>mac</code>控制台输入 <code>ifconfig</code>命令，可以看到 MTU 的值为多大。</p><div class="language-bash line-numbers-mode" data-ext="sh" data-title="sh"><pre class="language-bash"><code>$ ipconfig
lo0: <span class="token assign-left variable">flags</span><span class="token operator">=</span><span class="token number">804</span><span class="token operator"><span class="token file-descriptor important">9</span>&lt;</span>UP,LOOPBACK,RUNNING,MULTICAST<span class="token operator">&gt;</span> mtu <span class="token number">16384</span>
	<span class="token punctuation">..</span>.
en0: <span class="token assign-left variable">flags</span><span class="token operator">=</span><span class="token number">886</span><span class="token operator"><span class="token file-descriptor important">3</span>&lt;</span>UP,BROADCAST,SMART,RUNNING,SIMPLEX,MULTICAST<span class="token operator">&gt;</span> mtu <span class="token number">1500</span>
	<span class="token punctuation">..</span>.
p2p0: <span class="token assign-left variable">flags</span><span class="token operator">=</span><span class="token number">884</span><span class="token operator"><span class="token file-descriptor important">3</span>&lt;</span>UP,BROADCAST,RUNNING,SIMPLEX,MULTICAST<span class="token operator">&gt;</span> mtu <span class="token number">2304</span>
	<span class="token punctuation">..</span>.
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>可以看到这上面有好几个<strong>MTU</strong>，可以简单理解为每个网卡的处理能力不同，所以对应的 MTU 也不同。当然这个值是可以修改的，但不在今天的讨论范畴内，不再展开。</p><p>在一台机器的应用层到这台机器的网卡，<strong>这条链路上</strong>，基本上可以保证，<code>MSS &lt; MTU</code>。</p><figure><img src="https://cdn.xiaobaidebug.top/image/MSS和MTU的区别2.png" alt="MSS和MTU的区别" tabindex="0" loading="lazy"><figcaption>MSS和MTU的区别</figcaption></figure><h3 id="为什么-mtu-一般是-1500" tabindex="-1"><a class="header-anchor" href="#为什么-mtu-一般是-1500"><span>为什么 MTU 一般是 1500</span></a></h3><p>这其实是由传输效率决定的。首先，虽然我们平时用的网络感觉挺稳定的，但其实这是因为 TCP 在背地里做了各种重传等保证了传输的可靠，其实背地里线路是动不动就丢包的，而越大的包，发生丢包的概率就越大。</p><p>那是不是包越小就越好？也不是</p><p>但是如果选择一个比较小的长度，假设选择<code>MTU</code>为<code>300Byte</code>，<code>TCP payload = 300 - IP Header - TCP Header = 300 - 20 - 20 = 260 byte</code>。那有效传输效率<code>= 260 / 300 = 86%</code></p><p>而如果以太网长度为 1500，那有效传输效率<code>= 1460 / 1500 = 96%</code> ，显然比 <code>86%</code> 高多了。</p><p>所以，包越小越不容易丢包，包越大，传输效率又越高，因此权衡之下，选了<code>1500</code>。</p><h2 id="为什么-ip-层会分片-tcp-还要分段" tabindex="-1"><a class="header-anchor" href="#为什么-ip-层会分片-tcp-还要分段"><span>为什么 IP 层会分片，TCP 还要分段</span></a></h2><p>由于本身 IP 层就会做分片这件事情。<strong>就算 TCP 不分段</strong>，到了 IP 层，数据包也会被分片，数据也能<strong>正常传输</strong>。</p><p>既然网络层就会分片了，那么 TCP 为什么还要分段？是不是有些多此一举？</p><p>假设有一份数据，较大，且在 TCP 层不分段，如果这份数据在发送的过程中出现<strong>丢包</strong>现象，TCP 会发生重传，那么重传的就是这一大份数据（虽然 IP 层会把数据切分为 MTU 长度的 N 多个小包，但是 TCP 重传的单位却是那一大份数据）。</p><figure><img src="https://cdn.xiaobaidebug.top/image/TCP分片1.gif" alt="假设TCP不分段" tabindex="0" loading="lazy"><figcaption>假设TCP不分段</figcaption></figure><p>如果 TCP 把这份数据，分段为 N 个小于等于 MSS 长度的数据包，到了 IP 层后加上 IP 头和 TCP 头，还是小于 MTU，那么 IP 层也不会再进行分包。此时在传输路上发生了丢包，那么 TCP 重传的时候也只是重传那一小部分的 MSS 段。效率会比 TCP 不分段时更高。</p><figure><img src="https://cdn.xiaobaidebug.top/image/TCP分段.gif" alt="假设TCP分段" tabindex="0" loading="lazy"><figcaption>假设TCP分段</figcaption></figure><p>类似的，传输层除了 TCP 外，还有 UDP 协议，但 UDP 本身不会分段，所以当数据量较大时，只能交给 IP 层去分片，然后传到底层进行发送。</p><p>也就是说，正常情况下，在一台机器的传输层到网络层<strong>这条链路上</strong>，如果传输层对数据做了分段，那么 IP 层就不会再分片。如果传输层没分段，那么 IP 层就可能会进行分片。</p><p>说白了，<strong>数据在 TCP 分段，就是为了在 IP 层不需要分片，同时发生重传的时候只重传分段后的小份数据</strong>。</p><h2 id="tcp-分段了-ip-层就一定不会分片了吗" tabindex="-1"><a class="header-anchor" href="#tcp-分段了-ip-层就一定不会分片了吗"><span>TCP 分段了，IP 层就一定不会分片了吗</span></a></h2><p>上面提到了，在发送端，TCP 分段后，IP 层就不会再分片了。</p><p>但是整个传输链路中，可能还会有其他网络层设备，而这些设备的 MTU 可能小于发送端的 MTU。此时虽然数据包在发送端已经<strong>分段</strong>过了，但是在 IP 层就还会再分片一次。</p><p>如果链路上还有设备有<strong>更小的 MTU</strong>，那么还会再分片，最后所有的分片都会在<strong>接收端</strong>处进行组装。</p><figure><img src="https://cdn.xiaobaidebug.top/image/IP分片再分片.gif" alt="IP分片再分片" tabindex="0" loading="lazy"><figcaption>IP分片再分片</figcaption></figure><p>因此，就算 TCP 分段过后，在链路上的其他节点的 IP 层也是有可能再分片的，而且哪怕数据被第一次 IP 分片过了，也是有可能被其他机器的 IP 层进行二次、三次、四次....分片的。</p><h2 id="ip-层怎么做到不分片" tabindex="-1"><a class="header-anchor" href="#ip-层怎么做到不分片"><span>IP 层怎么做到不分片</span></a></h2><p>上面提到的 IP 层在传输过程中<strong>因为各个节点间 MTU</strong>可能不同，导致数据是可能被多次分片的。而且每次分片都要加上各种信息便于在接收端进行分片重组。那么 IP 层是否可以做到不分片？</p><p>如果有办法知道整个链路上，最小的 MTU 是多少，并且以最小 MTU 长度发送数据，那么不管数据传到哪个节点，都不会发生分片。</p><p>整个链路上，<strong>最小的 MTU，就叫 PMTU</strong>（path MTU）。</p><p>有一个<strong>获得这个 PMTU 的方法，叫 Path MTU Discovery</strong>。</p><div class="language-bash line-numbers-mode" data-ext="sh" data-title="sh"><pre class="language-bash"><code><span class="token variable">$cat</span> /proc/sys/net/ipv4/ip_no_pmtu_disc
<span class="token number">0</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>默认为<code>0</code>，意思是开启 PMTU 发现的功能。现在一般机器上都是开启的状态。</p><p>原理比较简单，首先我们先回去看下 IP 的数据报头。</p><figure><img src="https://cdn.xiaobaidebug.top/image/ip报头DF1.png" alt="IP报头DF" tabindex="0" loading="lazy"><figcaption>IP报头DF</figcaption></figure><p>这里有个标红的标志位<code>DF</code>（Don&#39;t Fragment），当它置为 1，意味着这个 IP 报文不分片。</p><p>当链路上某个路由器，收到了这个报文，当 IP 报文长度大于路由器的 MTU 时，路由器会看下这个 IP 报文的<code>DF</code></p><ul><li>如果为<code>0</code>（允许分片），就会分片并把分片后的数据传到下一个路由器</li><li>如果为<code>1</code>，就会把数据丢弃，同时返回一个 ICMP 包给发送端，并告诉它 <s>&quot;达咩!&quot;</s> 数据不可达，需要分片，同时带上当前机器的 MTU</li></ul><p>理解了上面的原理后，我们再看下 PMTU 发现是怎么实现的。</p><ul><li>应用通过 TCP 正常发送消息，传输层<strong>TCP 分段</strong>后，到<strong>网络层</strong>加上 IP 头，<strong>DF 置为 1</strong>，消息再到更底层执行发送</li><li>此时链路上有台<strong>路由器</strong>由于各种原因<strong>MTU 变小了</strong></li><li>IP 消息到这台路由器了，路由器发现消息长度大于自己的 MTU，且消息自带 DF 不让分片。就把消息丢弃。同时返回一个<code>ICMP</code>错误给发送端，同时带上自己的<code>MTU</code>。</li></ul><figure><img src="https://cdn.xiaobaidebug.top/image/获得pmtu.gif" alt="获得pmtu" tabindex="0" loading="lazy"><figcaption>获得pmtu</figcaption></figure><ul><li>发送端收到这个 ICMP 消息，会更新自己的 MTU，同时记录到一个<strong>PMTU 表</strong>中。</li><li>因为 TCP 的可靠性，会尝试重传这个消息，同时以这个新 MTU 值计算出 MSS 进行分段，此时新的 IP 包就可以顺利被刚才的路由器转发。</li><li>如果路径上还有更小的 MTU 的路由器，那上面发生的事情还会再发生一次。</li></ul><figure><img src="https://cdn.xiaobaidebug.top/image/获得pmtu后的TCP重传.gif" alt="获得pmtu后的TCP重传" tabindex="0" loading="lazy"><figcaption>获得pmtu后的TCP重传</figcaption></figure><h2 id="总结" tabindex="-1"><a class="header-anchor" href="#总结"><span>总结</span></a></h2><ul><li><p>数据在 TCP 分段，在 IP 层就不需要分片，同时发生重传的时候只重传分段后的小份数据</p></li><li><p>TCP 分段时使用 MSS，IP 分片时使用 MTU</p></li><li><p>MSS 是通过 MTU 计算得到，在三次握手和发送消息时都有可能产生变化。</p></li><li><p>IP 分片是<strong>不得已</strong>的行为，尽量不在 IP 层分片，尤其是链路上中间设备的 IP 分片。因此，在 IPv6 中已经禁止中间节点设备对 IP 报文进行分片，分片只能在链路的最开头和最末尾两端进行。</p></li><li><p>建立连接后，路径上节点的 MTU 值改变时，可以通过 PMTU 发现更新发送端 MTU 的值。这种情况下，PMTU 发现通过浪费 N 次发送机会来换取的 PMTU，TCP 因为有重传可以保证可靠性，在 UDP 就相当于消息直接丢了。</p></li></ul><h2 id="文章推荐" tabindex="-1"><a class="header-anchor" href="#文章推荐"><span>文章推荐：</span></a></h2>`,85),c={href:"https://golangguide.top/golang/%E6%A0%B8%E5%BF%83%E7%9F%A5%E8%AF%86%E7%82%B9/%E5%8A%A8%E5%9B%BE%E5%9B%BE%E8%A7%A3%EF%BC%8CGMP%E9%87%8C%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E6%9C%89P.html",target:"_blank",rel:"noopener noreferrer"},d=e("li",null,[e("p",null,[e("a",{href:"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/%E6%A0%B8%E5%BF%83%E7%9F%A5%E8%AF%86%E7%82%B9/%E7%A1%AC%E6%A0%B8%EF%BC%81%E6%BC%AB%E7%94%BB%E5%9B%BE%E8%A7%A3HTTP%E7%9F%A5%E8%AF%86%E7%82%B9_%E9%9D%A2%E8%AF%95%E9%A2%98"},"硬核！漫画图解 HTTP 知识点+面试题")])],-1),E={href:"https://mp.weixin.qq.com/s/PwIbKDTi0uSxhUWC56sJYg",target:"_blank",rel:"noopener noreferrer"},m={href:"https://mp.weixin.qq.com/s/BJqp72EyEMahxi2XOfSrBQ",target:"_blank",rel:"noopener noreferrer"},u=i('<h2 id="最后" tabindex="-1"><a class="header-anchor" href="#最后"><span>最后</span></a></h2><p>画动图，太难了。。。看完求个赞，下次图会动得更凶。</p><p>欢迎大家加我微信（公众号里右下角“联系我”），互相围观朋友圈砍一刀啥的哈哈。</p><figure><img src="https://cdn.xiaobaidebug.top/image/image-20210513085507280.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>如果文章对你有帮助，看下文章底部右下角，做点正能量的事情（<strong>点两下</strong>）支持一下。（<strong>疯狂暗示，拜托拜托，这对我真的很重要！</strong>）</p><p>我是小白，我们下期见。</p><h5 id="别说了-一起在知识的海洋里呛水吧" tabindex="-1"><a class="header-anchor" href="#别说了-一起在知识的海洋里呛水吧"><span>别说了，一起在知识的海洋里呛水吧</span></a></h5><p>关注公众号:【小白 debug】<br><img src="https://cdn.xiaobaidebug.top/1696069689495.png" alt="" loading="lazy"></p>',8);function B(P,h){const t=o("ExternalLinkIcon");return p(),r("div",null,[g,e("ul",null,[e("li",null,[e("p",null,[e("a",c,[a("i/o timeout，希望你不要踩到这个 net/http 包的坑"),n(t)])])]),d,e("li",null,[e("p",null,[e("a",E,[a("TCP 粘包 数据包：我只是犯了每个数据包都会犯的错 |硬核图解"),n(t)])])]),e("li",null,[e("p",null,[e("a",m,[a("硬核图解！30 张图带你搞懂！路由器，集线器，交换机，网桥，光猫有啥区别？"),n(t)])])])]),u])}const b=s(l,[["render",B],["__file","动图图解！既然IP层会分片，为什么TCP层也还要分段？.html.vue"]]),C=JSON.parse('{"path":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/%E6%A0%B8%E5%BF%83%E7%9F%A5%E8%AF%86%E7%82%B9/%E5%8A%A8%E5%9B%BE%E5%9B%BE%E8%A7%A3%EF%BC%81%E6%97%A2%E7%84%B6IP%E5%B1%82%E4%BC%9A%E5%88%86%E7%89%87%EF%BC%8C%E4%B8%BA%E4%BB%80%E4%B9%88TCP%E5%B1%82%E4%B9%9F%E8%BF%98%E8%A6%81%E5%88%86%E6%AE%B5%EF%BC%9F.html","title":"动图图解！既然IP层会分片，为什么TCP层也还要分段？","lang":"zh-CN","frontmatter":{"title":"动图图解！既然IP层会分片，为什么TCP层也还要分段？","date":"2021-05-25T22:57:55.000Z","tags":null,"categories":"图解网络","description":" 什么是 TCP 分段和 IP 分片 我们知道网络就像一根管子，而管子吧，就会有粗细。 一个数据包想从管子的一端到另一端，得过这个管子。 但数据包的量有大有小，想过管子，数据包不能大于这根管子的粗细。 问题来了，数据包过大时怎么办？ 答案比较简单。会把数据包切分小块。这样数据就可以由大变小，顺利传输。 数据分片数据分片 回去看下网络分层协议，数据先过传...","head":[["meta",{"property":"og:url","content":"https://golangguide.top/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/%E6%A0%B8%E5%BF%83%E7%9F%A5%E8%AF%86%E7%82%B9/%E5%8A%A8%E5%9B%BE%E5%9B%BE%E8%A7%A3%EF%BC%81%E6%97%A2%E7%84%B6IP%E5%B1%82%E4%BC%9A%E5%88%86%E7%89%87%EF%BC%8C%E4%B8%BA%E4%BB%80%E4%B9%88TCP%E5%B1%82%E4%B9%9F%E8%BF%98%E8%A6%81%E5%88%86%E6%AE%B5%EF%BC%9F.html"}],["meta",{"property":"og:site_name","content":"golang全栈指南"}],["meta",{"property":"og:title","content":"动图图解！既然IP层会分片，为什么TCP层也还要分段？"}],["meta",{"property":"og:description","content":" 什么是 TCP 分段和 IP 分片 我们知道网络就像一根管子，而管子吧，就会有粗细。 一个数据包想从管子的一端到另一端，得过这个管子。 但数据包的量有大有小，想过管子，数据包不能大于这根管子的粗细。 问题来了，数据包过大时怎么办？ 答案比较简单。会把数据包切分小块。这样数据就可以由大变小，顺利传输。 数据分片数据分片 回去看下网络分层协议，数据先过传..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:image","content":"https://cdn.xiaobaidebug.top/image/%E7%9B%AE%E5%BD%95.png"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2024-03-04T07:59:24.000Z"}],["meta",{"name":"twitter:card","content":"summary_large_image"}],["meta",{"name":"twitter:image:alt","content":"动图图解！既然IP层会分片，为什么TCP层也还要分段？"}],["meta",{"property":"article:author","content":"小白debug"}],["meta",{"property":"article:published_time","content":"2021-05-25T22:57:55.000Z"}],["meta",{"property":"article:modified_time","content":"2024-03-04T07:59:24.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"动图图解！既然IP层会分片，为什么TCP层也还要分段？\\",\\"image\\":[\\"https://cdn.xiaobaidebug.top/image/%E7%9B%AE%E5%BD%95.png\\",\\"https://cdn.xiaobaidebug.top/image/%E6%95%B0%E6%8D%AE%E5%88%86%E7%89%872.png\\",\\"https://cdn.xiaobaidebug.top/image/MSS%E5%88%86%E5%8C%85.gif\\",\\"https://cdn.xiaobaidebug.top/image/%E6%8A%93%E5%8C%85mss.png\\",\\"https://cdn.xiaobaidebug.top/image/tcp%E6%8A%A5%E5%A4%B45.png\\",\\"https://cdn.xiaobaidebug.top/image/mtu%E5%88%86%E5%8C%85.gif\\",\\"https://cdn.xiaobaidebug.top/image/MSS和MTU的区别2.png\\",\\"https://cdn.xiaobaidebug.top/image/TCP%E5%88%86%E7%89%871.gif\\",\\"https://cdn.xiaobaidebug.top/image/TCP%E5%88%86%E6%AE%B5.gif\\",\\"https://cdn.xiaobaidebug.top/image/IP%E5%88%86%E7%89%87%E5%86%8D%E5%88%86%E7%89%87.gif\\",\\"https://cdn.xiaobaidebug.top/image/ip%E6%8A%A5%E5%A4%B4DF1.png\\",\\"https://cdn.xiaobaidebug.top/image/%E8%8E%B7%E5%BE%97pmtu.gif\\",\\"https://cdn.xiaobaidebug.top/image/%E8%8E%B7%E5%BE%97pmtu%E5%90%8E%E7%9A%84TCP%E9%87%8D%E4%BC%A0.gif\\",\\"https://cdn.xiaobaidebug.top/image/image-20210513085507280.png\\",\\"https://cdn.xiaobaidebug.top/1696069689495.png\\"],\\"datePublished\\":\\"2021-05-25T22:57:55.000Z\\",\\"dateModified\\":\\"2024-03-04T07:59:24.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"小白debug\\",\\"url\\":\\"https://xiaobaidebug.top/\\"}]}"],["link",{"rel":"canonical","href":"https://golangguide.top/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/%E6%A0%B8%E5%BF%83%E7%9F%A5%E8%AF%86%E7%82%B9/%E5%8A%A8%E5%9B%BE%E5%9B%BE%E8%A7%A3%EF%BC%81%E6%97%A2%E7%84%B6IP%E5%B1%82%E4%BC%9A%E5%88%86%E7%89%87%EF%BC%8C%E4%B8%BA%E4%BB%80%E4%B9%88TCP%E5%B1%82%E4%B9%9F%E8%BF%98%E8%A6%81%E5%88%86%E6%AE%B5%EF%BC%9F.html"}],["meta",{"property":"og:url","content":"https://golangguide.top/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/%E6%A0%B8%E5%BF%83%E7%9F%A5%E8%AF%86%E7%82%B9/%E5%8A%A8%E5%9B%BE%E5%9B%BE%E8%A7%A3%EF%BC%81%E6%97%A2%E7%84%B6IP%E5%B1%82%E4%BC%9A%E5%88%86%E7%89%87%EF%BC%8C%E4%B8%BA%E4%BB%80%E4%B9%88TCP%E5%B1%82%E4%B9%9F%E8%BF%98%E8%A6%81%E5%88%86%E6%AE%B5%EF%BC%9F.html"}],["meta",{"property":"og:site_name","content":"golang全栈指南"}],["meta",{"property":"og:title","content":"动图图解！既然IP层会分片，为什么TCP层也还要分段？"}],["meta",{"property":"og:description","content":" 什么是 TCP 分段和 IP 分片 我们知道网络就像一根管子，而管子吧，就会有粗细。 一个数据包想从管子的一端到另一端，得过这个管子。 但数据包的量有大有小，想过管子，数据包不能大于这根管子的粗细。 问题来了，数据包过大时怎么办？ 答案比较简单。会把数据包切分小块。这样数据就可以由大变小，顺利传输。 数据分片数据分片 回去看下网络分层协议，数据先过传..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2024-03-04T07:59:24.000Z"}],["meta",{"property":"article:published_time","content":"2021-05-25T22:57:55.000Z"}],["meta",{"property":"article:modified_time","content":"2024-03-04T07:59:24.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"动图图解！既然IP层会分片，为什么TCP层也还要分段？\\",\\"image\\":[\\"\\"],\\"datePublished\\":\\"2021-05-25T22:57:55.000Z\\",\\"dateModified\\":\\"2024-03-04T07:59:24.000Z\\",\\"author\\":[]}"]]},"headers":[{"level":2,"title":"什么是 TCP 分段和 IP 分片","slug":"什么是-tcp-分段和-ip-分片","link":"#什么是-tcp-分段和-ip-分片","children":[]},{"level":2,"title":"MSS 是什么","slug":"mss-是什么","link":"#mss-是什么","children":[{"level":3,"title":"如何查看 MSS？","slug":"如何查看-mss","link":"#如何查看-mss","children":[]},{"level":3,"title":"三次握手中协商了 MSS 就不会改变了吗？","slug":"三次握手中协商了-mss-就不会改变了吗","link":"#三次握手中协商了-mss-就不会改变了吗","children":[]},{"level":3,"title":"对端不传 MSS 会怎么样？","slug":"对端不传-mss-会怎么样","link":"#对端不传-mss-会怎么样","children":[]}]},{"level":2,"title":"MTU 是什么","slug":"mtu-是什么","link":"#mtu-是什么","children":[{"level":3,"title":"如何查看 MTU","slug":"如何查看-mtu","link":"#如何查看-mtu","children":[]},{"level":3,"title":"为什么 MTU 一般是 1500","slug":"为什么-mtu-一般是-1500","link":"#为什么-mtu-一般是-1500","children":[]}]},{"level":2,"title":"为什么 IP 层会分片，TCP 还要分段","slug":"为什么-ip-层会分片-tcp-还要分段","link":"#为什么-ip-层会分片-tcp-还要分段","children":[]},{"level":2,"title":"TCP 分段了，IP 层就一定不会分片了吗","slug":"tcp-分段了-ip-层就一定不会分片了吗","link":"#tcp-分段了-ip-层就一定不会分片了吗","children":[]},{"level":2,"title":"IP 层怎么做到不分片","slug":"ip-层怎么做到不分片","link":"#ip-层怎么做到不分片","children":[]},{"level":2,"title":"总结","slug":"总结","link":"#总结","children":[]},{"level":2,"title":"文章推荐：","slug":"文章推荐","link":"#文章推荐","children":[]},{"level":2,"title":"最后","slug":"最后","link":"#最后","children":[]}],"git":{"createdTime":1708315055000,"updatedTime":1709539164000,"contributors":[{"name":"xiaobai","email":"xiaobaidebug@gmail.com","commits":3}]},"readingTime":{"minutes":11.42,"words":3426},"filePathRelative":"计算机基础/网络基础/核心知识点/动图图解！既然IP层会分片，为什么TCP层也还要分段？.md","localizedDate":"2021年5月25日","autoDesc":true}');export{b as comp,C as data};
