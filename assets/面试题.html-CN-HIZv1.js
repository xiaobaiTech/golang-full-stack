import{_ as e}from"./plugin-vue_export-helper-DlAUqK2U.js";import{o as n,c as i,e as t}from"./app-CXuySPgb.js";const r={},a=t(`<h1 id="nginx-面试题" tabindex="-1"><a class="header-anchor" href="#nginx-面试题"><span>Nginx 面试题</span></a></h1><h2 id="nginx-是如何实现高并发的" tabindex="-1"><a class="header-anchor" href="#nginx-是如何实现高并发的"><span>Nginx 是如何实现高并发的？</span></a></h2><p>如果一个 server 采用一个进程(或者线程)负责一个 request 的方式，那么进 程数就是并发数。那么显而易见的，就是会有很多进程在等待中。等什么？最 多的应该是等待网络传输。其缺点胖友应该也感觉到了，此处不述。</p><p>而 Nginx 的异步非阻塞工作方式正是利用了这点等待的时间。在需要等待的 时候，这些进程就空闲出来待命了。因此表现为少数几个进程就解决了大量的 并发问题。</p><p>Nginx 是如何利用的呢，简单来说：同样的 4 个进程，如果采用一个进程负 责一个 request 的方式，那么，同时进来 4 个 request 之后，每个进程就 负责其中一个，直至会话关闭。期间，如果有第 5 个 request 进来了。就无 法及时反应了，因为 4 个进程都没干完活呢，因此，一般有个调度进程，每当 新进来了一个 request ，就新开个进程来处理。</p><p>Nginx 不这样，每进来一个 request ，会有一个 worker 进程去处理。但不 是全程的处理，处理到什么程度呢？处理到可能发生阻塞的地方，比如向上游 （后端）服务器转发 request ，并等待请求返回。那么，这个处理的 worker 不会这么傻等着，他会在发送完请求后，注册一个事件：“如果 upstream 返 回了，告诉我一声，我再接着干”。于是他就休息去了。此时，如果再有 request 进来，他就可以很快再按这种方式处理。而一旦上游服务器返回了， 就会触发这个事件，worker 才会来接手，这个 request 才会接着往下走。 <strong>这就是为什么说，Nginx 基于事件模型。</strong></p><p>由于 web server 的工作性质决定了每个 request 的大部份生命都是在网络 传输中，实际上花费在 server 机器上的时间片不多。这是几个进程就解决高 并发的秘密所在。即：</p><p><strong>webserver 刚好属于网络 IO 密集型应用，不算是计算密集型。异步，非阻 塞，使用 epol- ，和大量细节处的优化，也正是 Nginx 之所以然的技术基 石。</strong></p><h2 id="请解释-nginx-如何处理-http-请求。" tabindex="-1"><a class="header-anchor" href="#请解释-nginx-如何处理-http-请求。"><span>请解释 Nginx 如何处理 HTTP 请求。</span></a></h2><p>Nginx 使用反应器模式。主事件循环等待操作系统发出准备事件的信号，这样 数据就可以从套接字读取，在该实例中读取到缓冲区并进行处理。单个线程可 以提供数万个并发连接。</p><h2 id="为什么要做动、静分离" tabindex="-1"><a class="header-anchor" href="#为什么要做动、静分离"><span>为什么要做动、静分离？</span></a></h2><p>在我们的软件开发中，有些请求是需要后台处理的（如：.jsp,.do 等等），有些 请求是不需要经过后台处理的（如：css、html、jpg、js 等等），这些不需要 经过后台处理的文件称为静态文件，否则动态文件。因此我们后台处理忽略静 态文件，但是如果直接忽略静态文件的话，后台的请求次数就明显增多了。在 我们对资源的响应速度有要求的时候，应该使用这种动静分离的策略去解决</p><p>动、静分离将网站静态资源（HTML，JavaScript，CSS 等）与后台应用分开 部署，提高用户访问静态代码的速度，降低对后台应用访问。这里将静态资源 放到 nginx 中，动态资源转发到 tomcat 服务器中,毕竟 Tomcat 的优势是处理 动态请求。</p><h2 id="nginx-是如何实现高并发的-1" tabindex="-1"><a class="header-anchor" href="#nginx-是如何实现高并发的-1"><span>nginx 是如何实现高并发的？</span></a></h2><p>一个主进程，多个工作进程，每个工作进程可以处理多个请求，每进来一个 request，会有一个 worker 进程去处理。但不是全程的处理，处理到可能发生 阻塞的地方，比如向上游（后端）服务器转发 request，并等待请求返回。那 么，这个处理的 worker 继续处理其他请求，而一旦上游服务器返回了，就会 触发这个事件，worker 才会来接手，这个 request 才会接着往下走。由于 web server 的工作性质决定了每个 request 的大部份生命都是在网络传输中， 实际上花费在 server 机器上的时间片不多。这是几个进程就解决高并发的秘密 所在。即 webserver 刚好属于网络 IO 密集型应用，不算是计算密集型。</p><h2 id="nginx-静态资源" tabindex="-1"><a class="header-anchor" href="#nginx-静态资源"><span>Nginx 静态资源?</span></a></h2><p>静态资源访问，就是存放在 nginx 的 html 页面，我们可以自己编写。</p><h2 id="nginx-配置高可用性怎么配置" tabindex="-1"><a class="header-anchor" href="#nginx-配置高可用性怎么配置"><span>Nginx 配置高可用性怎么配置？</span></a></h2><p>当上游服务器(真实访问服务器)，一旦出现故障或者是没有及时相应的话，应</p><p>该直接轮训到下一台服务器，保证服务器的高可用。</p><p>Nginx 配置代码：</p><div class="language-text line-numbers-mode" data-ext="text" data-title="text"><pre class="language-text"><code>server { 

     listen 80; 

     server\\_name www.lijie.com;cc  nginx 发送给上游服务器(真实访问的服 务器)超时时间 

         proxy\\_send\\_timeout 1s;###

         nginx 接受上游服务器(真实访问的服务器)超时时间 

         proxy\\_read\\_timeout 1s;

         index index.html index.htm;

     } 

} 
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="_502-错误可能原因" tabindex="-1"><a class="header-anchor" href="#_502-错误可能原因"><span>502 错误可能原因</span></a></h2><ul><li><p>FastCGI 进程是否已经启动</p></li><li><p>FastCGI worker 进程数是否不够</p></li><li><p>FastCGI 执行时间过长</p></li><li><p>fastcgi_connect_timeout 300; - fastcgi_send_timeout 300;</p></li><li><p>fastcgi_read_timeout 300;</p></li><li><p>FastCGI Buffer 不够</p></li><li><p>nginx 和 apache 一样，有前端缓冲限制，可以调整缓冲参数 - fastcgi_buffer_size 32k;</p></li><li><p>fastcgi_buffers 8 32k;</p></li><li><p>Proxy Buffer 不够</p></li><li><p>如果你用了 Proxying，调整</p></li><li><p>proxy_buffer_size 16k;</p></li><li><p>proxy_buffers 4 16k;</p></li><li><p>php 脚本执行时间过长</p></li><li><p>将 php-fpm.conf 的 0s 的 0s 改成一个时间</p></li></ul><h2 id="在-nginx-中-解释如何在-url-中保留双斜线" tabindex="-1"><a class="header-anchor" href="#在-nginx-中-解释如何在-url-中保留双斜线"><span>在 Nginx 中，解释如何在 URL 中保留双斜线?</span></a></h2><p>要在 URL 中保留双斜线，就必须使用 语法:merge_slashes [on/off] 默认值: merge_slashes on</p><p>环境: http，server</p><p> merge_slashes_off;</p><h2 id="nginx-服务器上的-master-和-worker-进程分别是什么" tabindex="-1"><a class="header-anchor" href="#nginx-服务器上的-master-和-worker-进程分别是什么"><span>Nginx 服务器上的 Master 和 Worker 进程分别是什么?</span></a></h2><p>Master 进程：读取及评估配置和维持 ；Worker 进程：处理请求。</p><h2 id="nginx-的优缺点" tabindex="-1"><a class="header-anchor" href="#nginx-的优缺点"><span>Nginx 的优缺点？</span></a></h2><p>优点：</p><ul><li><p>占内存小，可实现高并发连接，处理响应快。</p></li><li><p>可实现 HTTP 服务器、虚拟主机、方向代理、负载均衡。 - Nginx 配置简单。</p></li><li><p>可以不暴露正式的服务器 IP 地址。</p></li></ul><p>缺点：</p><p>动态处理差，nginx 处理静态文件好,耗费内存少，但是处理动态页面则很鸡 肋，现在一般前端用 nginx 作为反向代理抗住压力。</p>`,35),l=[a];function s(p,o){return n(),i("div",null,l)}const c=e(r,[["render",s],["__file","面试题.html.vue"]]),x=JSON.parse('{"path":"/%E4%B8%AD%E9%97%B4%E4%BB%B6/nginx/%E9%9D%A2%E8%AF%95%E9%A2%98.html","title":"Nginx  面试题","lang":"zh-CN","frontmatter":{"description":"Nginx 面试题 Nginx 是如何实现高并发的？ 如果一个 server 采用一个进程(或者线程)负责一个 request 的方式，那么进 程数就是并发数。那么显而易见的，就是会有很多进程在等待中。等什么？最 多的应该是等待网络传输。其缺点胖友应该也感觉到了，此处不述。 而 Nginx 的异步非阻塞工作方式正是利用了这点等待的时间。在需要等待的 时...","head":[["meta",{"property":"og:url","content":"https://golangguide.top/%E4%B8%AD%E9%97%B4%E4%BB%B6/nginx/%E9%9D%A2%E8%AF%95%E9%A2%98.html"}],["meta",{"property":"og:site_name","content":"golang全栈指南"}],["meta",{"property":"og:title","content":"Nginx  面试题"}],["meta",{"property":"og:description","content":"Nginx 面试题 Nginx 是如何实现高并发的？ 如果一个 server 采用一个进程(或者线程)负责一个 request 的方式，那么进 程数就是并发数。那么显而易见的，就是会有很多进程在等待中。等什么？最 多的应该是等待网络传输。其缺点胖友应该也感觉到了，此处不述。 而 Nginx 的异步非阻塞工作方式正是利用了这点等待的时间。在需要等待的 时..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2024-02-13T08:18:41.000Z"}],["meta",{"property":"article:author","content":"小白debug"}],["meta",{"property":"article:modified_time","content":"2024-02-13T08:18:41.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"Nginx  面试题\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2024-02-13T08:18:41.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"小白debug\\",\\"url\\":\\"https://xiaobaidebug.top/\\"}]}"],["link",{"rel":"canonical","href":"https://golangguide.top/%E4%B8%AD%E9%97%B4%E4%BB%B6/nginx/%E9%9D%A2%E8%AF%95%E9%A2%98.html"}],["meta",{"property":"og:url","content":"https://golangguide.top/%E4%B8%AD%E9%97%B4%E4%BB%B6/nginx/%E9%9D%A2%E8%AF%95%E9%A2%98.html"}],["meta",{"property":"og:site_name","content":"golang全栈指南"}],["meta",{"property":"og:title","content":"Nginx  面试题"}],["meta",{"property":"og:description","content":"Nginx 面试题 Nginx 是如何实现高并发的？ 如果一个 server 采用一个进程(或者线程)负责一个 request 的方式，那么进 程数就是并发数。那么显而易见的，就是会有很多进程在等待中。等什么？最 多的应该是等待网络传输。其缺点胖友应该也感觉到了，此处不述。 而 Nginx 的异步非阻塞工作方式正是利用了这点等待的时间。在需要等待的 时..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2024-02-13T08:18:41.000Z"}],["meta",{"property":"article:modified_time","content":"2024-02-13T08:18:41.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"Nginx  面试题\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2024-02-13T08:18:41.000Z\\",\\"author\\":[]}"]]},"headers":[{"level":2,"title":"Nginx  是如何实现高并发的？","slug":"nginx-是如何实现高并发的","link":"#nginx-是如何实现高并发的","children":[]},{"level":2,"title":"请解释  Nginx  如何处理  HTTP  请求。","slug":"请解释-nginx-如何处理-http-请求。","link":"#请解释-nginx-如何处理-http-请求。","children":[]},{"level":2,"title":"为什么要做动、静分离？","slug":"为什么要做动、静分离","link":"#为什么要做动、静分离","children":[]},{"level":2,"title":"nginx 是如何实现高并发的？","slug":"nginx-是如何实现高并发的-1","link":"#nginx-是如何实现高并发的-1","children":[]},{"level":2,"title":"Nginx 静态资源?","slug":"nginx-静态资源","link":"#nginx-静态资源","children":[]},{"level":2,"title":"Nginx 配置高可用性怎么配置？","slug":"nginx-配置高可用性怎么配置","link":"#nginx-配置高可用性怎么配置","children":[]},{"level":2,"title":"502 错误可能原因","slug":"_502-错误可能原因","link":"#_502-错误可能原因","children":[]},{"level":2,"title":"在  Nginx  中，解释如何在  URL 中保留双斜线?","slug":"在-nginx-中-解释如何在-url-中保留双斜线","link":"#在-nginx-中-解释如何在-url-中保留双斜线","children":[]},{"level":2,"title":"Nginx 服务器上的 Master 和 Worker 进程分别是什么?","slug":"nginx-服务器上的-master-和-worker-进程分别是什么","link":"#nginx-服务器上的-master-和-worker-进程分别是什么","children":[]},{"level":2,"title":"Nginx 的优缺点？","slug":"nginx-的优缺点","link":"#nginx-的优缺点","children":[]}],"git":{"createdTime":1707812321000,"updatedTime":1707812321000,"contributors":[{"name":"xiaobai","email":"xiaobaidebug@gmail.com","commits":1}]},"readingTime":{"minutes":5.37,"words":1611},"filePathRelative":"中间件/nginx/面试题.md","localizedDate":"2024年2月13日","autoDesc":true}');export{c as comp,x as data};
