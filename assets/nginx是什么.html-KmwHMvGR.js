import{_ as n,c as i,a as g,o}from"./app-YFeEz-zg.js";const a={};function e(r,t){return o(),i("div",null,t[0]||(t[0]=[g('<h1 id="nginx-是什么-nginx高并发架构拆解指南" tabindex="-1"><a class="header-anchor" href="#nginx-是什么-nginx高并发架构拆解指南"><span>Nginx 是什么？Nginx高并发架构拆解指南</span></a></h1><p>你是一个程序员，你在电脑上编辑了一段文本，将它保存为 <strong>txt 文件</strong>。将它拖到浏览器打开，就能看到文件里的内容。</p><p>但这看起来太过单调，为了让画面更丰富，我们定个规则，在文本边上加个两个h1符号，文本就以<strong>标题</strong>形式展示。</p><p>加入ul和li就能变成<strong>列表</strong>，加入img还能让<strong>url文本</strong>直接变成对应的<strong>图片</strong>。</p><figure><img src="https://cdn.xiaobaidebug.top/1743944617670.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>这些带尖括号的特殊符号，我们叫它<strong>标签</strong>。只要浏览器识别到这些标签，就展示对应的样式。</p><p>为了将这个自带标签的文本跟 txt 纯文本区分开来，我们给了它新的后缀名, <strong>html</strong>。</p><p>浏览器只要识别到文件是 html，就会解析里面的标签，这样我们就有了标题、输入框等各种丰富的内容了。这其实就是我们平时在浏览器中看到的<strong>网页</strong>。</p><p>但不同的是，这个 html 文件是浏览器从我们<strong>本地</strong>电脑文件中打开的。</p><figure><img src="https://cdn.xiaobaidebug.top/1743946289656.png" alt="本地浏览器打开html" tabindex="0" loading="lazy"><figcaption>本地浏览器打开html</figcaption></figure><p>而我们平时访问的网页，则是从<strong>某台远端服务器</strong>，将文件传到我们电脑的浏览器后打开的。</p><figure><img src="https://cdn.xiaobaidebug.top/1743946309031.png" alt="从远端服务器得到html打开" tabindex="0" loading="lazy"><figcaption>从远端服务器得到html打开</figcaption></figure><p>那么问题就来了，我们是<strong>怎么获得这个远端服务器上的 html 文件的</strong>？</p><p><strong>没有什么是加一层中间层不能解决的，如果有，那就再加一层</strong>，这次我们要加的中间层是 <strong>Nginx</strong>.</p><figure><img src="https://cdn.xiaobaidebug.top/1743946388452.png" alt="nginx中间层" tabindex="0" loading="lazy"><figcaption>nginx中间层</figcaption></figure><p>假设我们完全不了解 nginx，来看下它是怎么设计出来的。</p><h2 id="http-服务器是什么" tabindex="-1"><a class="header-anchor" href="#http-服务器是什么"><span>HTTP 服务器是什么？</span></a></h2><p>想要让本地的浏览器，获取到放在远端服务器上的 html 文件。</p><p>那很简单，我们可以在远端服务器启动一个<strong>进程</strong>，这个进程对外提供 <strong>http 服务</strong>，说白了就是提供了个 <strong>url</strong>。</p><p>用户在浏览器中输入这个 url， 回车，浏览器就会向 这个进程发起 <strong>http 请求</strong>，</p><p>进程收到浏览器的请求后，就将 html 文件发给浏览器，浏览器完成解析和展示，完美。</p><p>而像这种根据浏览器请求，返回 html 文件的服务进程，其实就叫 <strong>http 服务器</strong>。</p><p>有了它，前端开发老哥写的各种 html 文件就能部署到远端服务器上，<strong>对外提供网页服务</strong>了。</p><figure><img src="https://cdn.xiaobaidebug.top/1743946436086.png" alt="http服务器是什么" tabindex="0" loading="lazy"><figcaption>http服务器是什么</figcaption></figure><h2 id="反向代理是什么" tabindex="-1"><a class="header-anchor" href="#反向代理是什么"><span>反向代理是什么？</span></a></h2><p>但一个完整产品往往不止有<strong>前端页面</strong>，还有<strong>后端服务</strong>，比如某宝，前端商城页面需要从后端服务那获取最新的商品数据。</p><figure><img src="https://cdn.xiaobaidebug.top/1743946472244.png" alt="前后端分离" tabindex="0" loading="lazy"><figcaption>前后端分离</figcaption></figure><p>假设现在前端页面已经被加载到浏览器中，浏览器会按页面里写好的代码逻辑，向后端商品服务发起请求，获取数据，流量小的时候没什么问题，流量变大后，后端服务器扛不住的话，就需要增加商品服务的个数，服务变多后，每个都有对应的 ip 和端口，浏览器就不知道该访问哪个服务了。</p><p>所以我们还需要<strong>在这几个后端服务前面加一个进程</strong>，对外提供一个 url 域名，请求来了，由这个进程均匀转发给背后的几个服务，让每个服务都能处理上请求，也就实现了所谓的<strong>负载均衡</strong>。</p><p>像这种，<strong>屏蔽掉背后具体有哪些服务器的代理方式，就是我们常说的反向代理</strong>。</p><figure><img src="https://cdn.xiaobaidebug.top/1743946501135.png" alt="反向代理" tabindex="0" loading="lazy"><figcaption>反向代理</figcaption></figure><p>有了反向代理，我们对外就可以只提供一个url域名，背后根据需要, 随时<strong>扩缩容服务</strong>。</p><p>这个反向代理的功能，正好可以加到前面放 html 文件的进程上。</p><p>那现在这个进程就很灵性了，既可以为 前端 html 文件提供 http 服务器的功能，当 html 文件被加载到浏览器，并向后端发起请求的时候，这个进程还能为后端服务器提供反向代理的功能。</p><figure><img src="https://cdn.xiaobaidebug.top/1743946526585.png" alt="http服务器+反向代理" tabindex="0" loading="lazy"><figcaption>http服务器+反向代理</figcaption></figure><h2 id="模块化网关能力" tabindex="-1"><a class="header-anchor" href="#模块化网关能力"><span>模块化网关能力</span></a></h2><p>既然是中间层，所有网络流量都要经过进程，那它高低也算个<strong>网关</strong>了。</p><figure><img src="https://cdn.xiaobaidebug.top/1743946552587.png" alt="网关" tabindex="0" loading="lazy"><figcaption>网关</figcaption></figure><p>于是我们就可以顺理成章的在它上面加入一些<strong>通用网关能力</strong>，比如加个<strong>日志</strong>，记录每次调用的结果，方便后续排查问题，又比如加个对输入输出的内容进行<strong>压缩</strong>的功能，减小网络带宽消耗，又或者是对某个 IP 进行<strong>限流或封禁</strong>，甚至还可以<strong>修改输入输出</strong>的内容。能实现的功能实在太多，想象空间很大，于是将这部分功能设计为<strong>开放接口</strong>，让用户通过<strong>自定义模块</strong>来实现特定功能。</p><p>这还不够，现在这个网关只支持http，我们其实还能扩展下，让它支持tcp，udp，http2和websocket，你能想到的我都要支持，我本来不支持的，自会有人通过自定义模块帮我支持。</p><figure><img src="https://cdn.xiaobaidebug.top/1743946570528.png" alt="支持多种通用能力和协议" tabindex="0" loading="lazy"><figcaption>支持多种通用能力和协议</figcaption></figure><h2 id="配置能力" tabindex="-1"><a class="header-anchor" href="#配置能力"><span>配置能力</span></a></h2><p>前面提到那么多种能力，用户肯定不会全用上，所以需要有个地方让人选择用哪些能力，于是我们可以加个配置文件，也就是<strong>nginx.conf</strong>，用户想用什么能力，就在配置文件上声明清楚就行，非常方便。</p><figure><img src="https://cdn.xiaobaidebug.top/1743946608632.png" alt="nginx.conf配置" tabindex="0" loading="lazy"><figcaption>nginx.conf配置</figcaption></figure><h2 id="单线程" tabindex="-1"><a class="header-anchor" href="#单线程"><span>单线程</span></a></h2><p>现在这个网关进程的主要任务就是跟上下游建立网络连接，顺便内部做下处理。多个客户端请求通过网络进入到一个进程，如果用多线程并发处理，那就需要考虑并发问题，同时影响性能。怎么办呢？</p><figure><img src="https://cdn.xiaobaidebug.top/1743946626730.png" alt="多线程" tabindex="0" loading="lazy"><figcaption>多线程</figcaption></figure><p>很简单！外部不管有多少有个网络连接，网关进程收到客户端请求后，都统一塞到<strong>一个线程</strong>上，在一个线程上处理客户端请求，什么<strong>并发问题</strong>和<strong>线程切换开销</strong>，完全不存在！</p><figure><img src="https://cdn.xiaobaidebug.top/1743946648967.png" alt="单线程" tabindex="0" loading="lazy"><figcaption>单线程</figcaption></figure><h2 id="多-worker-进程" tabindex="-1"><a class="header-anchor" href="#多-worker-进程"><span>多 worker 进程</span></a></h2><p>但单个进程要单线程处理那么多流量，哪怕再快，压力也不小，万一这里面有美羊羊发的流量，你觊觎那么久？怎么忍心让她久等？沸羊羊你说话！</p><p>怎么办呢？既然多线程不行，那我们就上<strong>多进程</strong>。</p><p>于是可以将单个进程改成多个进程，我们管它们叫 <strong>worker 进程</strong>。进程之间互相独立，一个 worker 跪了不影响另外一个 worker 进程。</p><figure><img src="https://cdn.xiaobaidebug.top/1743946668856.png" alt="多worker进程" tabindex="0" loading="lazy"><figcaption>多worker进程</figcaption></figure><p>让多个 worker 进程同时监听一个 ip 地址+端口。只要一有流量进来，操作系统就会随机给到其中一个进程处理。将<strong>进程数量</strong>设置为跟操作系统<strong>cpu核数</strong>一致，那每个进程都能得到一个核，开足马力猛猛干。</p><figure><img src="https://cdn.xiaobaidebug.top/1743946688522.png" alt="worker数与核数一致" tabindex="0" loading="lazy"><figcaption>worker数与核数一致</figcaption></figure><blockquote><p>看到这里，问题就来了，为什么多个进程同时监听一个端口不会出现<strong>端口冲突</strong>（port is already in use），评论区告诉我答案。</p></blockquote><h2 id="共享内存" tabindex="-1"><a class="header-anchor" href="#共享内存"><span>共享内存</span></a></h2><p>但多 worker 进程的情况下，同一个客户端的多个请求会随机打到某个 worker ，对于限流这种需要计数的场景，就会被分散到多个 worker 上单独计数，那还怎么限流，所以还需要给这些 worker 进程 分配一个<strong>共享内存</strong>区域，方便多个进程之间共用同一份数据做逻辑，确保系统数据一致性。</p><figure><img src="https://cdn.xiaobaidebug.top/1743946712497.png" alt="共享内存" tabindex="0" loading="lazy"><figcaption>共享内存</figcaption></figure><h2 id="proxy-cache" tabindex="-1"><a class="header-anchor" href="#proxy-cache"><span>proxy cache</span></a></h2><p>作为网关，它在收到前端网页请求后，会转发给后端，并将后端处理结果中转给前端。如果它能<strong>将响应结果缓存</strong>起来，这样下次收到<strong>同样的请求</strong>，直接将缓存里的数据返回给前端，从而<strong>减少响应时间和网络负载</strong>。</p><p>那这个数据是放在共享内存里吗？内存贵，不合适，我们可以维护些磁盘文件，用于在前端请求后端的过程中，暂存后端响应的结果，后面再有相同请求，就可以将磁盘里的数据返回。</p><p>这又是经典的<strong>空间换时间</strong>，用廉价的磁盘空间换取网络传输和cpu计算耗时。对于后端响应较慢或重复请求较多的场景，读写磁盘总归比直接将请求打到后端来得快。这些<strong>用于缓存响应数据的磁盘文件</strong>，就是 所谓的<strong>proxy cache</strong> 。</p><figure><img src="https://cdn.xiaobaidebug.top/1743946726056.png" alt="proxy cache" tabindex="0" loading="lazy"><figcaption>proxy cache</figcaption></figure><h2 id="加入-master-进程" tabindex="-1"><a class="header-anchor" href="#加入-master-进程"><span>加入 master 进程</span></a></h2><p>但这还不够，现在每个 worker 都会分走一部分流量，如果功能更新，所有 worker 同时一起重启，上面的网络连接就会全部断掉。更好的方式是创建 worker 和关闭 worker 挨个陆续执行，这样前端网页连接断开后还能去连另外一个worker，保证任意时间一直有worker在工作。也就是所谓的<strong>滚动升级</strong>。因此还需要一个新的进程协调各个 worker 谁先谁后，这个<strong>协调进程</strong>，就是所谓的 <strong>master 进程</strong>。让master读取前面提到的<strong>nginx.conf</strong>配置，统一管理多个worker。</p><figure><img src="https://cdn.xiaobaidebug.top/1743946749353.png" alt="master进程" tabindex="0" loading="lazy"><figcaption>master进程</figcaption></figure><h2 id="nginx-是什么" tabindex="-1"><a class="header-anchor" href="#nginx-是什么"><span>nginx 是什么</span></a></h2><p>好啦，到这里，当初那个简陋的单进程网关服务，就变成了一个支持动态配置多种通用网关能力和多种网络协议，单 master 多 worker 架构、多个worker进程之间共享内存和proxy cache，对外提供一个IP+端口，支持 http 服务器和反向代理的高性能网关服务。</p><p>它就是所谓的 <strong>nginx</strong>。</p><figure><img src="https://cdn.xiaobaidebug.top/1743946772057.png" alt="nginx是什么" tabindex="0" loading="lazy"><figcaption>nginx是什么</figcaption></figure><p>它不仅支持日志、限流等各种通用能力、还支持自定义网关能力，只要你写好配置，就能让它给你当牛做马。性能上 5w qps 非常轻松，应付你那只有几十 qps 的服务更是绰绰有余了。</p><p>现在大家通了吗？好啦，如果你觉得这个视频对你有帮助，记得点赞并转发给你那不成器的兄弟，文字版的笔记见评论区。</p><p>最后遗留一个问题，想必大家也发现了，聊到现在它其实也只是某台服务器上的多个进程，一旦服务器跪了，nginx 也就跪了，存在<strong>单点问题</strong>。</p><figure><img src="https://cdn.xiaobaidebug.top/1743946788794.png" alt="nginx单点问题" tabindex="0" loading="lazy"><figcaption>nginx单点问题</figcaption></figure><p>那<strong>怎么解决 nginx 的单点问题</strong>呢？<strong>nginx 有集群模式</strong>吗？评论区告诉我答案。</p><p>最后的最后再遗留一个问题，你听说过大数据吗？你知道大家是怎么解决大数据问题的吗？</p><p>点赞超过 1w，下期聊聊这个话题，如果你感兴趣，记得关注。我们下期见！</p>',79)]))}const s=n(a,[["render",e],["__file","nginx是什么.html.vue"]]),c=JSON.parse('{"path":"/%E4%B8%AD%E9%97%B4%E4%BB%B6/nginx/%E6%A0%B8%E5%BF%83%E7%9F%A5%E8%AF%86%E7%82%B9/nginx%E6%98%AF%E4%BB%80%E4%B9%88.html","title":"Nginx 是什么？Nginx高并发架构拆解指南","lang":"zh-CN","frontmatter":{"description":"Nginx 是什么？Nginx高并发架构拆解指南 你是一个程序员，你在电脑上编辑了一段文本，将它保存为 txt 文件。将它拖到浏览器打开，就能看到文件里的内容。 但这看起来太过单调，为了让画面更丰富，我们定个规则，在文本边上加个两个h1符号，文本就以标题形式展示。 加入ul和li就能变成列表，加入img还能让url文本直接变成对应的图片。 这些带尖括号...","head":[["meta",{"property":"og:url","content":"https://golangguide.top/%E4%B8%AD%E9%97%B4%E4%BB%B6/nginx/%E6%A0%B8%E5%BF%83%E7%9F%A5%E8%AF%86%E7%82%B9/nginx%E6%98%AF%E4%BB%80%E4%B9%88.html"}],["meta",{"property":"og:site_name","content":"golang全栈指南"}],["meta",{"property":"og:title","content":"Nginx 是什么？Nginx高并发架构拆解指南"}],["meta",{"property":"og:description","content":"Nginx 是什么？Nginx高并发架构拆解指南 你是一个程序员，你在电脑上编辑了一段文本，将它保存为 txt 文件。将它拖到浏览器打开，就能看到文件里的内容。 但这看起来太过单调，为了让画面更丰富，我们定个规则，在文本边上加个两个h1符号，文本就以标题形式展示。 加入ul和li就能变成列表，加入img还能让url文本直接变成对应的图片。 这些带尖括号..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:image","content":"https://cdn.xiaobaidebug.top/1743944617670.png"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2025-04-12T06:39:24.000Z"}],["meta",{"name":"twitter:card","content":"summary_large_image"}],["meta",{"name":"twitter:image:alt","content":"Nginx 是什么？Nginx高并发架构拆解指南"}],["meta",{"property":"article:author","content":"小白debug"}],["meta",{"property":"article:modified_time","content":"2025-04-12T06:39:24.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"Nginx 是什么？Nginx高并发架构拆解指南\\",\\"image\\":[\\"https://cdn.xiaobaidebug.top/1743944617670.png\\",\\"https://cdn.xiaobaidebug.top/1743946289656.png\\",\\"https://cdn.xiaobaidebug.top/1743946309031.png\\",\\"https://cdn.xiaobaidebug.top/1743946388452.png\\",\\"https://cdn.xiaobaidebug.top/1743946436086.png\\",\\"https://cdn.xiaobaidebug.top/1743946472244.png\\",\\"https://cdn.xiaobaidebug.top/1743946501135.png\\",\\"https://cdn.xiaobaidebug.top/1743946526585.png\\",\\"https://cdn.xiaobaidebug.top/1743946552587.png\\",\\"https://cdn.xiaobaidebug.top/1743946570528.png\\",\\"https://cdn.xiaobaidebug.top/1743946608632.png\\",\\"https://cdn.xiaobaidebug.top/1743946626730.png\\",\\"https://cdn.xiaobaidebug.top/1743946648967.png\\",\\"https://cdn.xiaobaidebug.top/1743946668856.png\\",\\"https://cdn.xiaobaidebug.top/1743946688522.png\\",\\"https://cdn.xiaobaidebug.top/1743946712497.png\\",\\"https://cdn.xiaobaidebug.top/1743946726056.png\\",\\"https://cdn.xiaobaidebug.top/1743946749353.png\\",\\"https://cdn.xiaobaidebug.top/1743946772057.png\\",\\"https://cdn.xiaobaidebug.top/1743946788794.png\\"],\\"dateModified\\":\\"2025-04-12T06:39:24.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"小白debug\\",\\"url\\":\\"https://xiaobaidebug.top/\\"}]}"],["link",{"rel":"canonical","href":"https://golangguide.top/%E4%B8%AD%E9%97%B4%E4%BB%B6/nginx/%E6%A0%B8%E5%BF%83%E7%9F%A5%E8%AF%86%E7%82%B9/nginx%E6%98%AF%E4%BB%80%E4%B9%88.html"}],["meta",{"property":"og:url","content":"https://golangguide.top/%E4%B8%AD%E9%97%B4%E4%BB%B6/nginx/%E6%A0%B8%E5%BF%83%E7%9F%A5%E8%AF%86%E7%82%B9/nginx%E6%98%AF%E4%BB%80%E4%B9%88.html"}],["meta",{"property":"og:site_name","content":"golang全栈指南"}],["meta",{"property":"og:title","content":"Nginx 是什么？Nginx高并发架构拆解指南"}],["meta",{"property":"og:description","content":"Nginx 是什么？Nginx高并发架构拆解指南 你是一个程序员，你在电脑上编辑了一段文本，将它保存为 txt 文件。将它拖到浏览器打开，就能看到文件里的内容。 但这看起来太过单调，为了让画面更丰富，我们定个规则，在文本边上加个两个h1符号，文本就以标题形式展示。 加入ul和li就能变成列表，加入img还能让url文本直接变成对应的图片。 这些带尖括号..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2025-04-12T06:39:24.000Z"}],["meta",{"property":"article:modified_time","content":"2025-04-12T06:39:24.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"Nginx 是什么？Nginx高并发架构拆解指南\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2025-04-12T06:39:24.000Z\\",\\"author\\":[]}"]]},"headers":[{"level":2,"title":"HTTP 服务器是什么？","slug":"http-服务器是什么","link":"#http-服务器是什么","children":[]},{"level":2,"title":"反向代理是什么？","slug":"反向代理是什么","link":"#反向代理是什么","children":[]},{"level":2,"title":"模块化网关能力","slug":"模块化网关能力","link":"#模块化网关能力","children":[]},{"level":2,"title":"配置能力","slug":"配置能力","link":"#配置能力","children":[]},{"level":2,"title":"单线程","slug":"单线程","link":"#单线程","children":[]},{"level":2,"title":"多 worker 进程","slug":"多-worker-进程","link":"#多-worker-进程","children":[]},{"level":2,"title":"共享内存","slug":"共享内存","link":"#共享内存","children":[]},{"level":2,"title":"proxy cache","slug":"proxy-cache","link":"#proxy-cache","children":[]},{"level":2,"title":"加入 master 进程","slug":"加入-master-进程","link":"#加入-master-进程","children":[]},{"level":2,"title":"nginx 是什么","slug":"nginx-是什么","link":"#nginx-是什么","children":[]}],"git":{"createdTime":1744439283000,"updatedTime":1744439964000,"contributors":[{"name":"xiaobai","email":"xiaobaidebug@gmail.com","commits":2}]},"readingTime":{"minutes":9.36,"words":2807},"filePathRelative":"中间件/nginx/核心知识点/nginx是什么.md","localizedDate":"2025年4月12日","autoDesc":true}');export{s as comp,c as data};
