import{_ as a,c as o,a as e,o as i}from"./app-YFeEz-zg.js";const n={};function r(g,t){return i(),o("div",null,t[0]||(t[0]=[e('<h1 id="rocketmq-是什么-它的架构是怎么样的-和-kafka-又有什么区别" tabindex="-1"><a class="header-anchor" href="#rocketmq-是什么-它的架构是怎么样的-和-kafka-又有什么区别"><span>RocketMQ 是什么？它的架构是怎么样的？和 Kafka 又有什么区别？</span></a></h1><p>作为一个程序员，假设你有 A、B 两个服务，A 服务发出消息后，不想让 B 服务<strong>立马</strong>处理到。而是要<strong>过半小时</strong>才让 B 服务处理到，该怎么实现？<br> 这类延迟处理消息的场景非常常见，举个例子，比如我每天早上到公司后都会点个外卖，我希望外卖能在中午送过来，而不是立马送过来，这就需要将外卖消息经过延时后，再投递到商家侧。</p><figure><img src="https://cdn.xiaobaidebug.top/1716038897833.jpeg" alt="延时消息场景" tabindex="0" loading="lazy"><figcaption>延时消息场景</figcaption></figure><p>那么问题就来了，有没有优雅的解决方案？<br> 当然有，<strong>没有什么是加一层中间层不能解决的，如果有，那就再加一层</strong>。<br> 这次我们要加的中间层是消息队列 <strong>RocketMQ</strong>。</p><figure><img src="https://cdn.xiaobaidebug.top/1716038909786.jpeg" alt="RocketMQ" tabindex="0" loading="lazy"><figcaption>RocketMQ</figcaption></figure><h2 id="rocketmq-是什么" tabindex="-1"><a class="header-anchor" href="#rocketmq-是什么"><span>RocketMQ 是什么？</span></a></h2><p>RocketMQ 是阿里自研的国产<strong>消息队列</strong>，目前已经是 Apache 的顶级项目。和其他消息队列一样，它接受来自<strong>生产者</strong>的消息，将消息分类，每一类是一个 <strong>topic</strong>，<strong>消费者</strong>根据需要订阅 topic，获取里面的消息。</p><figure><img src="https://cdn.xiaobaidebug.top/1716038925501.jpeg" alt="消息队列模型" tabindex="0" loading="lazy"><figcaption>消息队列模型</figcaption></figure><p>是不是很像我们上篇文章里提到的消息队 Kafka，那么问题很自然就来了，<strong>既然都是消息队列，那它们之间有什么区别呢</strong>？</p><h2 id="rocketmq-和-kafka-的区别" tabindex="-1"><a class="header-anchor" href="#rocketmq-和-kafka-的区别"><span>RocketMQ 和 Kafka 的区别</span></a></h2><p>RocketMQ 的架构其实参考了 Kafka 的设计思想，同时又在 Kafka 的基础上做了一些调整。</p><figure><img src="https://cdn.xiaobaidebug.top/1716038944866.jpeg" alt="RocketMQ参考Kafka架构" tabindex="0" loading="lazy"><figcaption>RocketMQ参考Kafka架构</figcaption></figure><p>这些调整，用一句话总结就是，&quot;<strong>和 Kafka 相比，RocketMQ 在架构上做了减法，在功能上做了加法</strong>&quot;。我们来看下这句话的含义。</p><h2 id="在架构上做减法" tabindex="-1"><a class="header-anchor" href="#在架构上做减法"><span>在架构上做减法</span></a></h2><p>我们来简单回顾下消息队列 Kafka 的架构。<br> kakfa 也是通过多个 <code>topic</code> 对消息进行分类。</p><figure><img src="https://cdn.xiaobaidebug.top/1716039021926.jpeg" alt="topic分类" tabindex="0" loading="lazy"><figcaption>topic分类</figcaption></figure><ul><li>为了提升单个 topic 的并发<strong>性能</strong>，将<strong>单个 topic</strong> 拆为多个 <code>partition</code>。</li></ul><figure><img src="https://cdn.xiaobaidebug.top/1716039000949.jpeg" alt="partion" tabindex="0" loading="lazy"><figcaption>partion</figcaption></figure><ul><li>为了提升系统<strong>扩展性</strong>，将多个 partition 分别部署在不同 <code>broker</code> 上。</li><li>为了提升系统的<strong>可用性</strong>，为 partition 加了多个副本。</li><li>为了协调和管理 Kafka 集群的数据信息，引入<code>Zookeeper</code>作为协调节点。</li></ul><figure><img src="https://cdn.xiaobaidebug.top/1716039049814.jpeg" alt="kakfa架构" tabindex="0" loading="lazy"><figcaption>kakfa架构</figcaption></figure><p>如果你对这些依旧很陌生，可以看看上篇文章《<strong>Kafka 是什么</strong>》。<br> Kafka 已经是非常强的消息队列了，我们来看下 RocketMQ 在 Kafka 架构的基础上，还能玩出什么花样来。</p><h3 id="简化协调节点" tabindex="-1"><a class="header-anchor" href="#简化协调节点"><span>简化协调节点</span></a></h3><p><code>Zookeeper</code> 在 Kafka 架构中会和 broker 通信，维护 Kafka 集群信息。一个新的 broker 连上 Zookeeper 后，其他 broker 就能立马感知到它的加入，像这种能在分布式环境下，让多个实例同时获取到同一份信息的服务，就是所谓的<strong>分布式协调服务</strong>。</p><figure><img src="https://cdn.xiaobaidebug.top/1716039187841.jpeg" alt="Zookeeper的作用" tabindex="0" loading="lazy"><figcaption>Zookeeper的作用</figcaption></figure><p>但 Zookeeper 作为一个<strong>通用的</strong>分布式协调服务，它不仅可以用于服务注册与发现，还可以用于分布式锁、配置管理等场景。 Kafka 其实只用到了它的部分功能，多少有点<strong>杀鸡用牛刀</strong>的味道。<strong>太重了</strong>。</p><p>所以 RocketMQ 直接将 Zookeeper 去掉，换成了 <strong>nameserver</strong>，用一种更轻量的方式，管理消息队列的集群信息。生产者通过 nameserver 获取到 topic 和 broker 的路由信息，然后再与 broker 通信，实现<strong>服务发现</strong>和<strong>负载均衡</strong>的效果。</p><figure><img src="https://cdn.xiaobaidebug.top/1716039215116.jpeg" alt="nameserver是什么" tabindex="0" loading="lazy"><figcaption>nameserver是什么</figcaption></figure><p>当然，开发 Kafka 的大佬们后来也意识到了 Zookeeper 过重的问题，所以从 2.8.0 版本就支持将 Zookeeper 移除，通过 在 broker 之间加入一致性算法 raft 实现同样的效果，这就是所谓的 <strong>KRaft</strong> 或 <strong>Quorum</strong> 模式。</p><figure><img src="https://cdn.xiaobaidebug.top/1716039233839.jpeg" alt="KRaft模式" tabindex="0" loading="lazy"><figcaption>KRaft模式</figcaption></figure><h3 id="简化分区" tabindex="-1"><a class="header-anchor" href="#简化分区"><span>简化分区</span></a></h3><p>我们知道，Kafka 会将 topic 拆分为多个 partition，用来提升<strong>并发性能</strong>。</p><figure><img src="https://cdn.xiaobaidebug.top/1716039266847.jpeg" alt="partition是什么" tabindex="0" loading="lazy"><figcaption>partition是什么</figcaption></figure><p>在 RocketMQ 里也一样，将 topic 拆分成了多个分区，但换了个名字，叫 <strong>Queue</strong>,也就是&quot;<strong>队列</strong>&quot;。</p><figure><img src="https://cdn.xiaobaidebug.top/1716039283266.jpeg" alt="RocketMQ中的队列" tabindex="0" loading="lazy"><figcaption>RocketMQ中的队列</figcaption></figure><p>Kafka 中的 partition 会存储<strong>完整</strong>的消息体，而 RocketMQ 的 Queue 上却只存一些<strong>简要</strong>信息，比如消息偏移 offset，而消息的完整数据则放到&quot;一个&quot;叫 <code>commitlog</code> 的文件上，通过 offset 我们可以定位到 commitlog 上的某条消息。<br> Kafka 消费消息，broker 只需要直接从 partition 读取消息返回就好，也就是读第<strong>一次</strong>就够了。</p><figure><img src="https://cdn.xiaobaidebug.top/1716039326945.jpeg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>而在 RocketMQ 中，broker 则需要先从 Queue 上读取到 offset 的值，再跑到 commitlog 上将完整数据读出来，也就是需要读<strong>两次</strong>。</p><figure><img src="https://cdn.xiaobaidebug.top/1716039336550.jpeg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>那么问题就来了，看起来 Kafka 的设计更高效？为什么 RocketMQ 不采用 Kafka 的设计？<br> 这就不得说一下 Kafka 的<strong>底层存储</strong>了。</p><h3 id="kafka-的底层存储" tabindex="-1"><a class="header-anchor" href="#kafka-的底层存储"><span>Kafka 的底层存储</span></a></h3><p>Kafka 的 partition 分区，其实在底层由很多<strong>段</strong>（<strong>segment</strong>）组成，每个 segment 可以认为就是个<strong>小文件</strong>。将消息数据写入到 partition 分区，本质上就是将数据写入到某个 segment 文件下。</p><figure><img src="https://cdn.xiaobaidebug.top/1716039357450.jpeg" alt="segment是什么" tabindex="0" loading="lazy"><figcaption>segment是什么</figcaption></figure><p>我们知道，操作系统的机械磁盘，<strong>顺序写</strong>的性能会比<strong>随机写</strong>快很多，差距高达几十倍。为了提升性能，Kafka 对每个小文件都是顺序写。<br> 如果只有<strong>一个</strong> segment 文件，那写文件的性能会很好。<br> 但当 topic 变多之后，topic 底下的 partition 分区也会变多，对应的 partition 底下的 segment 文件也会变多。同时写<strong>多个</strong> topic 底下的 partition，就是同时<strong>写多个文件</strong>，虽然每个文件内部都是顺序写，但多个文件存放在磁盘的不同地方，原本<strong>顺序写磁盘就可能劣化变成了随机写</strong>。于是写性能就降低了。</p><figure><img src="https://cdn.xiaobaidebug.top/1716039374651.jpeg" alt="顺序写劣化为随机写" tabindex="0" loading="lazy"><figcaption>顺序写劣化为随机写</figcaption></figure><p>那问题又又来了，究竟多少 topic 才算多？这个看实际情况，但打太极从来不是我的风格。<br> 我给一个经验值<strong>仅供参考</strong>，8 个分区的情况下，超过 64 topic, Kafka 性能就会开始下降。</p><h3 id="rocketmq-的底层存储" tabindex="-1"><a class="header-anchor" href="#rocketmq-的底层存储"><span>RocketMQ 的底层存储</span></a></h3><p>为了缓解同时写多个文件带来的随机写问题，RocketMQ 索性将单个 broker 底下的多个 topic 数据，全都写到&quot;<strong>一个</strong>&quot;逻辑文件 <code>CommitLog</code> 上，这就消除了随机写多文件的问题，将所有写操作都变成了顺序写。大大提升了 RocketMQ 在多 topic 场景下的写性能。</p><figure><img src="https://cdn.xiaobaidebug.top/1716039402130.jpeg" alt="CommitLog的作用" tabindex="0" loading="lazy"><figcaption>CommitLog的作用</figcaption></figure><blockquote><p>注意上面提到的&quot;<strong>一个</strong>&quot;是带引号的，虽然逻辑上它是一个大文件，但实际上这个 CommitLog 由多个小文件组成。每个文件的大小是固定的，当一个文件被写满后，会创建一个新的文件来继续存储新的消息。这种方式可以方便地管理和清理旧的消息。</p></blockquote><h3 id="简化备份模型" tabindex="-1"><a class="header-anchor" href="#简化备份模型"><span>简化备份模型</span></a></h3><p>我们知道，Kafka 会将 partiton 分散到多个 broker 中，并为 partiton 配置副本，将 partiton 分为 <code>leader</code>和 <code>follower</code>，也就是<strong>主和从</strong>。broker 中既可能有 A topic 的主 partiton，也可能有 B topic 的从 partiton。<br> 主从 partiton 之间会建立数据同步，本质上就是同步 partiton 底下的 segment 文件数据</p><figure><img src="https://cdn.xiaobaidebug.top/1716039497979.jpeg" alt="Kafka主从parttion同步数据" tabindex="0" loading="lazy"><figcaption>Kafka主从parttion同步数据</figcaption></figure><p>RocketMQ 将 broker 上的所有 topic 数据到写到 CommitLog 上。如果还像 Kafka 那样给每个分区单独建立同步通信，就还得将 CommitLog 里的内容<strong>拆开</strong>，这就还是退化为<strong>随机读</strong>了。<br> 于是 RocketMQ 索性<strong>以 broker 为单位区分主从</strong>，主从之间同步 CommitLog 文件，保持高可用的同时，也大大简化了备份模型。</p><figure><img src="https://cdn.xiaobaidebug.top/1716039512531.jpeg" alt="RocketMQ主从broker同步" tabindex="0" loading="lazy"><figcaption>RocketMQ主从broker同步</figcaption></figure><p>好了，到这里，我们熟悉的 Kafka 架构，就成了 RocketMQ 的架构。</p><figure><img src="https://cdn.xiaobaidebug.top/1716039611015.jpeg" alt="Kafka架构" tabindex="0" loading="lazy"><figcaption>Kafka架构</figcaption></figure><p>是不是跟 Kafka 的很像但又简化了不少？</p><figure><img src="https://cdn.xiaobaidebug.top/1716039588252.jpeg" alt="RocketMQ架构" tabindex="0" loading="lazy"><figcaption>RocketMQ架构</figcaption></figure><h2 id="在功能上做加法" tabindex="-1"><a class="header-anchor" href="#在功能上做加法"><span>在功能上做加法</span></a></h2><p>虽然 RocketMQ 的架构比 Kafka 的简单，但功能却比 Kafka 要更丰富，我们来看下。</p><h3 id="消息过滤" tabindex="-1"><a class="header-anchor" href="#消息过滤"><span>消息过滤</span></a></h3><p>我们知道，Kafka 支持通过 topic 将数据进行分类，比如订单数据和用户数据是两个不同的 topic，但如果我还想<strong>再进一步分类</strong>呢？比如同样是用户数据，还能根据 vip 等级进一步分类。假设我们只需要获取 vip6 的用户数据，在 Kafka 里，消费者需要消费 topic 为用户数据的<strong>所有消息</strong>，再将 vip6 的用户过滤出来。</p><p>而 RocketMQ 支持对消息打上<strong>标记</strong>，也就是打 <strong>tag</strong>，消费者能根据 tag 过滤所需要的数据。比如我们可以在部分消息上标记 tag=vip6，这样消费者就能<strong>只获取</strong>这部分数据，省下了消费者过滤数据时的资源消耗。</p><blockquote><p>相当于 RocketMQ 除了支持通过 topic 进行一级分类，还支持通过 tag 进行二级分类。</p></blockquote><figure><img src="https://cdn.xiaobaidebug.top/1716039636534.jpeg" alt="tag二级过滤" tabindex="0" loading="lazy"><figcaption>tag二级过滤</figcaption></figure><h3 id="支持事务" tabindex="-1"><a class="header-anchor" href="#支持事务"><span>支持事务</span></a></h3><p>我们知道 Kafka 支持事务，比如生产者发三条消息 ABC，这三条消息要么同时发送成功，要么同时发送失败。</p><p><img src="https://cdn.xiaobaidebug.top/1716039652367.jpeg" alt="Kafka的事务" loading="lazy"><br> 是，这确实也叫事务，但<strong>跟我们要的不太一样</strong>。</p><p>写业务代码的时候，我们更想要的事务是，&quot;<strong>执行一些自定义逻辑</strong>&quot;和&quot;<strong>生产者发消息</strong>&quot;这两件事，要么同时成功，要么同时失败。</p><p>而这正是 RocketMQ 支持的事务能力。</p><figure><img src="https://cdn.xiaobaidebug.top/1716039663099.jpeg" alt="RocketMQ的事务" tabindex="0" loading="lazy"><figcaption>RocketMQ的事务</figcaption></figure><h3 id="加入延时队列" tabindex="-1"><a class="header-anchor" href="#加入延时队列"><span>加入延时队列</span></a></h3><p>如果我们希望消息投递出去之后，消费者不能立马消费到，而是过个一定时间后才消费，也就是所谓的<strong>延时消息</strong>，就像文章开头的定时外卖那样。如果我们使用 Kafka， 要实现类似的功能的话，就会很费劲。<br> 但 RocketMQ 天然支持<strong>延时队列</strong>，我们可以很方便实现这一功能。</p><h3 id="加入死信队列" tabindex="-1"><a class="header-anchor" href="#加入死信队列"><span>加入死信队列</span></a></h3><p>消费消息是有可能失败的，失败后一般可以设置<strong>重试</strong>。如果多次重试失败，RocketMQ 会将消息放到一个专门的队列，方便我们<strong>后面单独处理</strong>。这种专门存放失败消息的队列，就是<strong>死信队列</strong>。<br> Kafka 原生不支持这个功能，需要我们自己实现。</p><h3 id="消息回溯" tabindex="-1"><a class="header-anchor" href="#消息回溯"><span>消息回溯</span></a></h3><p>Kafka 支持通过<strong>调整 offset</strong> 来让消费者从某个地方开始消费，而 RocketMQ，除了可以调整 offset, 还支持<strong>调整时间</strong>。</p><br><p>所以<strong>不那么严谨</strong>的说， <strong>RocketMQ 本质就是在架构上做了减法，在功能上做了加法的 Kafka</strong>。<br> 这个总结是不是特别精辟。<br> 现在大家通了吗？</p><p>最后遗留一个问题。<br> 现在看起来，RocketMQ 好像各方面都比 Kafka 更能打。<br> 但 Kafka 却一直没被淘汰，说明 RocketMQ 必然是有着不如 Kafka 的地方。<br> 是啥呢？<br><strong>性能</strong>，严格来说是<strong>吞吐量</strong>。<br> 这就很奇怪了，<strong>为什么 RocketMQ 参考了 Kafka 的架构，性能却还不如 Kafka</strong>？<br> 这个问题，我们下期聊聊。</p><h2 id="总结" tabindex="-1"><a class="header-anchor" href="#总结"><span>总结</span></a></h2><ul><li>RocketMQ 和 Kafka 相比，在架构上做了减法，在功能上做了加法</li><li>跟 Kafka 的架构相比，RocketMQ 简化了协调节点和分区以及备份模型。同时增强了消息过滤、消息回溯和事务能力，加入了延迟队列，死信队列等新特性。</li></ul><h2 id="推荐阅读" tabindex="-1"><a class="header-anchor" href="#推荐阅读"><span>推荐阅读</span></a></h2><p><a href="/%E4%B8%AD%E9%97%B4%E4%BB%B6/rocketmq/%E9%9D%A2%E8%AF%95%E9%A2%98">rocketMQ面试八股文</a></p>',84)]))}const c=a(n,[["render",r],["__file","RocketMQ是什么.html.vue"]]),s=JSON.parse('{"path":"/%E4%B8%AD%E9%97%B4%E4%BB%B6/rocketmq/%E6%A0%B8%E5%BF%83%E7%9F%A5%E8%AF%86%E7%82%B9/RocketMQ%E6%98%AF%E4%BB%80%E4%B9%88.html","title":"RocketMQ 是什么？它的架构是怎么样的？和 Kafka 又有什么区别？","lang":"zh-CN","frontmatter":{"description":"RocketMQ 是什么？它的架构是怎么样的？和 Kafka 又有什么区别？ 作为一个程序员，假设你有 A、B 两个服务，A 服务发出消息后，不想让 B 服务立马处理到。而是要过半小时才让 B 服务处理到，该怎么实现？ 这类延迟处理消息的场景非常常见，举个例子，比如我每天早上到公司后都会点个外卖，我希望外卖能在中午送过来，而不是立马送过来，这就需要将外...","head":[["meta",{"property":"og:url","content":"https://golangguide.top/%E4%B8%AD%E9%97%B4%E4%BB%B6/rocketmq/%E6%A0%B8%E5%BF%83%E7%9F%A5%E8%AF%86%E7%82%B9/RocketMQ%E6%98%AF%E4%BB%80%E4%B9%88.html"}],["meta",{"property":"og:site_name","content":"golang全栈指南"}],["meta",{"property":"og:title","content":"RocketMQ 是什么？它的架构是怎么样的？和 Kafka 又有什么区别？"}],["meta",{"property":"og:description","content":"RocketMQ 是什么？它的架构是怎么样的？和 Kafka 又有什么区别？ 作为一个程序员，假设你有 A、B 两个服务，A 服务发出消息后，不想让 B 服务立马处理到。而是要过半小时才让 B 服务处理到，该怎么实现？ 这类延迟处理消息的场景非常常见，举个例子，比如我每天早上到公司后都会点个外卖，我希望外卖能在中午送过来，而不是立马送过来，这就需要将外..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:image","content":"https://cdn.xiaobaidebug.top/1716038897833.jpeg"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2024-05-21T22:53:49.000Z"}],["meta",{"name":"twitter:card","content":"summary_large_image"}],["meta",{"name":"twitter:image:alt","content":"RocketMQ 是什么？它的架构是怎么样的？和 Kafka 又有什么区别？"}],["meta",{"property":"article:author","content":"小白debug"}],["meta",{"property":"article:modified_time","content":"2024-05-21T22:53:49.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"RocketMQ 是什么？它的架构是怎么样的？和 Kafka 又有什么区别？\\",\\"image\\":[\\"https://cdn.xiaobaidebug.top/1716038897833.jpeg\\",\\"https://cdn.xiaobaidebug.top/1716038909786.jpeg\\",\\"https://cdn.xiaobaidebug.top/1716038925501.jpeg\\",\\"https://cdn.xiaobaidebug.top/1716038944866.jpeg\\",\\"https://cdn.xiaobaidebug.top/1716039021926.jpeg\\",\\"https://cdn.xiaobaidebug.top/1716039000949.jpeg\\",\\"https://cdn.xiaobaidebug.top/1716039049814.jpeg\\",\\"https://cdn.xiaobaidebug.top/1716039187841.jpeg\\",\\"https://cdn.xiaobaidebug.top/1716039215116.jpeg\\",\\"https://cdn.xiaobaidebug.top/1716039233839.jpeg\\",\\"https://cdn.xiaobaidebug.top/1716039266847.jpeg\\",\\"https://cdn.xiaobaidebug.top/1716039283266.jpeg\\",\\"https://cdn.xiaobaidebug.top/1716039326945.jpeg\\",\\"https://cdn.xiaobaidebug.top/1716039336550.jpeg\\",\\"https://cdn.xiaobaidebug.top/1716039357450.jpeg\\",\\"https://cdn.xiaobaidebug.top/1716039374651.jpeg\\",\\"https://cdn.xiaobaidebug.top/1716039402130.jpeg\\",\\"https://cdn.xiaobaidebug.top/1716039497979.jpeg\\",\\"https://cdn.xiaobaidebug.top/1716039512531.jpeg\\",\\"https://cdn.xiaobaidebug.top/1716039611015.jpeg\\",\\"https://cdn.xiaobaidebug.top/1716039588252.jpeg\\",\\"https://cdn.xiaobaidebug.top/1716039636534.jpeg\\",\\"https://cdn.xiaobaidebug.top/1716039652367.jpeg\\",\\"https://cdn.xiaobaidebug.top/1716039663099.jpeg\\"],\\"dateModified\\":\\"2024-05-21T22:53:49.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"小白debug\\",\\"url\\":\\"https://xiaobaidebug.top/\\"}]}"],["link",{"rel":"canonical","href":"https://golangguide.top/%E4%B8%AD%E9%97%B4%E4%BB%B6/rocketmq/%E6%A0%B8%E5%BF%83%E7%9F%A5%E8%AF%86%E7%82%B9/RocketMQ%E6%98%AF%E4%BB%80%E4%B9%88.html"}],["meta",{"property":"og:url","content":"https://golangguide.top/%E4%B8%AD%E9%97%B4%E4%BB%B6/rocketmq/%E6%A0%B8%E5%BF%83%E7%9F%A5%E8%AF%86%E7%82%B9/RocketMQ%E6%98%AF%E4%BB%80%E4%B9%88.html"}],["meta",{"property":"og:site_name","content":"golang全栈指南"}],["meta",{"property":"og:title","content":"RocketMQ 是什么？它的架构是怎么样的？和 Kafka 又有什么区别？"}],["meta",{"property":"og:description","content":"RocketMQ 是什么？它的架构是怎么样的？和 Kafka 又有什么区别？ 作为一个程序员，假设你有 A、B 两个服务，A 服务发出消息后，不想让 B 服务立马处理到。而是要过半小时才让 B 服务处理到，该怎么实现？ 这类延迟处理消息的场景非常常见，举个例子，比如我每天早上到公司后都会点个外卖，我希望外卖能在中午送过来，而不是立马送过来，这就需要将外..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2024-05-21T22:53:49.000Z"}],["meta",{"property":"article:modified_time","content":"2024-05-21T22:53:49.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"RocketMQ 是什么？它的架构是怎么样的？和 Kafka 又有什么区别？\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2024-05-21T22:53:49.000Z\\",\\"author\\":[]}"]]},"headers":[{"level":2,"title":"RocketMQ 是什么？","slug":"rocketmq-是什么","link":"#rocketmq-是什么","children":[]},{"level":2,"title":"RocketMQ 和 Kafka 的区别","slug":"rocketmq-和-kafka-的区别","link":"#rocketmq-和-kafka-的区别","children":[]},{"level":2,"title":"在架构上做减法","slug":"在架构上做减法","link":"#在架构上做减法","children":[{"level":3,"title":"简化协调节点","slug":"简化协调节点","link":"#简化协调节点","children":[]},{"level":3,"title":"简化分区","slug":"简化分区","link":"#简化分区","children":[]},{"level":3,"title":"Kafka 的底层存储","slug":"kafka-的底层存储","link":"#kafka-的底层存储","children":[]},{"level":3,"title":"RocketMQ 的底层存储","slug":"rocketmq-的底层存储","link":"#rocketmq-的底层存储","children":[]},{"level":3,"title":"简化备份模型","slug":"简化备份模型","link":"#简化备份模型","children":[]}]},{"level":2,"title":"在功能上做加法","slug":"在功能上做加法","link":"#在功能上做加法","children":[{"level":3,"title":"消息过滤","slug":"消息过滤","link":"#消息过滤","children":[]},{"level":3,"title":"支持事务","slug":"支持事务","link":"#支持事务","children":[]},{"level":3,"title":"加入延时队列","slug":"加入延时队列","link":"#加入延时队列","children":[]},{"level":3,"title":"加入死信队列","slug":"加入死信队列","link":"#加入死信队列","children":[]},{"level":3,"title":"消息回溯","slug":"消息回溯","link":"#消息回溯","children":[]}]},{"level":2,"title":"总结","slug":"总结","link":"#总结","children":[]},{"level":2,"title":"推荐阅读","slug":"推荐阅读","link":"#推荐阅读","children":[]}],"git":{"createdTime":1716332029000,"updatedTime":1716332029000,"contributors":[{"name":"xiaobai-tech","email":"948485496@qq.com","commits":1}]},"readingTime":{"minutes":9.6,"words":2880},"filePathRelative":"中间件/rocketmq/核心知识点/RocketMQ是什么.md","localizedDate":"2024年5月21日","autoDesc":true}');export{c as comp,s as data};
