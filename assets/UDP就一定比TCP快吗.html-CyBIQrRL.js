import{_ as p,c as r,b as o,d as n,e as a,a as i,o as g,r as s}from"./app-BNg3kbyH.js";const d={},l={href:"https://github.com/xiaobaiTech/golangFamily",target:"_blank",rel:"noopener noreferrer"},c={href:"https://juejin.cn/post/7126710506936598558",target:"_blank",rel:"noopener noreferrer"},E={href:"https://www.xiaobaidebug.top/2022/07/19/%E5%9B%BE%E8%A7%A3%E7%BD%91%E7%BB%9C/%E6%97%A2%E7%84%B6%E6%9C%89HTTP%E5%8D%8F%E8%AE%AE%EF%BC%8C%E4%B8%BA%E4%BB%80%E4%B9%88%E8%BF%98%E8%A6%81%E6%9C%89RPC%E5%8D%8F%E8%AE%AE%EF%BC%9F/",target:"_blank",rel:"noopener noreferrer"},u={href:"https://www.xiaobaidebug.top/2021/03/26/%E5%9B%BE%E8%A7%A3%E7%BD%91%E7%BB%9C/TCP%E7%B2%98%E5%8C%85%EF%BC%81%E6%95%B0%E6%8D%AE%E5%8C%85%EF%BC%9A%E6%88%91%E5%8F%AA%E6%98%AF%E7%8A%AF%E4%BA%86%E6%AF%8F%E4%B8%AA%E6%95%B0%E6%8D%AE%E5%8C%85%E9%83%BD%E4%BC%9A%E7%8A%AF%E7%9A%84%E9%94%99%EF%BC%8C%E7%A1%AC%E6%A0%B8%E5%9B%BE%E8%A7%A3/",target:"_blank",rel:"noopener noreferrer"},b={href:"https://www.xiaobaidebug.top/2021/05/25/%E5%9B%BE%E8%A7%A3%E7%BD%91%E7%BB%9C/%E5%8A%A8%E5%9B%BE%E5%9B%BE%E8%A7%A3%EF%BC%81%E6%97%A2%E7%84%B6IP%E5%B1%82%E4%BC%9A%E5%88%86%E7%89%87%EF%BC%8C%E4%B8%BA%E4%BB%80%E4%B9%88TCP%E5%B1%82%E4%B9%9F%E8%BF%98%E8%A6%81%E5%88%86%E6%AE%B5%EF%BC%9F/",target:"_blank",rel:"noopener noreferrer"};function h(P,t){const e=s("ExternalLinkIcon");return g(),r("div",null,[o("blockquote",null,[o("p",null,[t[1]||(t[1]=n("文章持续更新，可以微信搜一搜「小白 debug」第一时间阅读，回复【面试】获面试题集。本文已经收录在 GitHub ")),o("a",l,[t[0]||(t[0]=n("https://github.com/xiaobaiTech/golangFamily")),a(e)]),t[2]||(t[2]=n(" , 有大厂面试完整考点和成长路线，欢迎 Star。"))])]),t[9]||(t[9]=i(`<p>话说，<strong>UDP 比 TCP 快吗？</strong></p><p>相信就算不是八股文老手，也会下意识的脱口而出：&quot;<strong>是</strong>&quot;。</p><p>这要追问为什么，估计大家也能说出个大概。</p><figure><img src="https://cdn.xiaobaidebug.top/1663680963848.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>但这也让人好奇，<strong>用 UDP 就一定比用 TCP 快吗？什么情况下用 UDP 会比用 TCP 慢？</strong></p><p>我们今天就来聊下这个话题。</p><br><h2 id="使用-socket-进行数据传输" tabindex="-1"><a class="header-anchor" href="#使用-socket-进行数据传输"><span>使用 socket 进行数据传输</span></a></h2><p>作为一个程序员，假设我们需要在 A 电脑的进程发一段数据到 B 电脑的进程，我们一般会在代码里使用 socket 进行编程。</p><p>socket 就像是一个<strong>电话或者邮箱</strong>（邮政的信箱）。当你想要发送消息的时候，拨通电话或者将信息塞到邮箱里，socket 内核会自动完成将数据传给对方的这个过程。</p><p>基于 socket 我们可以选择使用 TCP 或 UDP 协议进行通信。</p><p>对于 TCP 这样的可靠性协议，每次消息发出后都能明确知道对方收没收到，就<strong>像打电话一样</strong>，只要&quot;喂喂&quot;两下就能知道对方有没有在听。</p><p>而 UDP 就像是<strong>给邮政的信箱寄信一样</strong>，你寄出去的信，根本就不知道对方有没有正常收到，丢了也是有可能的。</p><blockquote><p>这让我想起了大概 17 年前，当时还没有现在这么发达的网购，想买一本《掌机迷》杂志，还得往信封里塞钱，然后一等就是一个月，好几次都怀疑信是不是丢了。我至今印象深刻，因为那是我和我哥攒了好久的钱。。。</p></blockquote><br><p>回到 socket 编程的话题上。</p><p>创建 socket 的方式就像下面这样。</p><div class="language-c line-numbers-mode" data-ext="c" data-title="c"><pre class="language-c"><code>fd <span class="token operator">=</span> <span class="token function">socket</span><span class="token punctuation">(</span>AF_INET<span class="token punctuation">,</span> 具体协议<span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>注意上面的&quot;<strong>具体协议</strong>&quot;，如果传入的是<code>SOCK_STREAM</code>，是指使用<strong>字节流</strong>传输数据，说白了就是<strong>TCP 协议</strong>。</p><figure><img src="https://cdn.xiaobaidebug.top/tcp是什么5.drawio.png" alt="TCP是什么" tabindex="0" loading="lazy"><figcaption>TCP是什么</figcaption></figure><p>如果传入的是<code>SOCK_DGRAM</code>，是指使用<strong>数据报</strong>传输数据，也就是<strong>UDP 协议</strong>。</p><figure><img src="https://cdn.xiaobaidebug.top/1663557075676.png" alt="UDP是什么" tabindex="0" loading="lazy"><figcaption>UDP是什么</figcaption></figure><p>返回的<code>fd</code>是指 socket 句柄，可以理解为 socket 的<strong>身份证号</strong>。通过这个<code>fd</code>你可以在内核中找到<strong>唯一</strong>的 socket 结构。</p><p>如果想要通过这个 socket 发消息，只需要操作这个 fd 就行了，比如执行 <code>send(fd, msg, ...)</code>，内核就会通过这个 fd 句柄找到 socket 然后进行发数据的操作。</p><p><strong>如果一切顺利</strong>，此时对方执行接收消息的操作，也就是 <code>recv(fd, msg, ...)</code>，就能拿到你发的消息。</p><figure><img src="https://cdn.xiaobaidebug.top/1663602070263.gif" alt="udp发送接收过程" tabindex="0" loading="lazy"><figcaption>udp发送接收过程</figcaption></figure><h2 id="对于异常情况的处理" tabindex="-1"><a class="header-anchor" href="#对于异常情况的处理"><span>对于异常情况的处理</span></a></h2><p><strong>但如果不顺利呢？</strong></p><p>比如消息发到一半，丢包了呢?</p>`,29)),o("blockquote",null,[o("p",null,[t[4]||(t[4]=n("丢包的原因有很多，之前写过的")),o("a",c,[t[3]||(t[3]=n("《用了 TCP 协议，就一定不会丢包吗？》")),a(e)]),t[5]||(t[5]=n("有详细聊到过，这里就不再展开。"))])]),t[10]||(t[10]=i('<p>那 UDP 和 TCP 的态度就不太一样了。</p><br><p>UDP 表示，&quot;哦，是吗？然后呢？关我 x 事&quot;</p><p>TCP 态度就截然相反了，&quot;啊？那可不行，是不是我发太快了呢？是不是链路太堵被别人影响到了呢？不过你放心，我肯定给你补发&quot;</p><p>TCP 老实人石锤了。我们来看下这个老实人在背后都默默做了哪些事情。</p><h3 id="重传机制" tabindex="-1"><a class="header-anchor" href="#重传机制"><span>重传机制</span></a></h3><p>对于 TCP，它会给发出的消息打上一个<strong>编号（sequence）</strong>，接收方收到后回一个<strong>确认(ack)</strong>。发送方可以通过<code>ack</code>的数值知道接收方收到了哪些<code>sequence</code>的包。</p><p>如果长时间等不到对方的确认，TCP 就会重新发一次消息，这就是所谓的<strong>重传机制</strong>。</p><figure><img src="https://cdn.xiaobaidebug.top/1663597929404.png" alt="TCP重传" tabindex="0" loading="lazy"><figcaption>TCP重传</figcaption></figure><br><h3 id="流量控制机制" tabindex="-1"><a class="header-anchor" href="#流量控制机制"><span>流量控制机制</span></a></h3><p>但重传这件事本身对性能影响是比较严重的，所以是<strong>下下策</strong>。</p><p>于是 TCP 就需要思考有没有办法可以尽量<strong>避免重传</strong>。</p><p>因为数据发送方和接收方处理数据能力可能不同，因此如果可以根据双方的能力去调整发送的数据量就好了，于是就有了<strong>发送和接收窗口</strong>，基本上从名字就能看出它的作用，比如<strong>接收窗口的大小</strong>就是指，接收方当前<strong>能接收的数据量大小</strong>，<strong>发送窗口的大小</strong>就指发送方当前能发的数据量大小。TCP 根据窗口的大小去控制自己发送的数据量，这样就能大大减少丢包的概率。</p><figure><img src="https://cdn.xiaobaidebug.top/1663597968469.png" alt="流量控制机制" tabindex="0" loading="lazy"><figcaption>流量控制机制</figcaption></figure><br><h3 id="滑动窗口机制" tabindex="-1"><a class="header-anchor" href="#滑动窗口机制"><span>滑动窗口机制</span></a></h3><p>接收方的接收到数据之后，会不断处理，<strong>处理能力也不是一成不变的</strong>，有时候处理的快些，那就可以收多点数据，处理的慢点那就希望对方能少发点数据。毕竟发多了就有可能处理不过来导致丢包，丢包会导致重传，这可是下下策。因此我们需要动态的去调节这个接收窗口的大小，于是就有了<strong>滑动窗口机制</strong>。</p><p>看到这里大家可能就有点迷了，<strong>流量控制和滑动窗口机制貌似很像，它们之间是啥关系？<strong>我总结一下。其实现在 TCP 是</strong>通过滑动窗口机制来实现流量控制机制的</strong>。</p><figure><img src="https://cdn.xiaobaidebug.top/1663597995829.png" alt="滑动窗口机制" tabindex="0" loading="lazy"><figcaption>滑动窗口机制</figcaption></figure><br><h3 id="拥塞控制机制" tabindex="-1"><a class="header-anchor" href="#拥塞控制机制"><span>拥塞控制机制</span></a></h3><p>但这还不够，有时候发生丢包，<strong>并不是因为发送方和接收方的处理能力问题导致的</strong>。而是跟<strong>网络环境</strong>有关，大家可以将网络想象为一条公路。马路上可能堵满了别人家的车，只留下一辆车的空间。那就算你家有 5 辆车，目的地也正好有 5 个停车位，你也没办法同时全部一起上路。于是 TCP 希望能感知到外部的网络环境，根据网络环境及时调整自己的发包数量，比如马路只够两辆车跑，那我就只发两辆车。但外部环境这么复杂，TCP 是怎么感知到的呢？</p><p>TCP 会先慢慢试探的发数据，不断加码数据量，越发越多，先发一个，再发 2 个，4 个...。直到出现丢包，这样 TCP 就知道现在当前网络大概吃得消几个包了，这既是所谓的<strong>拥塞控制机制</strong>。</p><p>不少人会疑惑流量控制和拥塞控制的关系。我这里小小的总结下。<strong>流量控制</strong>针对的是<strong>单个连接</strong>数据处理能力的控制，<strong>拥塞控制</strong>针对的是<strong>整个网络环境</strong>数据处理能力的控制。</p><figure><img src="https://cdn.xiaobaidebug.top/1663598420295.png" alt="1663598420295" tabindex="0" loading="lazy"><figcaption>1663598420295</figcaption></figure><br><h3 id="分段机制" tabindex="-1"><a class="header-anchor" href="#分段机制"><span>分段机制</span></a></h3><p>但上面提到的都是怎么<strong>降低</strong>重传的概率，似乎重传这个事情就是无法避免的，<strong>那如果确实发生了，有没有办法降低它带来的影响呢？</strong></p><p>有。当我们需要发送一个超大的数据包时，如果这个数据包丢了，那就得重传同样大的数据包。但如果我能将其分成一小段一小段，那就算真丢了，那我也就只需要重传那一小段就好了，大大减小了重传的压力，这就是 TCP 的<strong>分段机制</strong>。</p><p>而这个所谓的一小段的长度，在传输层叫<strong>MSS</strong>（<strong>Maximum Segment Size</strong>），数据包长度大于 MSS 则会分成 N 个小于等于 MSS 的包。</p><figure><img src="https://cdn.xiaobaidebug.top/image/MSS分包.gif" alt="MSS分包" tabindex="0" loading="lazy"><figcaption>MSS分包</figcaption></figure><p>而在网络层，如果数据包还大于<strong>MTU（Maximum Transmit Unit）</strong>，那还会继续分包。</p><figure><img src="https://cdn.xiaobaidebug.top/image/mtu分包.gif" alt="MTU分包" tabindex="0" loading="lazy"><figcaption>MTU分包</figcaption></figure><p>一般情况下，<code>MSS=MTU-40Byte</code>，所以<strong>TCP 分段后，到了 IP 层大概率就不会再分片了</strong>。</p><figure><img src="https://cdn.xiaobaidebug.top/image/MSS和MTU的区别2.png" alt="MSS和MTU的区别" tabindex="0" loading="lazy"><figcaption>MSS和MTU的区别</figcaption></figure><br><h3 id="乱序重排机制" tabindex="-1"><a class="header-anchor" href="#乱序重排机制"><span>乱序重排机制</span></a></h3><p>既然数据包会被分段，链路又这么复杂还会丢包，那数据包乱序也就显得不奇怪了。比如发数据包 1,2,3。1 号数据包走了其他网络路径，2 和 3 数据包先到，1 数据包后到，于是数据包顺序就成了 2,3,1。这一点 TCP 也考虑到了，依靠数据包的<code>sequence</code>，接收方就能知道数据包的先后顺序。</p><p>后发的数据包先到是吧，那就先放到专门的<strong>乱序队列</strong>中，等数据都到齐后，重新整理好乱序队列的数据包顺序后再给到用户，这就是<strong>乱序重排机制</strong>。</p><figure><img src="https://cdn.xiaobaidebug.top/乱序队列等待数据包的到来.drawio.png" alt="乱序队列等待数据包的到来" tabindex="0" loading="lazy"><figcaption>乱序队列等待数据包的到来</figcaption></figure><br><h3 id="连接机制" tabindex="-1"><a class="header-anchor" href="#连接机制"><span>连接机制</span></a></h3><p>前面提到，UDP 是无连接的，而 TCP 是面向连接的。</p><p>这里提到的<strong>连接</strong>到底是啥？</p><p>TCP 通过上面提到的各种机制实现了数据的可靠性。这些机制背后是通过一个个数据结构来实现的逻辑。而为了实现这套逻辑，操作系统内核需要在两端代码里维护一套复杂的状态机（三次握手，四次挥手，RST，closing 等异常处理机制），<strong>这套状态机其实就是所谓的&quot;连接&quot;</strong>。这其实就是 TCP 的<strong>连接机制</strong>，而 UDP 用不上这套状态机，因此它是&quot;无连接&quot;的。</p><br><p>网络环境链路很长，还复杂，数据丢包是很常见的。</p><p>我们平常用 TCP 做各种数据传输，完全对这些事情无感知。</p><p><strong>哪有什么岁月静好，是 TCP 替你负重前行。</strong></p><p>这就是 TCP 三大特性&quot;面向连接、可靠的、基于字节流&quot;中&quot;<strong>可靠</strong>&quot;的含义。</p><p>不信你改用 UDP 试试，丢包那就是真丢了，丢到你怀疑人生。</p><br><h2 id="用-udp-就一定比用-tcp-快吗" tabindex="-1"><a class="header-anchor" href="#用-udp-就一定比用-tcp-快吗"><span>用 UDP 就一定比用 TCP 快吗？</span></a></h2><p>这时候 UDP 就不服了：&quot;<strong>正因为没有这些复杂的 TCP 可靠性机制，所以我很快啊</strong>&quot;</p><p>嗯，这也是大部分人认为 UDP 比 TCP 快的原因。</p><p><strong>实际上大部分情况下也确实是这样的。这话没毛病。</strong></p><br><p>那问题就来了。</p><p><strong>有没有用了 UDP 但却比 TCP 慢的情况呢？</strong></p><p>其实也有。</p><p>在回答这个问题前，我需要先说下<strong>UDP 的用途</strong>。</p><p>实际上，<strong>大部分</strong>人也不会尝试<strong>直接拿裸 udp</strong>放到生产环境中去做项目。</p><p>那 UDP 的价值在哪？</p><p>在我看来，UDP 的存在，本质是内核提供的一个<strong>最小网络传输功能</strong>。</p><p>很多时候，大家虽然号称自己用了 UDP，但实际上都很<strong>忌惮</strong>它的丢包问题，所以大部分情况下都会在 UDP 的基础上做各种不同程度的<strong>应用层</strong>可靠性保证。比如王者农药用的<code>KCP</code>，以及最近很火的<code>QUIC（HTTP3.0）</code>，其实都<strong>在 UDP 的基础上做了重传逻辑</strong>，实现了一套<strong>类似</strong>TCP 那样的可靠性机制。</p><p>教科书上最爱提 UDP 适合用于<strong>音视频传输</strong>，因为这些场景允许丢包。但其实也不是什么包都能丢的，比如重要的关键帧啥的，该重传还得重传。除此之外，还有一些<strong>乱序处理机制</strong>。举个例子吧。</p><p>打音视频电话的时候，你可能遇到过丢失中间某部分信息的情况，但应该从来没遇到过乱序的情况吧。</p><p>比如对方打网络电话给你，说了：&quot;<strong>我好想给小白来个点赞在看！</strong>&quot;</p><p>这时候网络信号不好，你可能会听到&quot;我....点赞在看&quot;。</p><p>但却从来没遇到过&quot;在看小白好想赞&quot;这样的<strong>乱序</strong>场景吧？</p><p>所以说，<strong>虽然选择了使用 UDP，但一般还是会在应用层上做一些重传机制的</strong>。</p><p>于是问题就来了，<strong>如果现在我需要传一个特别大的数据包</strong>。</p><p>在<code>TCP</code>里，它内部会根据<code>MSS</code>的大小<strong>分段</strong>，这时候进入到 IP 层之后，每个包大小都不会超过<code>MTU</code>，因此 IP 层一般不会再进行分片。这时候发生丢包了，只需要<strong>重传每个 MSS 分段</strong>就够了。</p><figure><img src="https://cdn.xiaobaidebug.top/1663602192374.gif" alt="TCP分段" tabindex="0" loading="lazy"><figcaption>TCP分段</figcaption></figure><p>但对于<code>UDP</code>，其本身并不会分段，如果数据过大，到了 IP 层，就会进行分片。此时发生丢包的话，再次重传，就会<strong>重传整个大数据包</strong>。</p><figure><img src="https://cdn.xiaobaidebug.top/1663602173391.gif" alt="UDP不分段" tabindex="0" loading="lazy"><figcaption>UDP不分段</figcaption></figure><p>对于上面这种情况，<strong>使用 UDP 就比 TCP 要慢</strong>。</p><p>当然，解决起来也不复杂。这里的关键点在于是否实现了数据分段机制，<strong>使用 UDP 的应用层如果也实现了分段机制的话，那就不会出现上述的问题了</strong>。</p><br><h2 id="总结" tabindex="-1"><a class="header-anchor" href="#总结"><span>总结</span></a></h2><ul><li>TCP 为了实现可靠性，引入了重传机制、流量控制、滑动窗口、拥塞控制、分段以及乱序重排机制。而 UDP 则没有实现，因此一般来说 TCP 比 UDP 慢。</li><li>TCP 是面向连接的协议，而 UDP 是无连接的协议。这里的&quot;<strong>连接</strong>&quot;其实是，操作系统内核在两端代码里维护的一套复杂状态机。</li><li>大部分项目，会在基于 UDP 的基础上，模仿 TCP，实现不同程度的可靠性机制。比如王者农药用的 KCP 其实就在基于 UDP 在应用层里实现了一套<strong>重传</strong>机制。</li><li>对于 UDP+重传的场景，如果要传<strong>超大数据包</strong>，并且没有实现<strong>分段机制</strong>的话，那数据就会在 IP 层分片，一旦丢包，那就需要重传整个超大数据包。而 TCP 则不需要考虑这个，内部会自动分段，丢包重传分段就行了。这种场景下，其实 TCP 更快。</li></ul><br><h2 id="最后" tabindex="-1"><a class="header-anchor" href="#最后"><span>最后</span></a></h2><p>最近原创更文的阅读量稳步下跌，思前想后，夜里辗转反侧。</p><p>我有个不成熟的请求。</p><img src="https://cdn.xiaobaidebug.top/image-20220522162506224.png" alt="" style="zoom:20%;"><br><p><strong>离开广东好长时间了，好久没人叫我靓仔了。</strong></p><p>大家可以在<strong>评论区</strong>里，叫我一靓仔吗？</p><p>我这么善良质朴的愿望，能被满足吗？</p><p>如果实在叫不出口的话，能帮我<strong>点下关注</strong>和右下角的<strong>点赞+收藏</strong>吗？</p><p>如果评论区没人叫我靓仔，文章也没人点赞，我感觉我下篇文章要开始收费了，价钱我都想好了，8 块 8，毕竟男人都拒绝不了这种价格以 8 结尾的项目。</p><p>你说是吧，易峰。</p><br><h5 id="别说了-一起在知识的海洋里呛水吧" tabindex="-1"><a class="header-anchor" href="#别说了-一起在知识的海洋里呛水吧"><span>别说了，一起在知识的海洋里呛水吧</span></a></h5><p>关注公众号:【小白 debug】</p><br><p>不满足于在留言区说骚话？</p><p>加我，我们建了个划水吹牛皮群，在群里，你可以跟你下次跳槽可能遇到的同事或面试官聊点有意思的话题。就<strong>超！开！心！</strong></p><img src="https://cdn.xiaobaidebug.top/image-20220522162616202.png" alt="" style="zoom:50%;"><figure><img src="https://cdn.xiaobaidebug.top/006APoFYly1g5q9gn2jipg308w08wqdi.gif" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><br><h2 id="文章推荐" tabindex="-1"><a class="header-anchor" href="#文章推荐"><span>文章推荐：</span></a></h2>',104)),o("ul",null,[o("li",null,[o("a",E,[t[6]||(t[6]=n("既然有 HTTP 协议，为什么还要有 RPC")),a(e)])]),o("li",null,[o("a",u,[t[7]||(t[7]=n("TCP 粘包 数据包：我只是犯了每个数据包都会犯的错 |硬核图解")),a(e)])]),o("li",null,[o("a",b,[t[8]||(t[8]=n("动图图解！既然 IP 层会分片，为什么 TCP 层也还要分段？")),a(e)])])])])}const B=p(d,[["render",h],["__file","UDP就一定比TCP快吗.html.vue"]]),f=JSON.parse('{"path":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/%E6%A0%B8%E5%BF%83%E7%9F%A5%E8%AF%86%E7%82%B9/UDP%E5%B0%B1%E4%B8%80%E5%AE%9A%E6%AF%94TCP%E5%BF%AB%E5%90%97.html","title":"动图图解 | UDP就一定比TCP快吗？","lang":"zh-CN","frontmatter":{"title":"动图图解 | UDP就一定比TCP快吗？","date":"2022-10-17T22:57:55.000Z","tags":null,"categories":"图解网络","description":" 文章持续更新，可以微信搜一搜「小白 debug」第一时间阅读，回复【面试】获面试题集。本文已经收录在 GitHub https://github.com/xiaobaiTech/golangFamily , 有大厂面试完整考点和成长路线，欢迎 Star。 话说，UDP 比 TCP 快吗？ 相信就算不是八股文老手，也会下意识的脱口而出：\\"是\\"。 这要追...","head":[["meta",{"property":"og:url","content":"https://golangguide.top/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/%E6%A0%B8%E5%BF%83%E7%9F%A5%E8%AF%86%E7%82%B9/UDP%E5%B0%B1%E4%B8%80%E5%AE%9A%E6%AF%94TCP%E5%BF%AB%E5%90%97.html"}],["meta",{"property":"og:site_name","content":"golang全栈指南"}],["meta",{"property":"og:title","content":"动图图解 | UDP就一定比TCP快吗？"}],["meta",{"property":"og:description","content":" 文章持续更新，可以微信搜一搜「小白 debug」第一时间阅读，回复【面试】获面试题集。本文已经收录在 GitHub https://github.com/xiaobaiTech/golangFamily , 有大厂面试完整考点和成长路线，欢迎 Star。 话说，UDP 比 TCP 快吗？ 相信就算不是八股文老手，也会下意识的脱口而出：\\"是\\"。 这要追..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:image","content":"https://cdn.xiaobaidebug.top/1663680963848.png"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2024-05-12T13:55:00.000Z"}],["meta",{"name":"twitter:card","content":"summary_large_image"}],["meta",{"name":"twitter:image:alt","content":"动图图解 | UDP就一定比TCP快吗？"}],["meta",{"property":"article:author","content":"小白debug"}],["meta",{"property":"article:published_time","content":"2022-10-17T22:57:55.000Z"}],["meta",{"property":"article:modified_time","content":"2024-05-12T13:55:00.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"动图图解 | UDP就一定比TCP快吗？\\",\\"image\\":[\\"https://cdn.xiaobaidebug.top/1663680963848.png\\",\\"https://cdn.xiaobaidebug.top/tcp%E6%98%AF%E4%BB%80%E4%B9%885.drawio.png\\",\\"https://cdn.xiaobaidebug.top/1663557075676.png\\",\\"https://cdn.xiaobaidebug.top/1663602070263.gif\\",\\"https://cdn.xiaobaidebug.top/1663597929404.png\\",\\"https://cdn.xiaobaidebug.top/1663597968469.png\\",\\"https://cdn.xiaobaidebug.top/1663597995829.png\\",\\"https://cdn.xiaobaidebug.top/1663598420295.png\\",\\"https://cdn.xiaobaidebug.top/image/MSS%E5%88%86%E5%8C%85.gif\\",\\"https://cdn.xiaobaidebug.top/image/mtu%E5%88%86%E5%8C%85.gif\\",\\"https://cdn.xiaobaidebug.top/image/MSS和MTU的区别2.png\\",\\"https://cdn.xiaobaidebug.top/%E4%B9%B1%E5%BA%8F%E9%98%9F%E5%88%97%E7%AD%89%E5%BE%85%E6%95%B0%E6%8D%AE%E5%8C%85%E7%9A%84%E5%88%B0%E6%9D%A5.drawio.png\\",\\"https://cdn.xiaobaidebug.top/1663602192374.gif\\",\\"https://cdn.xiaobaidebug.top/1663602173391.gif\\",\\"https://cdn.xiaobaidebug.top/006APoFYly1g5q9gn2jipg308w08wqdi.gif\\"],\\"datePublished\\":\\"2022-10-17T22:57:55.000Z\\",\\"dateModified\\":\\"2024-05-12T13:55:00.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"小白debug\\",\\"url\\":\\"https://xiaobaidebug.top/\\"}]}"],["link",{"rel":"canonical","href":"https://golangguide.top/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/%E6%A0%B8%E5%BF%83%E7%9F%A5%E8%AF%86%E7%82%B9/UDP%E5%B0%B1%E4%B8%80%E5%AE%9A%E6%AF%94TCP%E5%BF%AB%E5%90%97.html"}],["meta",{"property":"og:url","content":"https://golangguide.top/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/%E6%A0%B8%E5%BF%83%E7%9F%A5%E8%AF%86%E7%82%B9/UDP%E5%B0%B1%E4%B8%80%E5%AE%9A%E6%AF%94TCP%E5%BF%AB%E5%90%97.html"}],["meta",{"property":"og:site_name","content":"golang全栈指南"}],["meta",{"property":"og:title","content":"动图图解 | UDP就一定比TCP快吗？"}],["meta",{"property":"og:description","content":" 文章持续更新，可以微信搜一搜「小白 debug」第一时间阅读，回复【面试】获面试题集。本文已经收录在 GitHub https://github.com/xiaobaiTech/golangFamily , 有大厂面试完整考点和成长路线，欢迎 Star。 话说，UDP 比 TCP 快吗？ 相信就算不是八股文老手，也会下意识的脱口而出：\\"是\\"。 这要追..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2024-05-12T13:55:00.000Z"}],["meta",{"property":"article:published_time","content":"2022-10-17T22:57:55.000Z"}],["meta",{"property":"article:modified_time","content":"2024-05-12T13:55:00.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"动图图解 | UDP就一定比TCP快吗？\\",\\"image\\":[\\"\\"],\\"datePublished\\":\\"2022-10-17T22:57:55.000Z\\",\\"dateModified\\":\\"2024-05-12T13:55:00.000Z\\",\\"author\\":[]}"]]},"headers":[{"level":2,"title":"使用 socket 进行数据传输","slug":"使用-socket-进行数据传输","link":"#使用-socket-进行数据传输","children":[]},{"level":2,"title":"对于异常情况的处理","slug":"对于异常情况的处理","link":"#对于异常情况的处理","children":[{"level":3,"title":"重传机制","slug":"重传机制","link":"#重传机制","children":[]},{"level":3,"title":"流量控制机制","slug":"流量控制机制","link":"#流量控制机制","children":[]},{"level":3,"title":"滑动窗口机制","slug":"滑动窗口机制","link":"#滑动窗口机制","children":[]},{"level":3,"title":"拥塞控制机制","slug":"拥塞控制机制","link":"#拥塞控制机制","children":[]},{"level":3,"title":"分段机制","slug":"分段机制","link":"#分段机制","children":[]},{"level":3,"title":"乱序重排机制","slug":"乱序重排机制","link":"#乱序重排机制","children":[]},{"level":3,"title":"连接机制","slug":"连接机制","link":"#连接机制","children":[]}]},{"level":2,"title":"用 UDP 就一定比用 TCP 快吗？","slug":"用-udp-就一定比用-tcp-快吗","link":"#用-udp-就一定比用-tcp-快吗","children":[]},{"level":2,"title":"总结","slug":"总结","link":"#总结","children":[]},{"level":2,"title":"最后","slug":"最后","link":"#最后","children":[]},{"level":2,"title":"文章推荐：","slug":"文章推荐","link":"#文章推荐","children":[]}],"git":{"createdTime":1708315055000,"updatedTime":1715522100000,"contributors":[{"name":"xiaobai","email":"xiaobaidebug@gmail.com","commits":1},{"name":"xiaobai-tech","email":"948485496@qq.com","commits":1}]},"readingTime":{"minutes":13.82,"words":4145},"filePathRelative":"计算机基础/网络基础/核心知识点/UDP就一定比TCP快吗.md","localizedDate":"2022年10月17日","autoDesc":true}');export{B as comp,f as data};
