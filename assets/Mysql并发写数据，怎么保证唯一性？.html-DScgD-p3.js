import{_ as o}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as p,a as i,b as n,d as s,e as t,o as r,r as l}from"./app-CfNjLirf.js";const c={},g={href:"https://golangguide.top/golang/%E9%9D%A2%E8%AF%95%E9%A2%98/2.Go%E8%BF%9B%E9%98%B6.html",target:"_blank",rel:"noopener noreferrer"},d={href:"https://golangguide.top/golang/%E9%9D%A2%E8%AF%95%E9%A2%98/1.Go%E5%85%A5%E9%97%A8.html",target:"_blank",rel:"noopener noreferrer"},u={href:"https://golangguide.top/golang/%E5%B8%B8%E7%94%A8%E5%8C%85%E5%A4%A7%E5%85%A8.html",target:"_blank",rel:"noopener noreferrer"},m={href:"https://golangguide.top/golang/%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF.html",target:"_blank",rel:"noopener noreferrer"};function E(h,e){const a=l("ExternalLinkIcon");return r(),p("div",null,[e[4]||(e[4]=i(`<h1 id="两个事务并发写-能保证数据唯一吗" tabindex="-1"><a class="header-anchor" href="#两个事务并发写-能保证数据唯一吗"><span>两个事务并发写，能保证数据唯一吗？</span></a></h1><br><p>哟，又是我小白。最近有点高产了。</p><p>连我自己都害怕了。</p><figure><img src="https://cdn.xiaobaidebug.top/image/006APoFYly8grrdl7zawuj30af0afwiu.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>直接进入正题吧。</p><br><h2 id="两个事务并发写-能保证数据唯一吗-1" tabindex="-1"><a class="header-anchor" href="#两个事务并发写-能保证数据唯一吗-1"><span>两个事务并发写，能保证数据唯一吗？</span></a></h2><p>我先来解释下标题讲的是个啥。</p><br><p>我们假设有这么一个用户注册的场景。用户并发请求注册新用户。</p><p>你有一张数据库表，也就是下面的 user 表。</p><figure><img src="https://cdn.xiaobaidebug.top/image/user表数据库原始状态.png" alt="user表数据库原始状态" tabindex="0" loading="lazy"><figcaption>user表数据库原始状态</figcaption></figure><p>产品经理要求用户和用户之间，电话号码不能重复，为了保证这一点。我们想到了先查一下数据库，再判断一下，如果存在，就退出，否则插入一条数据。类似下面这样的伪代码。</p><div class="language-sql line-numbers-mode" data-ext="sql" data-title="sql"><pre class="language-sql"><code><span class="token keyword">select</span> <span class="token keyword">user</span> <span class="token keyword">where</span> phone_no <span class="token operator">=</span><span class="token number">2</span><span class="token punctuation">;</span>  <span class="token comment">// 查询sql</span>
<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">user</span> 存在<span class="token punctuation">)</span> {
		<span class="token keyword">return</span>
} <span class="token keyword">else</span> {
  <span class="token keyword">insert</span> <span class="token keyword">user</span><span class="token punctuation">;</span>   <span class="token comment">// 插入sql</span>
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>但这是两条 sql 语句，先执行查询 sql，判断后再决定要不要执行插入 sql。每次用户注册的时候都会执行这么一段逻辑。</p><p>那如果，此时有多个用户在做操作，就会<strong>并发</strong>执行这段逻辑。</p><p>如果都并发执行，第一条 sql 语句执行完之后，都会发现没有用户存在。此时都执行了插入，这样就出现了两条一样的数据才对。</p><p>所以，有人就想了，这<strong>两条 sql 语句逻辑应该是一个整体</strong>，不应该拆开，于是就想到了事务，通过事务把这两个 sql 作为<strong>一个整体</strong>，要么一起执行，要么都回滚。</p><p>这正是数据库 ACID 里的 A（Atomicity），原子性的完美体现啊。</p><figure><img src="https://cdn.xiaobaidebug.top/image/ACID.png" alt="ACID" tabindex="0" loading="lazy"><figcaption>ACID</figcaption></figure><p>伪代码类似下面这样。</p><div class="language-sql line-numbers-mode" data-ext="sql" data-title="sql"><pre class="language-sql"><code><span class="token keyword">begin</span><span class="token punctuation">;</span>
<span class="token keyword">select</span> <span class="token keyword">user</span> <span class="token keyword">where</span> phone_no <span class="token operator">=</span><span class="token number">2</span><span class="token punctuation">;</span>  <span class="token comment">// 查询sql</span>
<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">user</span> 存在<span class="token punctuation">)</span> {
		<span class="token keyword">return</span>
} <span class="token keyword">else</span> {
  <span class="token keyword">insert</span> <span class="token keyword">user</span><span class="token punctuation">;</span>   <span class="token comment">// 插入sql</span>
}
<span class="token keyword">commit</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>那么问题来了，<strong>这段逻辑，并发执行，能保证数据唯一？</strong></p><p><strong>当然是不能。</strong></p><p>事务內的多条 sql 语句，确实是原子的，要么一起成功，要么一起失败，这没错，但跟这个场景没什么太大关系。事务是并发执行的，第一个事务执行查询用户，并<strong>不会阻塞</strong>另一个事务查询用户，所以都有可能查到用户不存在，此时两个事务逻辑都判断为用户不存在，然后插入数据库。事务内两条 sql 都执行成功了，于是就插入了两条一样的数据。</p><figure><img src="https://cdn.xiaobaidebug.top/image/并发事务写入两条数据.drawio.png" alt="并发事务写入两条数据.drawio" tabindex="0" loading="lazy"><figcaption>并发事务写入两条数据.drawio</figcaption></figure><br><h2 id="怎么保证数据唯一" tabindex="-1"><a class="header-anchor" href="#怎么保证数据唯一"><span>怎么保证数据唯一？</span></a></h2><p>那么我们接下来聊聊，怎么保证上面这种场景下，插入的数据是唯一的。方法有很多种，但我们今天只讨论 mysql 内部的做法，不考虑其他外部中间件（比如 redis 分布式锁这些）。</p><br><h3 id="唯一索引" tabindex="-1"><a class="header-anchor" href="#唯一索引"><span>唯一索引</span></a></h3><p>通过下面的命令，可以为数据库 user 表的 phone_no 字段加入唯一索引。</p><div class="language-text line-numbers-mode" data-ext="text" data-title="text"><pre class="language-text"><code>ALTER TABLE \`user\` ADD unique(\`phone_no\`);
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>我们执行一条写操作时，比如下面这句，</p><div class="language-sql line-numbers-mode" data-ext="sql" data-title="sql"><pre class="language-sql"><code><span class="token keyword">INSERT</span> <span class="token keyword">INTO</span> <span class="token identifier"><span class="token punctuation">\`</span>user<span class="token punctuation">\`</span></span> <span class="token punctuation">(</span><span class="token identifier"><span class="token punctuation">\`</span>user_name<span class="token punctuation">\`</span></span><span class="token punctuation">,</span> <span class="token identifier"><span class="token punctuation">\`</span>phone_no<span class="token punctuation">\`</span></span><span class="token punctuation">)</span> <span class="token keyword">VALUES</span><span class="token punctuation">(</span><span class="token string">&#39;小红&#39;</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>第一次会插入成功，第二次再执行插入，则会出现报错。</p><div class="language-sql line-numbers-mode" data-ext="sql" data-title="sql"><pre class="language-sql"><code><span class="token keyword">Duplicate</span> entry <span class="token string">&#39;2&#39;</span> <span class="token keyword">for</span> <span class="token keyword">key</span> <span class="token string">&#39;phone_no&#39;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>含义是 phone_no 这个字段是唯一的，加两次 phone_no=2 会导致重复。</p><p>于是乎回到我们文章开头的场景里，就完美解决了重复插入的问题了。</p><br><p>那么问题来了。</p><br><h4 id="为什么唯一索引能保证数据唯一" tabindex="-1"><a class="header-anchor" href="#为什么唯一索引能保证数据唯一"><span>为什么唯一索引能保证数据唯一？</span></a></h4><p>我们看看一句写操作，会经历什么。</p><figure><img src="https://cdn.xiaobaidebug.top/Mysql架构56.drawio.png" alt="Mysql架构" tabindex="0" loading="lazy"><figcaption>Mysql架构</figcaption></figure><p>首先，mysql 作为一个数据库，内部主要分为两层，一层是<strong>server 层</strong>，一层是<strong>存储引擎层</strong>（一般是<strong>innodb</strong>）。</p><p>server 层主要管的是数据库链接，权限校验，以及 sql 语句校验和优化之类的工作。请求打到存储引擎层，才是真正的查询和更新数据的操作。</p><p>大家都知道数据库是持久化存储，且最后都是把数据存到<strong>磁盘</strong>上的。</p><p><strong>那数据库读写是直接读写磁盘数据吗？</strong></p><p>不是，如果直接读写磁盘的话，那就太慢了，为了提升速度。</p><p>它在磁盘前面加了一层内存，叫<strong>buffer pool</strong>。它里面有很多细节，但最主要的就是个双向链表，里面放的是一个个数据页，每个数据页的大小默认是 16kb，数据页里面放的就是磁盘的数据。</p><figure><img src="https://cdn.xiaobaidebug.top/image/bufferPool与磁盘.png" alt="bufferPool与磁盘" tabindex="0" loading="lazy"><figcaption>bufferPool与磁盘</figcaption></figure><p>于是有了这层 buffer pool 内存，mysql 的读和写操作都可以先操作这部分内存，如果想要读写的数据页不在 buffer pool 里，再跑到磁盘里去捞。由于<strong>读写内存的速度比读写磁盘快得多</strong>。</p><p><strong>所以引擎读写都快多了。</strong></p><p>但这还不够，<strong>很多时候写操作，我的诉求就是把 xx 更新为 xx，或插入 xx，数据库光知道这一点就够了，我根本不需要知道数据页原来长什么样子。</strong></p><p>有点抽象？举个例子吧。</p><p>比方说我想要把 id=1 的这条数据的 phone_no 字段更新为 100，数据库知道这一点就够了，至于这条数据原来 phone_no 究竟是等于 20，还是 30，这根本不重要，反正最后都会变成我想要的 phone_no=100。</p><p>也就是说，如果有那么<strong>一块内存</strong>，记录下我准备把数据改成什么样子，然后后续异步慢慢更新到磁盘数据上。那我甚至到不需要在一开始就把这块数据从磁盘读到 buffer pool 中，按照这个思路，<strong>change buffer</strong>就来了。</p><figure><img src="https://cdn.xiaobaidebug.top/image/changeBuffer在bufferPool内2.png" alt="changeBuffer在bufferPool内" tabindex="0" loading="lazy"><figcaption>changeBuffer在bufferPool内</figcaption></figure><p>于是乎，写加了<strong>普通索引</strong>的数据，当想要更新的数据它不在 buffer 里时，也不需要立马去磁盘里加载这份数据了，只要把想要写的内容写到 change buffer 上，就立马结束返回了。后面 innodb 引擎拿着这个 change buffer，再异步读入磁盘数据到内存，将 change buffer 的数据修改到数据页中，再写回磁盘，这速度就上来了，秒啊。</p><p>但这个 change buffer，放在<strong>唯一索引</strong>这里就不管用了，毕竟，它得保证数据真的只有一条，那就得去看下数据库里，是不是真的有这条数据。</p><p>所以，对于 insert 场景，普通索引把需求扔到 change buffer 就完事返回了，而唯一索引需要真的把数据从磁盘读到内存来，看下是不是有重复的，没重复的再插入数据。</p><p>这唯一索引，在性能上就输了一截了。</p><p>所以回到<strong>唯一索引为什么能保证数据唯一</strong>的问题上，一句话概括就是，<strong>唯一索引会绕过 change buffer，确保把磁盘数据读到内存后再判断数据是否存在，不存在才能插入数据，否则报错，以此来保证数据是唯一的。</strong></p><br><h3 id="总结" tabindex="-1"><a class="header-anchor" href="#总结"><span>总结</span></a></h3><ul><li>加唯一索引可以保证数据并发写入时数据唯一，而且最省事省心。</li><li>数据库通过引入一层 buffer pool 内存来提升读写速度，普通索引可以利用 change buffer 提高数据插入的性能。</li><li>唯一索引会绕过 change buffer，确保把磁盘数据读到内存后再判断数据是否存在，不存在才能插入数据，否则报错，以此来保证数据是唯一的。</li></ul><br><p>给大家留个问题呗，前面也提到了，<strong>innodb 中，利用了 change buffer，为普通索引做了加速</strong>。<strong>有没有哪些场景下，change buffer 不仅不能给普通索引加速，还起到反作用的呢？</strong></p><h3 id="最后" tabindex="-1"><a class="header-anchor" href="#最后"><span>最后</span></a></h3><p>大家也别笑，文章开头提到的通过开事务来保证数据唯一性的错误操作，其实很容易犯，而且我曾经也遇到过不止一次这样的事情。</p><p>做这个操作的人，还会信誓旦旦，言之凿凿的说出他的理解，在我解释了几遍发现无果之后，我选择低头假装思考，然后说：&quot;你说的有点道理，我再回去好好想想&quot;，然后默默的为数据表加上唯一索引......</p><p>我相信对方肯定已经理解了。那一刻，我感觉我写的不是代码，我写的是人情世故。</p><figure><img src="https://cdn.xiaobaidebug.top/image/006ARE9vgy1fz5ahct0mhj30mk0m83zo.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><br><p><strong>如果文章对你有帮助，欢迎.....</strong></p><p>算了。</p><br><h6 id="别说了-一起在知识的海洋里呛水吧" tabindex="-1"><a class="header-anchor" href="#别说了-一起在知识的海洋里呛水吧"><span>别说了，一起在知识的海洋里呛水吧</span></a></h6><p>关注公众号:【小白 debug】</p><br><p>不满足于在留言区说骚话？</p><p>加我，我们建了个划水吹牛皮群，在群里，你可以跟你下次跳槽可能遇到的同事或面试官聊点有意思的话题。就<strong>超！开！心！</strong></p><img src="https://cdn.xiaobaidebug.top/image-20220522162616202.png" width="50%" align="center"><h2 id="文章推荐" tabindex="-1"><a class="header-anchor" href="#文章推荐"><span>文章推荐：</span></a></h2>`,86)),n("ul",null,[n("li",null,[n("p",null,[n("a",g,[e[0]||(e[0]=s("golang进阶面试题八股文合集")),t(a)])])]),n("li",null,[n("p",null,[n("a",d,[e[1]||(e[1]=s("golang基础面试题八股文合集")),t(a)])])]),n("li",null,[n("p",null,[n("a",u,[e[2]||(e[2]=s("golang常用标准库第三方库大全")),t(a)])])]),n("li",null,[n("p",null,[n("a",m,[e[3]||(e[3]=s("golang学习路线")),t(a)])])])])])}const k=o(c,[["render",E],["__file","Mysql并发写数据，怎么保证唯一性？.html.vue"]]),B=JSON.parse('{"path":"/%E4%B8%AD%E9%97%B4%E4%BB%B6/mysql/%E6%A0%B8%E5%BF%83%E7%9F%A5%E8%AF%86%E7%82%B9/Mysql%E5%B9%B6%E5%8F%91%E5%86%99%E6%95%B0%E6%8D%AE%EF%BC%8C%E6%80%8E%E4%B9%88%E4%BF%9D%E8%AF%81%E5%94%AF%E4%B8%80%E6%80%A7%EF%BC%9F.html","title":"两个事务并发写，能保证数据唯一吗？","lang":"zh-CN","frontmatter":{"description":"两个事务并发写，能保证数据唯一吗？ 哟，又是我小白。最近有点高产了。 连我自己都害怕了。 直接进入正题吧。 两个事务并发写，能保证数据唯一吗？ 我先来解释下标题讲的是个啥。 我们假设有这么一个用户注册的场景。用户并发请求注册新用户。 你有一张数据库表，也就是下面的 user 表。 user表数据库原始状态user表数据库原始状态 产品经理要求用户和用户...","head":[["meta",{"property":"og:url","content":"https://golangguide.top/%E4%B8%AD%E9%97%B4%E4%BB%B6/mysql/%E6%A0%B8%E5%BF%83%E7%9F%A5%E8%AF%86%E7%82%B9/Mysql%E5%B9%B6%E5%8F%91%E5%86%99%E6%95%B0%E6%8D%AE%EF%BC%8C%E6%80%8E%E4%B9%88%E4%BF%9D%E8%AF%81%E5%94%AF%E4%B8%80%E6%80%A7%EF%BC%9F.html"}],["meta",{"property":"og:site_name","content":"golang全栈指南"}],["meta",{"property":"og:title","content":"两个事务并发写，能保证数据唯一吗？"}],["meta",{"property":"og:description","content":"两个事务并发写，能保证数据唯一吗？ 哟，又是我小白。最近有点高产了。 连我自己都害怕了。 直接进入正题吧。 两个事务并发写，能保证数据唯一吗？ 我先来解释下标题讲的是个啥。 我们假设有这么一个用户注册的场景。用户并发请求注册新用户。 你有一张数据库表，也就是下面的 user 表。 user表数据库原始状态user表数据库原始状态 产品经理要求用户和用户..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:image","content":"https://cdn.xiaobaidebug.top/image/006APoFYly8grrdl7zawuj30af0afwiu.jpg"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2024-07-16T01:53:36.000Z"}],["meta",{"name":"twitter:card","content":"summary_large_image"}],["meta",{"name":"twitter:image:alt","content":"两个事务并发写，能保证数据唯一吗？"}],["meta",{"property":"article:author","content":"小白debug"}],["meta",{"property":"article:modified_time","content":"2024-07-16T01:53:36.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"两个事务并发写，能保证数据唯一吗？\\",\\"image\\":[\\"https://cdn.xiaobaidebug.top/image/006APoFYly8grrdl7zawuj30af0afwiu.jpg\\",\\"https://cdn.xiaobaidebug.top/image/user%E8%A1%A8%E6%95%B0%E6%8D%AE%E5%BA%93%E5%8E%9F%E5%A7%8B%E7%8A%B6%E6%80%81.png\\",\\"https://cdn.xiaobaidebug.top/image/ACID.png\\",\\"https://cdn.xiaobaidebug.top/image/%E5%B9%B6%E5%8F%91%E4%BA%8B%E5%8A%A1%E5%86%99%E5%85%A5%E4%B8%A4%E6%9D%A1%E6%95%B0%E6%8D%AE.drawio.png\\",\\"https://cdn.xiaobaidebug.top/Mysql%E6%9E%B6%E6%9E%8456.drawio.png\\",\\"https://cdn.xiaobaidebug.top/image/bufferPool%E4%B8%8E%E7%A3%81%E7%9B%98.png\\",\\"https://cdn.xiaobaidebug.top/image/changeBuffer%E5%9C%A8bufferPool%E5%86%852.png\\",\\"https://cdn.xiaobaidebug.top/image/006ARE9vgy1fz5ahct0mhj30mk0m83zo.jpg\\"],\\"dateModified\\":\\"2024-07-16T01:53:36.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"小白debug\\",\\"url\\":\\"https://xiaobaidebug.top/\\"}]}"],["link",{"rel":"canonical","href":"https://golangguide.top/%E4%B8%AD%E9%97%B4%E4%BB%B6/mysql/%E6%A0%B8%E5%BF%83%E7%9F%A5%E8%AF%86%E7%82%B9/Mysql%E5%B9%B6%E5%8F%91%E5%86%99%E6%95%B0%E6%8D%AE%EF%BC%8C%E6%80%8E%E4%B9%88%E4%BF%9D%E8%AF%81%E5%94%AF%E4%B8%80%E6%80%A7%EF%BC%9F.html"}],["meta",{"property":"og:url","content":"https://golangguide.top/%E4%B8%AD%E9%97%B4%E4%BB%B6/mysql/%E6%A0%B8%E5%BF%83%E7%9F%A5%E8%AF%86%E7%82%B9/Mysql%E5%B9%B6%E5%8F%91%E5%86%99%E6%95%B0%E6%8D%AE%EF%BC%8C%E6%80%8E%E4%B9%88%E4%BF%9D%E8%AF%81%E5%94%AF%E4%B8%80%E6%80%A7%EF%BC%9F.html"}],["meta",{"property":"og:site_name","content":"golang全栈指南"}],["meta",{"property":"og:title","content":"两个事务并发写，能保证数据唯一吗？"}],["meta",{"property":"og:description","content":"两个事务并发写，能保证数据唯一吗？ 哟，又是我小白。最近有点高产了。 连我自己都害怕了。 直接进入正题吧。 两个事务并发写，能保证数据唯一吗？ 我先来解释下标题讲的是个啥。 我们假设有这么一个用户注册的场景。用户并发请求注册新用户。 你有一张数据库表，也就是下面的 user 表。 user表数据库原始状态user表数据库原始状态 产品经理要求用户和用户..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2024-07-16T01:53:36.000Z"}],["meta",{"property":"article:modified_time","content":"2024-07-16T01:53:36.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"两个事务并发写，能保证数据唯一吗？\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2024-07-16T01:53:36.000Z\\",\\"author\\":[]}"]]},"headers":[{"level":2,"title":"两个事务并发写，能保证数据唯一吗？","slug":"两个事务并发写-能保证数据唯一吗-1","link":"#两个事务并发写-能保证数据唯一吗-1","children":[]},{"level":2,"title":"怎么保证数据唯一？","slug":"怎么保证数据唯一","link":"#怎么保证数据唯一","children":[{"level":3,"title":"唯一索引","slug":"唯一索引","link":"#唯一索引","children":[]},{"level":3,"title":"总结","slug":"总结","link":"#总结","children":[]},{"level":3,"title":"最后","slug":"最后","link":"#最后","children":[]}]},{"level":2,"title":"文章推荐：","slug":"文章推荐","link":"#文章推荐","children":[]}],"git":{"createdTime":1708315055000,"updatedTime":1721094816000,"contributors":[{"name":"xiaobai","email":"xiaobaidebug@gmail.com","commits":2},{"name":"xiaobai-tech","email":"948485496@qq.com","commits":2}]},"readingTime":{"minutes":8.03,"words":2410},"filePathRelative":"中间件/mysql/核心知识点/Mysql并发写数据，怎么保证唯一性？.md","localizedDate":"2024年2月19日","autoDesc":true}');export{k as comp,B as data};
