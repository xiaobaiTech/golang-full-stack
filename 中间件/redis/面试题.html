<!doctype html>
<html lang="zh-CN" data-theme="light">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <meta name="generator" content="VuePress 2.0.0-rc.7" />
    <meta name="theme" content="VuePress Theme Hope 2.0.0-rc.23" />
    <style>
      html {
        background: var(--bg-color, #fff);
      }

      html[data-theme="dark"] {
        background: var(--bg-color, #1d1e1f);
      }

      body {
        background: var(--bg-color);
      }
    </style>
    <script>
      const userMode = localStorage.getItem("vuepress-theme-hope-scheme");
      const systemDarkMode =
        window.matchMedia &&
        window.matchMedia("(prefers-color-scheme: dark)").matches;

      if (userMode === "dark" || (userMode !== "light" && systemDarkMode)) {
        document.documentElement.setAttribute("data-theme", "dark");
      }
    </script>
    <meta property="og:url" content="https://golangguide.top/%E4%B8%AD%E9%97%B4%E4%BB%B6/redis/%E9%9D%A2%E8%AF%95%E9%A2%98.html"><meta property="og:site_name" content="golang全栈指南"><meta property="og:title" content="Redis面试题"><meta property="og:description" content="Redis面试题 什么是 Redis? Redis 是完全开源免费的，遵守 BSD 协议，是一个高性能的 key-value 数据库。 Redis 与其他 key - value 缓存产品有以下三个特点： Redis 支持数据的持久化，可以将内存中的数据保存在磁盘中，重启的时候可以再次加载进行使用。 Redis 不仅仅支持简单的 key-value 类..."><meta property="og:type" content="article"><meta property="og:image" content="https://golangguide.top/assets/image/docs/Aspose.Words.51b43265-f45e-4206-a945-0b7c10078cb5.035.jpeg"><meta property="og:locale" content="zh-CN"><meta property="og:updated_time" content="2024-02-13T08:18:41.000Z"><meta name="twitter:card" content="summary_large_image"><meta name="twitter:image:alt" content="Redis面试题"><meta property="article:author" content="小白debug"><meta property="article:modified_time" content="2024-02-13T08:18:41.000Z"><script type="application/ld+json">{"@context":"https://schema.org","@type":"Article","headline":"Redis面试题","image":["https://golangguide.top/assets/image/docs/Aspose.Words.51b43265-f45e-4206-a945-0b7c10078cb5.035.jpeg","https://golangguide.top/assets/image/docs/Aspose.Words.51b43265-f45e-4206-a945-0b7c10078cb5.036.jpeg"],"dateModified":"2024-02-13T08:18:41.000Z","author":[{"@type":"Person","name":"小白debug","url":"https://xiaobaidebug.top/"}]}</script><title>Redis面试题 | golang全栈指南</title><meta name="description" content="Redis面试题 什么是 Redis? Redis 是完全开源免费的，遵守 BSD 协议，是一个高性能的 key-value 数据库。 Redis 与其他 key - value 缓存产品有以下三个特点： Redis 支持数据的持久化，可以将内存中的数据保存在磁盘中，重启的时候可以再次加载进行使用。 Redis 不仅仅支持简单的 key-value 类...">
    <link rel="preload" href="/assets/style-pUUM4cAF.css" as="style"><link rel="stylesheet" href="/assets/style-pUUM4cAF.css">
    <link rel="modulepreload" href="/assets/app-jCQZcvpD.js"><link rel="modulepreload" href="/assets/面试题.html-BfFzw_bw.js"><link rel="modulepreload" href="/assets/plugin-vue_export-helper-DlAUqK2U.js">
    <link rel="prefetch" href="/assets/index.html-DxvaX8zE.js" as="script"><link rel="prefetch" href="/assets/学习路线.html-BCSOY0iW.js" as="script"><link rel="prefetch" href="/assets/目录.html-2DGDTCkT.js" as="script"><link rel="prefetch" href="/assets/介绍.html-CGyhUijF.js" as="script"><link rel="prefetch" href="/assets/入营须知.html-B0a9YUzy.js" as="script"><link rel="prefetch" href="/assets/1.Go入门.html-ZQLpO3QW.js" as="script"><link rel="prefetch" href="/assets/2.Go进阶.html-DW4TkQel.js" as="script"><link rel="prefetch" href="/assets/1. Python 的起源与发展.html-DmvI8JCr.js" as="script"><link rel="prefetch" href="/assets/10. Python 标准库概览.html-BuaEu4aK.js" as="script"><link rel="prefetch" href="/assets/11. 字符串操作与正则表达式.html-iFyZp0k9.js" as="script"><link rel="prefetch" href="/assets/12. 列表、元组、字典与集合.html-BiZ7-JhO.js" as="script"><link rel="prefetch" href="/assets/13. 时间与日期处理.html-Rf0ZULGS.js" as="script"><link rel="prefetch" href="/assets/14. 常用内建函数.html-BQvE9lQG.js" as="script"><link rel="prefetch" href="/assets/15. 生成器与迭代器.html-BU-em7oR.js" as="script"><link rel="prefetch" href="/assets/2. 安装与环境配置.html-CNhd-S5k.js" as="script"><link rel="prefetch" href="/assets/3. 变量、数据类型与运算符.html-Dmuy6hy2.js" as="script"><link rel="prefetch" href="/assets/4. 控制流程：条件与循环.html-BtE3Ef-H.js" as="script"><link rel="prefetch" href="/assets/5. 函数与模块.html-BqzGhkAN.js" as="script"><link rel="prefetch" href="/assets/6. 输入与输出.html-5-OrCoKR.js" as="script"><link rel="prefetch" href="/assets/7. 异常处理.html-ClFv3Rgk.js" as="script"><link rel="prefetch" href="/assets/8. 面向对象编程基础.html-CUBfXqHp.js" as="script"><link rel="prefetch" href="/assets/9. 文件操作与管理.html-CQbj-5jG.js" as="script"><link rel="prefetch" href="/assets/16. 线程与多线程编程.html-p9veyY98.js" as="script"><link rel="prefetch" href="/assets/17. 进程与多进程编程.html-CqpZt3C0.js" as="script"><link rel="prefetch" href="/assets/18. 异步编程与协程.html-DY-UbgT2.js" as="script"><link rel="prefetch" href="/assets/19. 并发编程中的常见问题与解决方案.html-DDnfjDLP.js" as="script"><link rel="prefetch" href="/assets/20. 线程安全与锁机制.html-CcIr8cHF.js" as="script"><link rel="prefetch" href="/assets/21. 进程间通信与共享资源.html-6IVXfIit.js" as="script"><link rel="prefetch" href="/assets/22. 异步编程框架比较.html-zwcq42Yw.js" as="script"><link rel="prefetch" href="/assets/23. GIL 与 Python 多线程.html--kJ-3cdV.js" as="script"><link rel="prefetch" href="/assets/24. 多进程与多线程的选择.html-D2f3mArh.js" as="script"><link rel="prefetch" href="/assets/25. asyncio 库与异步 IO 模型.html-auuDEovt.js" as="script"><link rel="prefetch" href="/assets/26. 多进程池与线程池.html-CfVnbIno.js" as="script"><link rel="prefetch" href="/assets/27. 并行与并发的区别.html-BfXn1kRM.js" as="script"><link rel="prefetch" href="/assets/28. 异步编程中的回调地狱问题.html-BQYx7FQM.js" as="script"><link rel="prefetch" href="/assets/29. 高并发与高性能的设计原则.html-7p2mhzEz.js" as="script"><link rel="prefetch" href="/assets/30. 分布式计算与任务调度.html-BkLtDx8G.js" as="script"><link rel="prefetch" href="/assets/31. 迭代器与生成器.html-DPDVNr3q.js" as="script"><link rel="prefetch" href="/assets/32. 装饰器与闭包.html-FHCaDxpa.js" as="script"><link rel="prefetch" href="/assets/33. 元类与类装饰器.html-BQwokWN8.js" as="script"><link rel="prefetch" href="/assets/34. 设计模式与最佳实践.html-D6iK09gY.js" as="script"><link rel="prefetch" href="/assets/35. 函数式编程风格.html-CaMgkGQk.js" as="script"><link rel="prefetch" href="/assets/36. Python 代码优化与性能提升.html-QXbUonGq.js" as="script"><link rel="prefetch" href="/assets/37. 高级函数与 Lambda 表达式.html-CiAOWn-3.js" as="script"><link rel="prefetch" href="/assets/38. 魔术方法与元编程.html-D6rhWoRZ.js" as="script"><link rel="prefetch" href="/assets/39. 动态类型与静态类型语言对比.html-I4hpk9fk.js" as="script"><link rel="prefetch" href="/assets/40. 高级模块与扩展.html-izkfTj6p.js" as="script"><link rel="prefetch" href="/assets/41. 编码规范与文档.html-CxgtQfP0.js" as="script"><link rel="prefetch" href="/assets/42. 版本控制与 Git.html-B7ofr-On.js" as="script"><link rel="prefetch" href="/assets/43. 虚拟环境与依赖管理.html-B6fw-2Vz.js" as="script"><link rel="prefetch" href="/assets/44. IDE 与编辑器推荐.html-D98Zo_Gi.js" as="script"><link rel="prefetch" href="/assets/45. 调试工具与技巧.html-C3t4Zm2m.js" as="script"><link rel="prefetch" href="/assets/46. 单元测试与集成测试.html-Db-EsE4J.js" as="script"><link rel="prefetch" href="/assets/47. 静态代码分析与 Lint 工具.html-BEnT9Syb.js" as="script"><link rel="prefetch" href="/assets/48. 代码重构与优化工具.html-BIrru61O.js" as="script"><link rel="prefetch" href="/assets/49. CI-CD 与持续集成.html-a8aZATOJ.js" as="script"><link rel="prefetch" href="/assets/50. 文档生成与自动化部署.html-BNMiv5co.js" as="script"><link rel="prefetch" href="/assets/51. 常见算法概述.html-DK_vnLkC.js" as="script"><link rel="prefetch" href="/assets/52. 排序与搜索算法.html-DrWof8Tn.js" as="script"><link rel="prefetch" href="/assets/53. 数据结构与算法设计.html-jljyd4zf.js" as="script"><link rel="prefetch" href="/assets/54. 动态规划与贪心算法.html-CmUmlmmC.js" as="script"><link rel="prefetch" href="/assets/55. 图论与网络流算法.html-DqYkBZaA.js" as="script"><link rel="prefetch" href="/assets/56. 字符串匹配与处理算法.html-DBY6X9Lc.js" as="script"><link rel="prefetch" href="/assets/57. 数论与组合数学.html-B6iVX885.js" as="script"><link rel="prefetch" href="/assets/58. 复杂度分析与算法评估.html-zHH6bSvn.js" as="script"><link rel="prefetch" href="/assets/59. 算法实现与优化技巧.html-BUpUUPJu.js" as="script"><link rel="prefetch" href="/assets/60. 常用数据结构实现.html-BTBCQ7Tp.js" as="script"><link rel="prefetch" href="/assets/61. 数据获取与清洗.html-BpECaEOZ.js" as="script"><link rel="prefetch" href="/assets/62. 数据处理与分析.html-DLiv3FCN.js" as="script"><link rel="prefetch" href="/assets/63. 数据可视化.html-DYr_o7nA.js" as="script"><link rel="prefetch" href="/assets/64. 机器学习入门.html-Z2pWqXIh.js" as="script"><link rel="prefetch" href="/assets/65. 数据挖掘与预测建模.html-CB10NQT7.js" as="script"><link rel="prefetch" href="/assets/66. 数据库与数据仓库.html-CTvb2Qwt.js" as="script"><link rel="prefetch" href="/assets/67. 大数据与分布式计算.html-WzoSWmVH.js" as="script"><link rel="prefetch" href="/assets/68. 自然语言处理基础.html-xDbuLcSH.js" as="script"><link rel="prefetch" href="/assets/69. 图像处理与计算机视觉.html-suwmlEps.js" as="script"><link rel="prefetch" href="/assets/70. 时间序列分析与预测.html-qz-N6DxJ.js" as="script"><link rel="prefetch" href="/assets/71. Linux 基础与常用命令.html-BspAAlxP.js" as="script"><link rel="prefetch" href="/assets/72. 网络基础与常用协议.html-8737NpuL.js" as="script"><link rel="prefetch" href="/assets/73. Web 服务器与部署.html-J66puCd1.js" as="script"><link rel="prefetch" href="/assets/74. 数据库基础与管理.html-CrLYGwCv.js" as="script"><link rel="prefetch" href="/assets/75. 容器化与 Docker.html-pKnpoq_4.js" as="script"><link rel="prefetch" href="/assets/76. 自动化运维与配置管理.html-i7hkUylh.js" as="script"><link rel="prefetch" href="/assets/77. 负载均衡与高可用性.html-BeRwhzet.js" as="script"><link rel="prefetch" href="/assets/78. 日志与监控系统.html-nEzQVGBa.js" as="script"><link rel="prefetch" href="/assets/79. 安全与漏洞管理.html-DXevcE8p.js" as="script"><link rel="prefetch" href="/assets/80. 云计算与云服务.html-CHYgn0At.js" as="script"><link rel="prefetch" href="/assets/81. NumPy 与 SciPy.html-q5MNutSl.js" as="script"><link rel="prefetch" href="/assets/82. Pandas.html-CS51GKXh.js" as="script"><link rel="prefetch" href="/assets/83. Matplotlib 与 Seaborn.html-bPtYRAza.js" as="script"><link rel="prefetch" href="/assets/84. Requests 与 Beautiful Soup.html-D-9gEwSc.js" as="script"><link rel="prefetch" href="/assets/85. Django 与 Flask.html-DyFthDAA.js" as="script"><link rel="prefetch" href="/assets/86. SQLAlchemy 与 ORM.html-CKiM1wWM.js" as="script"><link rel="prefetch" href="/assets/87. Celery 与任务队列.html-BiAi79IT.js" as="script"><link rel="prefetch" href="/assets/88. TensorFlow 与机器学习库.html-BpjgsHqc.js" as="script"><link rel="prefetch" href="/assets/89. PyQT 与 GUI 开发.html-oACUpnbj.js" as="script"><link rel="prefetch" href="/assets/90. GIS 与地理信息处理.html-CaAg7IOT.js" as="script"><link rel="prefetch" href="/assets/100.  项目总结与回顾.html-XH2siEMb.js" as="script"><link rel="prefetch" href="/assets/91. 项目介绍与需求分析.html-CqFuZJvk.js" as="script"><link rel="prefetch" href="/assets/92. 项目架构与设计.html-Drh7NRkf.js" as="script"><link rel="prefetch" href="/assets/93. 代码实现与测试.html-CsykAVn-.js" as="script"><link rel="prefetch" href="/assets/94. 项目部署与维护.html-BPy0DrjP.js" as="script"><link rel="prefetch" href="/assets/95. 用户反馈与迭代优化.html-Cqvkbtyg.js" as="script"><link rel="prefetch" href="/assets/96. 项目文档与知识分享.html-DsKwFl5J.js" as="script"><link rel="prefetch" href="/assets/97. 团队协作与版本控制.html-DP2aeZaY.js" as="script"><link rel="prefetch" href="/assets/98. 项目上线与发布.html-BkqwBOcT.js" as="script"><link rel="prefetch" href="/assets/99. 故障处理与紧急修复.html-BwbHrdL1.js" as="script"><link rel="prefetch" href="/assets/面试题.html-DfW9PX9O.js" as="script"><link rel="prefetch" href="/assets/面试题.html-CPP-N3FX.js" as="script"><link rel="prefetch" href="/assets/面试题.html-CiDnFlvA.js" as="script"><link rel="prefetch" href="/assets/面试题.html-DGpN2Rpe.js" as="script"><link rel="prefetch" href="/assets/面试题.html-Dbolb9jL.js" as="script"><link rel="prefetch" href="/assets/面试题.html-Ci9z5RrN.js" as="script"><link rel="prefetch" href="/assets/面试题.html-CpVX3-iY.js" as="script"><link rel="prefetch" href="/assets/面试题.html-BiHzHBZ3.js" as="script"><link rel="prefetch" href="/assets/面试题.html-a4LtF8FF.js" as="script"><link rel="prefetch" href="/assets/面试题.html-CZ1d9ghC.js" as="script"><link rel="prefetch" href="/assets/面试题.html-CvVSb7iF.js" as="script"><link rel="prefetch" href="/assets/面试题.html-Bm7BgNJA.js" as="script"><link rel="prefetch" href="/assets/面试题.html-ukKAeP5i.js" as="script"><link rel="prefetch" href="/assets/404.html-BgAfuAoq.js" as="script"><link rel="prefetch" href="/assets/index.html-BRWhJdg3.js" as="script"><link rel="prefetch" href="/assets/index.html-CzjzUwQG.js" as="script"><link rel="prefetch" href="/assets/index.html-Ce_lU0Vb.js" as="script"><link rel="prefetch" href="/assets/index.html-CEmUwOMx.js" as="script"><link rel="prefetch" href="/assets/index.html-D3jF-Ahh.js" as="script"><link rel="prefetch" href="/assets/index.html-D65v0X_e.js" as="script"><link rel="prefetch" href="/assets/index.html-CFFzuk5I.js" as="script"><link rel="prefetch" href="/assets/index.html-BUAvKCdv.js" as="script"><link rel="prefetch" href="/assets/index.html-_ltkC9Fl.js" as="script"><link rel="prefetch" href="/assets/index.html-DY-gDP99.js" as="script"><link rel="prefetch" href="/assets/index.html-DkvG5xjs.js" as="script"><link rel="prefetch" href="/assets/index.html-D3QqAkSB.js" as="script"><link rel="prefetch" href="/assets/index.html-CFINbN_3.js" as="script"><link rel="prefetch" href="/assets/index.html-BbQndTRj.js" as="script"><link rel="prefetch" href="/assets/index.html-B7MMOXJ9.js" as="script"><link rel="prefetch" href="/assets/index.html-CYpLIk-w.js" as="script"><link rel="prefetch" href="/assets/index.html-DJgF41Ej.js" as="script"><link rel="prefetch" href="/assets/index.html-Cjx2qAir.js" as="script"><link rel="prefetch" href="/assets/index.html-lHYub6wj.js" as="script"><link rel="prefetch" href="/assets/index.html-Dou3N5Qm.js" as="script"><link rel="prefetch" href="/assets/index.html-LfnjJydx.js" as="script"><link rel="prefetch" href="/assets/index.html-B6f0oM-x.js" as="script"><link rel="prefetch" href="/assets/index.html-CNsMZh_p.js" as="script"><link rel="prefetch" href="/assets/index.html-B1NPTTTI.js" as="script"><link rel="prefetch" href="/assets/index.html-BLsCW4rw.js" as="script"><link rel="prefetch" href="/assets/index.html-IixDESwQ.js" as="script"><link rel="prefetch" href="/assets/index.html-BxUhY7yf.js" as="script"><link rel="prefetch" href="/assets/index.html-x-Rrv4bc.js" as="script"><link rel="prefetch" href="/assets/index.html-D7U_Wq_O.js" as="script"><link rel="prefetch" href="/assets/index.html-B6PW0E46.js" as="script"><link rel="prefetch" href="/assets/index.html-CW6RLuZ_.js" as="script"><link rel="prefetch" href="/assets/giscus-7BMGhbDA.js" as="script"><link rel="prefetch" href="/assets/auto-C0MMSKEI.js" as="script"><link rel="prefetch" href="/assets/index-DA4axBLK.js" as="script"><link rel="prefetch" href="/assets/flowchart-966sEcGG.js" as="script"><link rel="prefetch" href="/assets/mermaid.core-DHXCryRm.js" as="script"><link rel="prefetch" href="/assets/reveal.esm-9nNZbZvi.js" as="script"><link rel="prefetch" href="/assets/markdown.esm-BG2Xu2Hd.js" as="script"><link rel="prefetch" href="/assets/vue-repl-DHMTDtqS.js" as="script"><link rel="prefetch" href="/assets/codemirror-editor-DiwYWCOa.js" as="script"><link rel="prefetch" href="/assets/photoswipe.esm-SzV8tJDW.js" as="script">
  </head>
  <body>
    <div id="app"><!--[--><!--[--><!--[--><span tabindex="-1"></span><a href="#main-content" class="vp-skip-link sr-only">跳至主要內容</a><!--]--><div class="theme-container has-toc"><!--[--><header id="navbar" class="vp-navbar"><div class="vp-navbar-start"><button type="button" class="vp-toggle-sidebar-button" title="Toggle Sidebar"><span class="icon"></span></button><!--[--><!----><!--]--><!--[--><a class="route-link vp-brand" href="/"><img class="vp-nav-logo" src="/new_logo.png" alt><!----><span class="vp-site-name hide-in-pad">golang全栈指南</span></a><!--]--><!--[--><!----><!--]--></div><div class="vp-navbar-center"><!--[--><!----><!--]--><!--[--><nav class="vp-nav-links"><div class="nav-item hide-in-mobile"><a class="route-link nav-link" href="/" aria-label="主页"><span class="font-icon icon fa-fw fa-sm fas fa-home" style=""></span>主页<!----></a></div><div class="nav-item hide-in-mobile"><a class="route-link nav-link" href="/python/" aria-label="Python"><!---->Python<!----></a></div><div class="nav-item hide-in-mobile"><div class="dropdown-wrapper"><button type="button" class="dropdown-title" aria-label="训练营"><span class="title"><span class="font-icon icon fa-fw fa-sm fas fa-campground" style=""></span>训练营</span><span class="arrow"></span><ul class="nav-dropdown"><li class="dropdown-item"><a class="route-link nav-link" href="/%E8%AE%AD%E7%BB%83%E8%90%A5/%E4%BB%8B%E7%BB%8D.html" aria-label="介绍"><span class="font-icon icon fa-fw fa-sm fas fa-address-card" style=""></span>介绍<!----></a></li><li class="dropdown-item"><a class="route-link nav-link" href="/%E8%AE%AD%E7%BB%83%E8%90%A5/%E5%85%A5%E8%90%A5%E9%A1%BB%E7%9F%A5.html" aria-label="入营须知"><span class="font-icon icon fa-fw fa-sm fas fa-brain" style=""></span>入营须知<!----></a></li></ul></button></div></div><div class="nav-item hide-in-mobile"><div class="dropdown-wrapper"><button type="button" class="dropdown-title" aria-label="计算机基础"><span class="title"><span class="font-icon icon fa-fw fa-sm fas fa-computer" style=""></span>计算机基础</span><span class="arrow"></span><ul class="nav-dropdown"><li class="dropdown-item"><a class="route-link nav-link" href="/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" aria-label="操作系统"><span class="font-icon icon fa-fw fa-sm fas fa-server" style=""></span>操作系统<!----></a></li></ul></button></div></div><div class="nav-item hide-in-mobile"><div class="dropdown-wrapper"><button type="button" class="dropdown-title" aria-label="架构"><span class="title"><span class="font-icon icon fa-fw fa-sm fas fa-folder-tree" style=""></span>架构</span><span class="arrow"></span><ul class="nav-dropdown"><li class="dropdown-item"><a class="route-link nav-link" href="/%E6%9E%B6%E6%9E%84/Docker/" aria-label="Docker"><span class="font-icon icon fa-fw fa-sm fas fa-box" style=""></span>Docker<!----></a></li><li class="dropdown-item"><a class="route-link nav-link" href="/%E6%9E%B6%E6%9E%84/%E5%88%86%E5%B8%83%E5%BC%8F/" aria-label="分布式"><span class="font-icon icon fa-fw fa-sm fas fa-manat-sign" style=""></span>分布式<!----></a></li><li class="dropdown-item"><a class="route-link nav-link" href="/%E6%9E%B6%E6%9E%84/%E5%BE%AE%E6%9C%8D%E5%8A%A1/" aria-label="微服务"><span class="font-icon icon fa-fw fa-sm fas fa-microchip" style=""></span>微服务<!----></a></li><li class="dropdown-item"><a class="route-link nav-link" href="/%E6%9E%B6%E6%9E%84/%E8%BF%90%E7%BB%B4/" aria-label="运维"><span class="font-icon icon fa-fw fa-sm fas fa-folder-open" style=""></span>运维<!----></a></li></ul></button></div></div><div class="nav-item hide-in-mobile"><div class="dropdown-wrapper"><button type="button" class="dropdown-title" aria-label="中间件"><span class="title"><span class="font-icon icon fa-fw fa-sm fas fa-align-center" style=""></span>中间件</span><span class="arrow"></span><ul class="nav-dropdown"><li class="dropdown-item"><a class="route-link nav-link" href="/%E4%B8%AD%E9%97%B4%E4%BB%B6/es/" aria-label="ES"><span class="font-icon icon fa-fw fa-sm fas fa-magnifying-glass" style=""></span>ES<!----></a></li><li class="dropdown-item"><a class="route-link nav-link" href="/%E4%B8%AD%E9%97%B4%E4%BB%B6/kafka/" aria-label="Kafka"><span class="font-icon icon fa-fw fa-sm fas fa-chess-queen" style=""></span>Kafka<!----></a></li><li class="dropdown-item"><a class="route-link nav-link" href="/%E4%B8%AD%E9%97%B4%E4%BB%B6/Memcached/" aria-label="Memcached"><span class="font-icon icon fa-fw fa-sm fas fa-suitcase" style=""></span>Memcached<!----></a></li><li class="dropdown-item"><a class="route-link nav-link" href="/%E4%B8%AD%E9%97%B4%E4%BB%B6/mongodb/" aria-label="Mongodb"><span class="font-icon icon fa-fw fa-sm fas fa-vr-cardboard" style=""></span>Mongodb<!----></a></li><li class="dropdown-item"><a class="route-link nav-link" href="/%E4%B8%AD%E9%97%B4%E4%BB%B6/mysql/" aria-label="Mysql"><span class="font-icon icon fa-fw fa-sm fas fa-database" style=""></span>Mysql<!----></a></li><li class="dropdown-item"><a class="route-link nav-link" href="/%E4%B8%AD%E9%97%B4%E4%BB%B6/nginx/" aria-label="Nginx"><span class="font-icon icon fa-fw fa-sm fas fa-network-wired" style=""></span>Nginx<!----></a></li><li class="dropdown-item"><a class="route-link nav-link" href="/%E4%B8%AD%E9%97%B4%E4%BB%B6/rabbitmq/" aria-label="RabbitMQ"><span class="font-icon icon fa-fw fa-sm fas fa-frog" style=""></span>RabbitMQ<!----></a></li><li class="dropdown-item"><a class="route-link nav-link active" href="/%E4%B8%AD%E9%97%B4%E4%BB%B6/redis/" aria-label="Redis"><span class="font-icon icon fa-fw fa-sm fas fa-registered" style=""></span>Redis<!----></a></li><li class="dropdown-item"><a class="route-link nav-link" href="/%E4%B8%AD%E9%97%B4%E4%BB%B6/rocketmq/" aria-label="RocketMQ"><span class="font-icon icon fa-fw fa-sm fas fa-rocket" style=""></span>RocketMQ<!----></a></li></ul></button></div></div><div class="nav-item hide-in-mobile"><div class="dropdown-wrapper"><button type="button" class="dropdown-title" aria-label="Golang"><span class="title"><span class="font-icon icon fa-fw fa-sm fas fa-lightbulb" style=""></span>Golang</span><span class="arrow"></span><ul class="nav-dropdown"><li class="dropdown-item"><a class="route-link nav-link" href="/golang/%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF.html" aria-label="学习路线"><span class="font-icon icon fa-fw fa-sm fas fa-map-location-dot" style=""></span>学习路线<!----></a></li><li class="dropdown-item"><a class="route-link nav-link" href="/golang/%E9%9D%A2%E8%AF%95%E9%A2%98/1.Go%E5%85%A5%E9%97%A8.html" aria-label="基础面试题"><span class="font-icon icon fa-fw fa-sm fas fa-disease" style=""></span>基础面试题<!----></a></li><li class="dropdown-item"><a class="route-link nav-link" href="/golang/%E9%9D%A2%E8%AF%95%E9%A2%98/2.Go%E8%BF%9B%E9%98%B6.html" aria-label="进阶面试题"><span class="font-icon icon fa-fw fa-sm fas fa-clipboard-question" style=""></span>进阶面试题<!----></a></li></ul></button></div></div><div class="nav-item hide-in-mobile"><a href="https://xiaobaidebug.top/" rel="noopener noreferrer" target="_blank" aria-label="blog" class="nav-link"><span class="font-icon icon fa-fw fa-sm fas fa-book" style=""></span>blog<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span><!----></a></div><div class="nav-item hide-in-mobile"><a href="https://golangguide.top/sitemap.xml" rel="noopener noreferrer" target="_blank" aria-label="sitemap" class="nav-link"><span class="font-icon icon fa-fw fa-sm fas fa-blog" style=""></span>sitemap<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span><!----></a></div></nav><!--]--><!--[--><!----><!--]--></div><div class="vp-navbar-end"><!--[--><!----><!--]--><!--[--><!----><div class="nav-item vp-repo"><a class="vp-repo-link" href="https://github.com/xiaobaiTech/golang-full-stack" target="_blank" rel="noopener noreferrer" aria-label="GitHub"><svg xmlns="http://www.w3.org/2000/svg" class="icon github-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="github icon" style="width:1.25rem;height:1.25rem;vertical-align:middle;"><path d="M511.957 21.333C241.024 21.333 21.333 240.981 21.333 512c0 216.832 140.544 400.725 335.574 465.664 24.49 4.395 32.256-10.07 32.256-23.083 0-11.69.256-44.245 0-85.205-136.448 29.61-164.736-64.64-164.736-64.64-22.315-56.704-54.4-71.765-54.4-71.765-44.587-30.464 3.285-29.824 3.285-29.824 49.195 3.413 75.179 50.517 75.179 50.517 43.776 75.008 114.816 53.333 142.762 40.79 4.523-31.66 17.152-53.377 31.19-65.537-108.971-12.458-223.488-54.485-223.488-242.602 0-53.547 19.114-97.323 50.517-131.67-5.035-12.33-21.93-62.293 4.779-129.834 0 0 41.258-13.184 134.912 50.346a469.803 469.803 0 0 1 122.88-16.554c41.642.213 83.626 5.632 122.88 16.554 93.653-63.488 134.784-50.346 134.784-50.346 26.752 67.541 9.898 117.504 4.864 129.834 31.402 34.347 50.474 78.123 50.474 131.67 0 188.586-114.73 230.016-224.042 242.09 17.578 15.232 33.578 44.672 33.578 90.454v135.85c0 13.142 7.936 27.606 32.854 22.87C862.25 912.597 1002.667 728.747 1002.667 512c0-271.019-219.648-490.667-490.71-490.667z"></path></svg></a></div><div class="nav-item hide-in-mobile"><button type="button" id="appearance-switch"><svg xmlns="http://www.w3.org/2000/svg" class="icon auto-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="auto icon" style="display:block;"><path d="M512 992C246.92 992 32 777.08 32 512S246.92 32 512 32s480 214.92 480 480-214.92 480-480 480zm0-840c-198.78 0-360 161.22-360 360 0 198.84 161.22 360 360 360s360-161.16 360-360c0-198.78-161.22-360-360-360zm0 660V212c165.72 0 300 134.34 300 300 0 165.72-134.28 300-300 300z"></path></svg><svg xmlns="http://www.w3.org/2000/svg" class="icon dark-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="dark icon" style="display:none;"><path d="M524.8 938.667h-4.267a439.893 439.893 0 0 1-313.173-134.4 446.293 446.293 0 0 1-11.093-597.334A432.213 432.213 0 0 1 366.933 90.027a42.667 42.667 0 0 1 45.227 9.386 42.667 42.667 0 0 1 10.24 42.667 358.4 358.4 0 0 0 82.773 375.893 361.387 361.387 0 0 0 376.747 82.774 42.667 42.667 0 0 1 54.187 55.04 433.493 433.493 0 0 1-99.84 154.88 438.613 438.613 0 0 1-311.467 128z"></path></svg><svg xmlns="http://www.w3.org/2000/svg" class="icon light-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="light icon" style="display:none;"><path d="M952 552h-80a40 40 0 0 1 0-80h80a40 40 0 0 1 0 80zM801.88 280.08a41 41 0 0 1-57.96-57.96l57.96-58a41.04 41.04 0 0 1 58 58l-58 57.96zM512 752a240 240 0 1 1 0-480 240 240 0 0 1 0 480zm0-560a40 40 0 0 1-40-40V72a40 40 0 0 1 80 0v80a40 40 0 0 1-40 40zm-289.88 88.08-58-57.96a41.04 41.04 0 0 1 58-58l57.96 58a41 41 0 0 1-57.96 57.96zM192 512a40 40 0 0 1-40 40H72a40 40 0 0 1 0-80h80a40 40 0 0 1 40 40zm30.12 231.92a41 41 0 0 1 57.96 57.96l-57.96 58a41.04 41.04 0 0 1-58-58l58-57.96zM512 832a40 40 0 0 1 40 40v80a40 40 0 0 1-80 0v-80a40 40 0 0 1 40-40zm289.88-88.08 58 57.96a41.04 41.04 0 0 1-58 58l-57.96-58a41 41 0 0 1 57.96-57.96z"></path></svg></button></div><!----><!--]--><!--[--><!----><!--]--><button type="button" class="vp-toggle-navbar-button" aria-label="Toggle Navbar" aria-expanded="false" aria-controls="nav-screen"><span><span class="vp-top"></span><span class="vp-middle"></span><span class="vp-bottom"></span></span></button></div></header><!----><!--]--><!----><div class="toggle-sidebar-wrapper"><span class="arrow start"></span></div><aside id="sidebar" class="vp-sidebar"><!--[--><!----><!--]--><ul class="vp-sidebar-links"><li><section class="vp-sidebar-group"><p class="vp-sidebar-heading clickable active"><span class="font-icon icon fa-fw fa-sm fas fa-laptop-code" style=""></span><a class="route-link nav-link vp-sidebar-title" href="/中间件/中间件/" aria-label="中间件"><!---->中间件<!----></a><!----></p><ul class="vp-sidebar-links"><li><section class="vp-sidebar-group"><button class="vp-sidebar-heading clickable" type="button"><!----><span class="vp-sidebar-title">Es</span><span class="vp-arrow end"></span></button><!----></section></li><li><section class="vp-sidebar-group"><button class="vp-sidebar-heading clickable" type="button"><!----><span class="vp-sidebar-title">Kafka</span><span class="vp-arrow end"></span></button><!----></section></li><li><section class="vp-sidebar-group"><button class="vp-sidebar-heading clickable" type="button"><!----><span class="vp-sidebar-title">Memcached</span><span class="vp-arrow end"></span></button><!----></section></li><li><section class="vp-sidebar-group"><button class="vp-sidebar-heading clickable" type="button"><!----><span class="vp-sidebar-title">Mongodb</span><span class="vp-arrow end"></span></button><!----></section></li><li><section class="vp-sidebar-group"><button class="vp-sidebar-heading clickable" type="button"><!----><span class="vp-sidebar-title">Mysql</span><span class="vp-arrow end"></span></button><!----></section></li><li><section class="vp-sidebar-group"><button class="vp-sidebar-heading clickable" type="button"><!----><span class="vp-sidebar-title">Nginx</span><span class="vp-arrow end"></span></button><!----></section></li><li><section class="vp-sidebar-group"><button class="vp-sidebar-heading clickable" type="button"><!----><span class="vp-sidebar-title">Rabbitmq</span><span class="vp-arrow end"></span></button><!----></section></li><li><section class="vp-sidebar-group"><button class="vp-sidebar-heading clickable active" type="button"><!----><span class="vp-sidebar-title">Redis</span><span class="vp-arrow down"></span></button><ul class="vp-sidebar-links"><li><!--[--><a class="route-link nav-link active vp-sidebar-link vp-sidebar-page active" href="/%E4%B8%AD%E9%97%B4%E4%BB%B6/redis/%E9%9D%A2%E8%AF%95%E9%A2%98.html" aria-label="Redis面试题"><!---->Redis面试题<!----></a><ul class="vp-sidebar-sub-headers"><li class="vp-sidebar-sub-header"><a class="route-link nav-link vp-sidebar-link vp-heading" href="/%E4%B8%AD%E9%97%B4%E4%BB%B6/redis/%E9%9D%A2%E8%AF%95%E9%A2%98.html#什么是-redis" aria-label="什么是 Redis?"><!---->什么是 Redis?<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a class="route-link nav-link vp-sidebar-link vp-heading" href="/%E4%B8%AD%E9%97%B4%E4%BB%B6/redis/%E9%9D%A2%E8%AF%95%E9%A2%98.html#redis-的数据类型" aria-label="Redis 的数据类型？"><!---->Redis 的数据类型？<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a class="route-link nav-link vp-sidebar-link vp-heading" href="/%E4%B8%AD%E9%97%B4%E4%BB%B6/redis/%E9%9D%A2%E8%AF%95%E9%A2%98.html#使用-redis-有哪些好处" aria-label="使用 Redis 有哪些好处？"><!---->使用 Redis 有哪些好处？<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a class="route-link nav-link vp-sidebar-link vp-heading" href="/%E4%B8%AD%E9%97%B4%E4%BB%B6/redis/%E9%9D%A2%E8%AF%95%E9%A2%98.html#redis-相比-memcached-有哪些优势" aria-label="Redis 相比 Memcached 有哪些优势？"><!---->Redis 相比 Memcached 有哪些优势？<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a class="route-link nav-link vp-sidebar-link vp-heading" href="/%E4%B8%AD%E9%97%B4%E4%BB%B6/redis/%E9%9D%A2%E8%AF%95%E9%A2%98.html#memcache-与-redis-的区别都有哪些" aria-label="Memcache 与 Redis 的区别都有哪些？"><!---->Memcache 与 Redis 的区别都有哪些？<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a class="route-link nav-link vp-sidebar-link vp-heading" href="/%E4%B8%AD%E9%97%B4%E4%BB%B6/redis/%E9%9D%A2%E8%AF%95%E9%A2%98.html#redis-是单进程单线程的" aria-label="Redis 是单进程单线程的？"><!---->Redis 是单进程单线程的？<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a class="route-link nav-link vp-sidebar-link vp-heading" href="/%E4%B8%AD%E9%97%B4%E4%BB%B6/redis/%E9%9D%A2%E8%AF%95%E9%A2%98.html#一个字符串类型的值能存储最大容量是多少" aria-label="一个字符串类型的值能存储最大容量是多少？"><!---->一个字符串类型的值能存储最大容量是多少？<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a class="route-link nav-link vp-sidebar-link vp-heading" href="/%E4%B8%AD%E9%97%B4%E4%BB%B6/redis/%E9%9D%A2%E8%AF%95%E9%A2%98.html#redis-集群最大节点个数是多少" aria-label="Redis 集群最大节点个数是多少？"><!---->Redis 集群最大节点个数是多少？<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a class="route-link nav-link vp-sidebar-link vp-heading" href="/%E4%B8%AD%E9%97%B4%E4%BB%B6/redis/%E9%9D%A2%E8%AF%95%E9%A2%98.html#reids-的特点" aria-label="Reids 的特点"><!---->Reids 的特点<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a class="route-link nav-link vp-sidebar-link vp-heading" href="/%E4%B8%AD%E9%97%B4%E4%BB%B6/redis/%E9%9D%A2%E8%AF%95%E9%A2%98.html#使用-redis-有哪些好处-1" aria-label="使用 Redis 有哪些好处？"><!---->使用 Redis 有哪些好处？<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a class="route-link nav-link vp-sidebar-link vp-heading" href="/%E4%B8%AD%E9%97%B4%E4%BB%B6/redis/%E9%9D%A2%E8%AF%95%E9%A2%98.html#为什么-edis-需要把所有数据放到内存中" aria-label="为什么 edis 需要把所有数据放到内存中？"><!---->为什么 edis 需要把所有数据放到内存中？<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a class="route-link nav-link vp-sidebar-link vp-heading" href="/%E4%B8%AD%E9%97%B4%E4%BB%B6/redis/%E9%9D%A2%E8%AF%95%E9%A2%98.html#redis-的内存用完了会发生什么" aria-label="Redis 的内存用完了会发生什么？"><!---->Redis 的内存用完了会发生什么？<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a class="route-link nav-link vp-sidebar-link vp-heading" href="/%E4%B8%AD%E9%97%B4%E4%BB%B6/redis/%E9%9D%A2%E8%AF%95%E9%A2%98.html#redis-的回收策略-淘汰策略" aria-label="Redis  的回收策略（淘汰策略）"><!---->Redis  的回收策略（淘汰策略）<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a class="route-link nav-link vp-sidebar-link vp-heading" href="/%E4%B8%AD%E9%97%B4%E4%BB%B6/redis/%E9%9D%A2%E8%AF%95%E9%A2%98.html#redis-的持久化机制是什么-各自的优缺点" aria-label="Redis 的持久化机制是什么？各自的优缺点？"><!---->Redis 的持久化机制是什么？各自的优缺点？<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a class="route-link nav-link vp-sidebar-link vp-heading" href="/%E4%B8%AD%E9%97%B4%E4%BB%B6/redis/%E9%9D%A2%E8%AF%95%E9%A2%98.html#redis-常见性能问题和解决方案" aria-label="Redis 常见性能问题和解决方案："><!---->Redis 常见性能问题和解决方案：<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a class="route-link nav-link vp-sidebar-link vp-heading" href="/%E4%B8%AD%E9%97%B4%E4%BB%B6/redis/%E9%9D%A2%E8%AF%95%E9%A2%98.html#redis-过期键的删除策略" aria-label="Redis 过期键的删除策略？"><!---->Redis 过期键的删除策略？<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a class="route-link nav-link vp-sidebar-link vp-heading" href="/%E4%B8%AD%E9%97%B4%E4%BB%B6/redis/%E9%9D%A2%E8%AF%95%E9%A2%98.html#redis-的回收策略-淘汰策略-1" aria-label="Redis 的回收策略（淘汰策略）?"><!---->Redis 的回收策略（淘汰策略）?<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a class="route-link nav-link vp-sidebar-link vp-heading" href="/%E4%B8%AD%E9%97%B4%E4%BB%B6/redis/%E9%9D%A2%E8%AF%95%E9%A2%98.html#为什么-redis-需要把所有数据放到内存中" aria-label="为什么 Redis 需要把所有数据放到内存中？"><!---->为什么 Redis 需要把所有数据放到内存中？<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a class="route-link nav-link vp-sidebar-link vp-heading" href="/%E4%B8%AD%E9%97%B4%E4%BB%B6/redis/%E9%9D%A2%E8%AF%95%E9%A2%98.html#redis-的同步机制了解么" aria-label="Redis 的同步机制了解么？"><!---->Redis 的同步机制了解么？<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a class="route-link nav-link vp-sidebar-link vp-heading" href="/%E4%B8%AD%E9%97%B4%E4%BB%B6/redis/%E9%9D%A2%E8%AF%95%E9%A2%98.html#pipeline-有什么好处-为什么要用-pipeline" aria-label="Pipeline 有什么好处，为什么要用 Pipeline？"><!---->Pipeline 有什么好处，为什么要用 Pipeline？<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a class="route-link nav-link vp-sidebar-link vp-heading" href="/%E4%B8%AD%E9%97%B4%E4%BB%B6/redis/%E9%9D%A2%E8%AF%95%E9%A2%98.html#是否使用过-redis-集群-集群的原理是什么" aria-label="是否使用过 Redis 集群，集群的原理是什么？"><!---->是否使用过 Redis 集群，集群的原理是什么？<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a class="route-link nav-link vp-sidebar-link vp-heading" href="/%E4%B8%AD%E9%97%B4%E4%BB%B6/redis/%E9%9D%A2%E8%AF%95%E9%A2%98.html#redis-集群方案什么情况下会导致整个集群不可用" aria-label="Redis 集群方案什么情况下会导致整个集群不可用？"><!---->Redis 集群方案什么情况下会导致整个集群不可用？<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a class="route-link nav-link vp-sidebar-link vp-heading" href="/%E4%B8%AD%E9%97%B4%E4%BB%B6/redis/%E9%9D%A2%E8%AF%95%E9%A2%98.html#redis-支持的-java-客户端都有哪些-官方推荐用哪个" aria-label="Redis 支持的 Java 客户端都有哪些？官方推荐用哪个？"><!---->Redis 支持的 Java 客户端都有哪些？官方推荐用哪个？<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a class="route-link nav-link vp-sidebar-link vp-heading" href="/%E4%B8%AD%E9%97%B4%E4%BB%B6/redis/%E9%9D%A2%E8%AF%95%E9%A2%98.html#jedis-与-redisson-对比有什么优缺点" aria-label="Jedis 与 Redisson 对比有什么优缺点？"><!---->Jedis 与 Redisson 对比有什么优缺点？<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a class="route-link nav-link vp-sidebar-link vp-heading" href="/%E4%B8%AD%E9%97%B4%E4%BB%B6/redis/%E9%9D%A2%E8%AF%95%E9%A2%98.html#redis-如何设置密码及验证密码" aria-label="Redis 如何设置密码及验证密码？"><!---->Redis 如何设置密码及验证密码？<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a class="route-link nav-link vp-sidebar-link vp-heading" href="/%E4%B8%AD%E9%97%B4%E4%BB%B6/redis/%E9%9D%A2%E8%AF%95%E9%A2%98.html#说说-redis-哈希槽的概念" aria-label="说说 Redis 哈希槽的概念？"><!---->说说 Redis 哈希槽的概念？<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a class="route-link nav-link vp-sidebar-link vp-heading" href="/%E4%B8%AD%E9%97%B4%E4%BB%B6/redis/%E9%9D%A2%E8%AF%95%E9%A2%98.html#redis-集群的主从复制模型是怎样的" aria-label="Redis 集群的主从复制模型是怎样的？"><!---->Redis 集群的主从复制模型是怎样的？<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a class="route-link nav-link vp-sidebar-link vp-heading" href="/%E4%B8%AD%E9%97%B4%E4%BB%B6/redis/%E9%9D%A2%E8%AF%95%E9%A2%98.html#redis-集群会有写操作丢失吗-为什么" aria-label="Redis 集群会有写操作丢失吗？为什么？"><!---->Redis 集群会有写操作丢失吗？为什么？<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a class="route-link nav-link vp-sidebar-link vp-heading" href="/%E4%B8%AD%E9%97%B4%E4%BB%B6/redis/%E9%9D%A2%E8%AF%95%E9%A2%98.html#redis-集群之间是如何复制的" aria-label="Redis 集群之间是如何复制的？"><!---->Redis 集群之间是如何复制的？<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a class="route-link nav-link vp-sidebar-link vp-heading" href="/%E4%B8%AD%E9%97%B4%E4%BB%B6/redis/%E9%9D%A2%E8%AF%95%E9%A2%98.html#redis-集群最大节点个数是多少-1" aria-label="Redis 集群最大节点个数是多少？"><!---->Redis 集群最大节点个数是多少？<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a class="route-link nav-link vp-sidebar-link vp-heading" href="/%E4%B8%AD%E9%97%B4%E4%BB%B6/redis/%E9%9D%A2%E8%AF%95%E9%A2%98.html#redis-集群如何选择数据库" aria-label="Redis 集群如何选择数据库？"><!---->Redis 集群如何选择数据库？<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a class="route-link nav-link vp-sidebar-link vp-heading" href="/%E4%B8%AD%E9%97%B4%E4%BB%B6/redis/%E9%9D%A2%E8%AF%95%E9%A2%98.html#怎么测试-redis-的连通性" aria-label="怎么测试 Redis 的连通性"><!---->怎么测试 Redis 的连通性<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a class="route-link nav-link vp-sidebar-link vp-heading" href="/%E4%B8%AD%E9%97%B4%E4%BB%B6/redis/%E9%9D%A2%E8%AF%95%E9%A2%98.html#怎么理解-redis-事务" aria-label="怎么理解 Redis 事务？"><!---->怎么理解 Redis 事务？<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a class="route-link nav-link vp-sidebar-link vp-heading" href="/%E4%B8%AD%E9%97%B4%E4%BB%B6/redis/%E9%9D%A2%E8%AF%95%E9%A2%98.html#redis-事务相关的命令有哪几个" aria-label="Redis 事务相关的命令有哪几个？"><!---->Redis 事务相关的命令有哪几个？<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a class="route-link nav-link vp-sidebar-link vp-heading" href="/%E4%B8%AD%E9%97%B4%E4%BB%B6/redis/%E9%9D%A2%E8%AF%95%E9%A2%98.html#redis-key-的过期时间和永久有效分别怎么设置" aria-label="Redis key 的过期时间和永久有效分别怎么设置？"><!---->Redis key 的过期时间和永久有效分别怎么设置？<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a class="route-link nav-link vp-sidebar-link vp-heading" href="/%E4%B8%AD%E9%97%B4%E4%BB%B6/redis/%E9%9D%A2%E8%AF%95%E9%A2%98.html#redis-如何做内存优化" aria-label="Redis 如何做内存优化？"><!---->Redis 如何做内存优化？<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a class="route-link nav-link vp-sidebar-link vp-heading" href="/%E4%B8%AD%E9%97%B4%E4%BB%B6/redis/%E9%9D%A2%E8%AF%95%E9%A2%98.html#redis-回收进程如何工作的" aria-label="Redis 回收进程如何工作的？"><!---->Redis 回收进程如何工作的？<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a class="route-link nav-link vp-sidebar-link vp-heading" href="/%E4%B8%AD%E9%97%B4%E4%BB%B6/redis/%E9%9D%A2%E8%AF%95%E9%A2%98.html#都有哪些办法可以降低-redis-的内存使用情况呢" aria-label="都有哪些办法可以降低 Redis 的内存使用情况呢？"><!---->都有哪些办法可以降低 Redis 的内存使用情况呢？<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a class="route-link nav-link vp-sidebar-link vp-heading" href="/%E4%B8%AD%E9%97%B4%E4%BB%B6/redis/%E9%9D%A2%E8%AF%95%E9%A2%98.html#redis-的内存用完了会发生什么-1" aria-label="Redis 的内存用完了会发生什么？"><!---->Redis 的内存用完了会发生什么？<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a class="route-link nav-link vp-sidebar-link vp-heading" href="/%E4%B8%AD%E9%97%B4%E4%BB%B6/redis/%E9%9D%A2%E8%AF%95%E9%A2%98.html#一个-redis-实例最多能存放多少的-keys-list、set、-sorted-set-他们最多能存放多少元素" aria-label="一个 Redis 实例最多能存放多少的 keys？ List、Set、 Sorted Set 他们最多能存放多少元素？"><!---->一个 Redis 实例最多能存放多少的 keys？ List、Set、 Sorted Set 他们最多能存放多少元素？<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a class="route-link nav-link vp-sidebar-link vp-heading" href="/%E4%B8%AD%E9%97%B4%E4%BB%B6/redis/%E9%9D%A2%E8%AF%95%E9%A2%98.html#mysql-里有2000w-数据-redis-中只存20w-的数据-如何保证-redis-中的数据都是热点数据-redis-内存数据集大小上升到一定大小的时候-就会施行数据淘汰策略。" aria-label="MySQL 里有2000w 数据，Redis 中只存20w 的数据，如何保证 redis 中的数据都是热点数据？Redis 内存数据集大小上升到一定大小的时候，就会施行数据淘汰策略。"><!---->MySQL 里有2000w 数据，Redis 中只存20w 的数据，如何保证 redis 中的数据都是热点数据？Redis 内存数据集大小上升到一定大小的时候，就会施行数据淘汰策略。<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a class="route-link nav-link vp-sidebar-link vp-heading" href="/%E4%B8%AD%E9%97%B4%E4%BB%B6/redis/%E9%9D%A2%E8%AF%95%E9%A2%98.html#redis-最适合的场景" aria-label="Redis 最适合的场景？"><!---->Redis 最适合的场景？<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a class="route-link nav-link vp-sidebar-link vp-heading" href="/%E4%B8%AD%E9%97%B4%E4%BB%B6/redis/%E9%9D%A2%E8%AF%95%E9%A2%98.html#假如-redis-里面有1-亿个-key-其中有10w-个-key-是以某个固定的已知的前缀开头的-如果将它们全部找出来" aria-label="假如 Redis 里面有1 亿个 key，其中有10w 个 key 是以某个固定的已知的前缀开头的，如果将它们全部找出来？"><!---->假如 Redis 里面有1 亿个 key，其中有10w 个 key 是以某个固定的已知的前缀开头的，如果将它们全部找出来？<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a class="route-link nav-link vp-sidebar-link vp-heading" href="/%E4%B8%AD%E9%97%B4%E4%BB%B6/redis/%E9%9D%A2%E8%AF%95%E9%A2%98.html#如果有大量的-key-需要设置同一时间过期-一般需要注意什么" aria-label="如果有大量的 key 需要设置同一时间过期，一般需要注意什么？"><!---->如果有大量的 key 需要设置同一时间过期，一般需要注意什么？<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a class="route-link nav-link vp-sidebar-link vp-heading" href="/%E4%B8%AD%E9%97%B4%E4%BB%B6/redis/%E9%9D%A2%E8%AF%95%E9%A2%98.html#使用过-redis-做异步队列么-你是怎么用的" aria-label="使用过 Redis 做异步队列么，你是怎么用的？"><!---->使用过 Redis 做异步队列么，你是怎么用的？<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a class="route-link nav-link vp-sidebar-link vp-heading" href="/%E4%B8%AD%E9%97%B4%E4%BB%B6/redis/%E9%9D%A2%E8%AF%95%E9%A2%98.html#使用过-redis-分布式锁么-它是什么回事" aria-label="使用过 Redis 分布式锁么，它是什么回事"><!---->使用过 Redis 分布式锁么，它是什么回事<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a class="route-link nav-link vp-sidebar-link vp-heading" href="/%E4%B8%AD%E9%97%B4%E4%BB%B6/redis/%E9%9D%A2%E8%AF%95%E9%A2%98.html#假如-redis-里面有-1-亿个-key-其中有-10w-个-key-是以某个固定的已知的前缀开头的-如果将它们全部找出来" aria-label="假如 Redis 里面有 1 亿个 key，其中有 10w 个 key 是以某个固定的已知的前缀开头的，如果将它们全部找出来？"><!---->假如 Redis 里面有 1 亿个 key，其中有 10w 个 key 是以某个固定的已知的前缀开头的，如果将它们全部找出来？<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a class="route-link nav-link vp-sidebar-link vp-heading" href="/%E4%B8%AD%E9%97%B4%E4%BB%B6/redis/%E9%9D%A2%E8%AF%95%E9%A2%98.html#memcached-与-redis-的区别" aria-label="Memcached  与 Redis  的区别？"><!---->Memcached  与 Redis  的区别？<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a class="route-link nav-link vp-sidebar-link vp-heading" href="/%E4%B8%AD%E9%97%B4%E4%BB%B6/redis/%E9%9D%A2%E8%AF%95%E9%A2%98.html#redis-常见性能问题和解决方案-1" aria-label="Redis  常见性能问题和解决方案："><!---->Redis  常见性能问题和解决方案：<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a class="route-link nav-link vp-sidebar-link vp-heading" href="/%E4%B8%AD%E9%97%B4%E4%BB%B6/redis/%E9%9D%A2%E8%AF%95%E9%A2%98.html#缓存如何实现高并发" aria-label="缓存如何实现高并发？"><!---->缓存如何实现高并发？<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a class="route-link nav-link vp-sidebar-link vp-heading" href="/%E4%B8%AD%E9%97%B4%E4%BB%B6/redis/%E9%9D%A2%E8%AF%95%E9%A2%98.html#redis-和-memcached-的区别" aria-label="Redis 和 Memcached 的区别"><!---->Redis 和 Memcached 的区别<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a class="route-link nav-link vp-sidebar-link vp-heading" href="/%E4%B8%AD%E9%97%B4%E4%BB%B6/redis/%E9%9D%A2%E8%AF%95%E9%A2%98.html#用缓存可能出现的问题" aria-label="用缓存可能出现的问题"><!---->用缓存可能出现的问题<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a class="route-link nav-link vp-sidebar-link vp-heading" href="/%E4%B8%AD%E9%97%B4%E4%BB%B6/redis/%E9%9D%A2%E8%AF%95%E9%A2%98.html#当查询缓存报错-怎么提高可用性" aria-label="当查询缓存报错，怎么提高可用性？"><!---->当查询缓存报错，怎么提高可用性？<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a class="route-link nav-link vp-sidebar-link vp-heading" href="/%E4%B8%AD%E9%97%B4%E4%BB%B6/redis/%E9%9D%A2%E8%AF%95%E9%A2%98.html#如果避免缓存-穿透-的问题" aria-label="如果避免缓存”穿透”的问题？"><!---->如果避免缓存”穿透”的问题？<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a class="route-link nav-link vp-sidebar-link vp-heading" href="/%E4%B8%AD%E9%97%B4%E4%BB%B6/redis/%E9%9D%A2%E8%AF%95%E9%A2%98.html#如何避免缓存-雪崩-的问题" aria-label="如何避免缓存“雪崩”的问题？"><!---->如何避免缓存“雪崩”的问题？<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a class="route-link nav-link vp-sidebar-link vp-heading" href="/%E4%B8%AD%E9%97%B4%E4%BB%B6/redis/%E9%9D%A2%E8%AF%95%E9%A2%98.html#如果避免缓存-击穿-的问题" aria-label="如果避免缓存“击穿”的问题？"><!---->如果避免缓存“击穿”的问题？<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a class="route-link nav-link vp-sidebar-link vp-heading" href="/%E4%B8%AD%E9%97%B4%E4%BB%B6/redis/%E9%9D%A2%E8%AF%95%E9%A2%98.html#什么是缓存预热-如何实现缓存预热" aria-label="什么是缓存预热？如何实现缓存预热？"><!---->什么是缓存预热？如何实现缓存预热？<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a class="route-link nav-link vp-sidebar-link vp-heading" href="/%E4%B8%AD%E9%97%B4%E4%BB%B6/redis/%E9%9D%A2%E8%AF%95%E9%A2%98.html#缓存数据的淘汰策略有哪些" aria-label="缓存数据的淘汰策略有哪些？"><!---->缓存数据的淘汰策略有哪些？<!----></a><ul class="vp-sidebar-sub-headers"></ul></li></ul><!--]--></li></ul></section></li><li><section class="vp-sidebar-group"><button class="vp-sidebar-heading clickable" type="button"><!----><span class="vp-sidebar-title">Rocketmq</span><span class="vp-arrow end"></span></button><!----></section></li></ul></section></li></ul><!--[--><!----><!--]--></aside><!--[--><main id="main-content" class="vp-page"><!--[--><!--[--><!----><!--]--><!----><nav class="vp-breadcrumb disable"></nav><div class="vp-page-title"><h1><!---->Redis面试题</h1><div class="page-info"><span class="page-author-info" aria-label="作者🖊" data-balloon-pos="down"><svg xmlns="http://www.w3.org/2000/svg" class="icon author-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="author icon"><path d="M649.6 633.6c86.4-48 147.2-144 147.2-249.6 0-160-128-288-288-288s-288 128-288 288c0 108.8 57.6 201.6 147.2 249.6-121.6 48-214.4 153.6-240 288-3.2 9.6 0 19.2 6.4 25.6 3.2 9.6 12.8 12.8 22.4 12.8h704c9.6 0 19.2-3.2 25.6-12.8 6.4-6.4 9.6-16 6.4-25.6-25.6-134.4-121.6-240-243.2-288z"></path></svg><span><a class="page-author-item" href="https://xiaobaidebug.top/" target="_blank" rel="noopener noreferrer">小白debug</a></span><span property="author" content="小白debug"></span></span><!----><span class="page-date-info" aria-label="写作日期📅" data-balloon-pos="down"><svg xmlns="http://www.w3.org/2000/svg" class="icon calendar-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="calendar icon"><path d="M716.4 110.137c0-18.753-14.72-33.473-33.472-33.473-18.753 0-33.473 14.72-33.473 33.473v33.473h66.993v-33.473zm-334.87 0c0-18.753-14.72-33.473-33.473-33.473s-33.52 14.72-33.52 33.473v33.473h66.993v-33.473zm468.81 33.52H716.4v100.465c0 18.753-14.72 33.473-33.472 33.473a33.145 33.145 0 01-33.473-33.473V143.657H381.53v100.465c0 18.753-14.72 33.473-33.473 33.473a33.145 33.145 0 01-33.473-33.473V143.657H180.6A134.314 134.314 0 0046.66 277.595v535.756A134.314 134.314 0 00180.6 947.289h669.74a134.36 134.36 0 00133.94-133.938V277.595a134.314 134.314 0 00-133.94-133.938zm33.473 267.877H147.126a33.145 33.145 0 01-33.473-33.473c0-18.752 14.72-33.473 33.473-33.473h736.687c18.752 0 33.472 14.72 33.472 33.473a33.145 33.145 0 01-33.472 33.473z"></path></svg><span><!----></span><meta property="datePublished" content="2024-02-13T08:18:41.000Z"></span><!----><span class="page-reading-time-info" aria-label="阅读时间⌛" data-balloon-pos="down"><svg xmlns="http://www.w3.org/2000/svg" class="icon timer-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="timer icon"><path d="M799.387 122.15c4.402-2.978 7.38-7.897 7.38-13.463v-1.165c0-8.933-7.38-16.312-16.312-16.312H256.33c-8.933 0-16.311 7.38-16.311 16.312v1.165c0 5.825 2.977 10.874 7.637 13.592 4.143 194.44 97.22 354.963 220.201 392.763-122.204 37.542-214.893 196.511-220.2 389.397-4.661 5.049-7.638 11.651-7.638 19.03v5.825h566.49v-5.825c0-7.379-2.849-13.981-7.509-18.9-5.049-193.016-97.867-351.985-220.2-389.527 123.24-37.67 216.446-198.453 220.588-392.892zM531.16 450.445v352.632c117.674 1.553 211.787 40.778 211.787 88.676H304.097c0-48.286 95.149-87.382 213.728-88.676V450.445c-93.077-3.107-167.901-81.297-167.901-177.093 0-8.803 6.99-15.793 15.793-15.793 8.803 0 15.794 6.99 15.794 15.793 0 80.261 63.69 145.635 142.01 145.635s142.011-65.374 142.011-145.635c0-8.803 6.99-15.793 15.794-15.793s15.793 6.99 15.793 15.793c0 95.019-73.789 172.82-165.96 177.093z"></path></svg><span>大约 30 分钟</span><meta property="timeRequired" content="PT30M"></span><!----><!----></div><hr></div><div class="toc-place-holder"><aside id="toc"><!--[--><!----><!--]--><div class="toc-header">此页内容<button type="button" class="print-button" title="打印"><svg xmlns="http://www.w3.org/2000/svg" class="icon print-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="print icon"><path d="M819.2 364.8h-44.8V128c0-17.067-14.933-32-32-32H281.6c-17.067 0-32 14.933-32 32v236.8h-44.8C145.067 364.8 96 413.867 96 473.6v192c0 59.733 49.067 108.8 108.8 108.8h44.8V896c0 17.067 14.933 32 32 32h460.8c17.067 0 32-14.933 32-32V774.4h44.8c59.733 0 108.8-49.067 108.8-108.8v-192c0-59.733-49.067-108.8-108.8-108.8zM313.6 160h396.8v204.8H313.6V160zm396.8 704H313.6V620.8h396.8V864zM864 665.6c0 25.6-19.2 44.8-44.8 44.8h-44.8V588.8c0-17.067-14.933-32-32-32H281.6c-17.067 0-32 14.933-32 32v121.6h-44.8c-25.6 0-44.8-19.2-44.8-44.8v-192c0-25.6 19.2-44.8 44.8-44.8h614.4c25.6 0 44.8 19.2 44.8 44.8v192z"></path></svg></button></div><div class="toc-wrapper"><ul class="toc-list"><!--[--><li class="toc-item"><a class="route-link toc-link level2" href="/#什么是-redis">什么是 Redis?</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="route-link toc-link level2" href="/#redis-的数据类型">Redis 的数据类型？</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="route-link toc-link level2" href="/#使用-redis-有哪些好处">使用 Redis 有哪些好处？</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="route-link toc-link level2" href="/#redis-相比-memcached-有哪些优势">Redis 相比 Memcached 有哪些优势？</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="route-link toc-link level2" href="/#memcache-与-redis-的区别都有哪些">Memcache 与 Redis 的区别都有哪些？</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="route-link toc-link level2" href="/#redis-是单进程单线程的">Redis 是单进程单线程的？</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="route-link toc-link level2" href="/#一个字符串类型的值能存储最大容量是多少">一个字符串类型的值能存储最大容量是多少？</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="route-link toc-link level2" href="/#redis-集群最大节点个数是多少">Redis 集群最大节点个数是多少？</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="route-link toc-link level2" href="/#reids-的特点">Reids 的特点</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="route-link toc-link level2" href="/#使用-redis-有哪些好处-1">使用 Redis 有哪些好处？</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="route-link toc-link level2" href="/#为什么-edis-需要把所有数据放到内存中">为什么 edis 需要把所有数据放到内存中？</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="route-link toc-link level2" href="/#redis-的内存用完了会发生什么">Redis 的内存用完了会发生什么？</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="route-link toc-link level2" href="/#redis-的回收策略-淘汰策略">Redis  的回收策略（淘汰策略）</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="route-link toc-link level2" href="/#redis-的持久化机制是什么-各自的优缺点">Redis 的持久化机制是什么？各自的优缺点？</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="route-link toc-link level2" href="/#redis-常见性能问题和解决方案">Redis 常见性能问题和解决方案：</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="route-link toc-link level2" href="/#redis-过期键的删除策略">Redis 过期键的删除策略？</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="route-link toc-link level2" href="/#redis-的回收策略-淘汰策略-1">Redis 的回收策略（淘汰策略）?</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="route-link toc-link level2" href="/#为什么-redis-需要把所有数据放到内存中">为什么 Redis 需要把所有数据放到内存中？</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="route-link toc-link level2" href="/#redis-的同步机制了解么">Redis 的同步机制了解么？</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="route-link toc-link level2" href="/#pipeline-有什么好处-为什么要用-pipeline">Pipeline 有什么好处，为什么要用 Pipeline？</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="route-link toc-link level2" href="/#是否使用过-redis-集群-集群的原理是什么">是否使用过 Redis 集群，集群的原理是什么？</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="route-link toc-link level2" href="/#redis-集群方案什么情况下会导致整个集群不可用">Redis 集群方案什么情况下会导致整个集群不可用？</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="route-link toc-link level2" href="/#redis-支持的-java-客户端都有哪些-官方推荐用哪个">Redis 支持的 Java 客户端都有哪些？官方推荐用哪个？</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="route-link toc-link level2" href="/#jedis-与-redisson-对比有什么优缺点">Jedis 与 Redisson 对比有什么优缺点？</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="route-link toc-link level2" href="/#redis-如何设置密码及验证密码">Redis 如何设置密码及验证密码？</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="route-link toc-link level2" href="/#说说-redis-哈希槽的概念">说说 Redis 哈希槽的概念？</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="route-link toc-link level2" href="/#redis-集群的主从复制模型是怎样的">Redis 集群的主从复制模型是怎样的？</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="route-link toc-link level2" href="/#redis-集群会有写操作丢失吗-为什么">Redis 集群会有写操作丢失吗？为什么？</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="route-link toc-link level2" href="/#redis-集群之间是如何复制的">Redis 集群之间是如何复制的？</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="route-link toc-link level2" href="/#redis-集群最大节点个数是多少-1">Redis 集群最大节点个数是多少？</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="route-link toc-link level2" href="/#redis-集群如何选择数据库">Redis 集群如何选择数据库？</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="route-link toc-link level2" href="/#怎么测试-redis-的连通性">怎么测试 Redis 的连通性</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="route-link toc-link level2" href="/#怎么理解-redis-事务">怎么理解 Redis 事务？</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="route-link toc-link level2" href="/#redis-事务相关的命令有哪几个">Redis 事务相关的命令有哪几个？</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="route-link toc-link level2" href="/#redis-key-的过期时间和永久有效分别怎么设置">Redis key 的过期时间和永久有效分别怎么设置？</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="route-link toc-link level2" href="/#redis-如何做内存优化">Redis 如何做内存优化？</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="route-link toc-link level2" href="/#redis-回收进程如何工作的">Redis 回收进程如何工作的？</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="route-link toc-link level2" href="/#都有哪些办法可以降低-redis-的内存使用情况呢">都有哪些办法可以降低 Redis 的内存使用情况呢？</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="route-link toc-link level2" href="/#redis-的内存用完了会发生什么-1">Redis 的内存用完了会发生什么？</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="route-link toc-link level2" href="/#一个-redis-实例最多能存放多少的-keys-list、set、-sorted-set-他们最多能存放多少元素">一个 Redis 实例最多能存放多少的 keys？ List、Set、 Sorted Set 他们最多能存放多少元素？</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="route-link toc-link level2" href="/#mysql-里有2000w-数据-redis-中只存20w-的数据-如何保证-redis-中的数据都是热点数据-redis-内存数据集大小上升到一定大小的时候-就会施行数据淘汰策略。">MySQL 里有2000w 数据，Redis 中只存20w 的数据，如何保证 redis 中的数据都是热点数据？Redis 内存数据集大小上升到一定大小的时候，就会施行数据淘汰策略。</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="route-link toc-link level2" href="/#redis-最适合的场景">Redis 最适合的场景？</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="route-link toc-link level2" href="/#假如-redis-里面有1-亿个-key-其中有10w-个-key-是以某个固定的已知的前缀开头的-如果将它们全部找出来">假如 Redis 里面有1 亿个 key，其中有10w 个 key 是以某个固定的已知的前缀开头的，如果将它们全部找出来？</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="route-link toc-link level2" href="/#如果有大量的-key-需要设置同一时间过期-一般需要注意什么">如果有大量的 key 需要设置同一时间过期，一般需要注意什么？</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="route-link toc-link level2" href="/#使用过-redis-做异步队列么-你是怎么用的">使用过 Redis 做异步队列么，你是怎么用的？</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="route-link toc-link level2" href="/#使用过-redis-分布式锁么-它是什么回事">使用过 Redis 分布式锁么，它是什么回事</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="route-link toc-link level2" href="/#假如-redis-里面有-1-亿个-key-其中有-10w-个-key-是以某个固定的已知的前缀开头的-如果将它们全部找出来">假如 Redis 里面有 1 亿个 key，其中有 10w 个 key 是以某个固定的已知的前缀开头的，如果将它们全部找出来？</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="route-link toc-link level2" href="/#memcached-与-redis-的区别">Memcached  与 Redis  的区别？</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="route-link toc-link level2" href="/#redis-常见性能问题和解决方案-1">Redis  常见性能问题和解决方案：</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="route-link toc-link level2" href="/#缓存如何实现高并发">缓存如何实现高并发？</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="route-link toc-link level2" href="/#redis-和-memcached-的区别">Redis 和 Memcached 的区别</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="route-link toc-link level2" href="/#用缓存可能出现的问题">用缓存可能出现的问题</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="route-link toc-link level2" href="/#当查询缓存报错-怎么提高可用性">当查询缓存报错，怎么提高可用性？</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="route-link toc-link level2" href="/#如果避免缓存-穿透-的问题">如果避免缓存”穿透”的问题？</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="route-link toc-link level2" href="/#如何避免缓存-雪崩-的问题">如何避免缓存“雪崩”的问题？</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="route-link toc-link level2" href="/#如果避免缓存-击穿-的问题">如果避免缓存“击穿”的问题？</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="route-link toc-link level2" href="/#什么是缓存预热-如何实现缓存预热">什么是缓存预热？如何实现缓存预热？</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="route-link toc-link level2" href="/#缓存数据的淘汰策略有哪些">缓存数据的淘汰策略有哪些？</a></li><!----><!--]--></ul><div class="toc-marker" style="top:-1.7rem;"></div></div><!--[--><!----><!--]--></aside></div><!--[--><!----><!--]--><div class="theme-hope-content"><h1 id="redis面试题" tabindex="-1"><a class="header-anchor" href="#redis面试题"><span><strong>Redis面试题</strong></span></a></h1><h2 id="什么是-redis" tabindex="-1"><a class="header-anchor" href="#什么是-redis"><span>什么是 Redis?</span></a></h2><p>Redis 是完全开源免费的，遵守 BSD 协议，是一个高性能的 key-value 数据库。</p><p>Redis 与其他 key - value 缓存产品有以下三个特点：</p><ul><li>Redis 支持数据的持久化，可以将内存中的数据保存在磁盘中，重启的时候可以再次加载进行使用。</li><li>Redis 不仅仅支持简单的 key-value 类型的数据，同时还提供 list， set，zset，hash 等数据结构的存储。</li><li>Redis 支持数据的备份，即 master-slave 模式的数据备份。</li></ul><p>Redis 优势：</p><ul><li>性能极高– Redis 能读的速度是110000 次/s,写的速度是81000 次/s 。</li><li>丰富的数据类型– Redis 支持二进制案例的 Strings, Lists, Hashes, Sets 及 Ordered Sets 数据类型操作。</li><li>原子– Redis 的所有操作都是原子性的，意思就是要么成功执行要么失败完全不执行。单个操作是原子性的。多个操作也支持事务，即原子性，通过 MULTI 和 EXEC 指令包起来。</li><li>丰富的特性– Redis 还支持 publish/subscribe,通知, key 过期等等特性。</li></ul><p><strong>Redis 与其他 key-value 存储有什么不同？</strong></p><ul><li>Redis 有着更为复杂的数据结构并且提供对他们的原子性操作，这是一个不同于其他数据库的进化路径。Redis 的数据类型都是基于基本数据结构的同时对程序员透明，无需进行额外的抽象。</li><li>Redis 运行在内存中但是可以持久化到磁盘，所以在对不同数据集进行高速读写时需要权衡内存，因为数据量不能大于硬件内存。在内存数据库方面的另一个优点是，相比在磁盘上相同的复杂的数据结构，在内存中操作起来非常简单，这样 Redis 可以做很多内部复杂性很强的事情。同时，在磁盘格式方面他们是紧凑的以追加的方式产生的，因为他们并不需要进行随机访问。</li></ul><h2 id="redis-的数据类型" tabindex="-1"><a class="header-anchor" href="#redis-的数据类型"><span>Redis 的数据类型？</span></a></h2><p>Redis 支持五种数据类型：string（字符串），hash（哈希），list（列表），set（集合）及 zsetsorted set：有序集合)。我们实际项目中比较常用的是 string，hash 如果你是 Redis 中高级用户，还</p><p>需要加上下面几种数据结构 HyperLogLog、Geo、Pub/Sub。</p><p>如果你说还玩过 Redis Module，像 BloomFilter，RedisSearch，Redis-ML，面试官得眼睛就开始发亮了。</p><h2 id="使用-redis-有哪些好处" tabindex="-1"><a class="header-anchor" href="#使用-redis-有哪些好处"><span>使用 Redis 有哪些好处？</span></a></h2><ul><li>速度快，因为数据存在内存中，类似于 HashMap，HashMap 的优势就是查找和操作的时间复杂度都是 O1)</li><li>支持丰富数据类型，支持 string，list，set，Zset，hash 等</li><li>支持事务，操作都是原子性，所谓的原子性就是对数据的更改要么全部执行，要么全部不执行</li><li>丰富的特性：可用于缓存，消息，按 key 设置过期时间，过期后将会自动删除</li></ul><h2 id="redis-相比-memcached-有哪些优势" tabindex="-1"><a class="header-anchor" href="#redis-相比-memcached-有哪些优势"><span>Redis 相比 Memcached 有哪些优势？</span></a></h2><ul><li>Memcached 所有的值均是简单的字符串，redis 作为其替代者，支持更为丰富的数据类</li><li>Redis 的速度比 Memcached 快很</li><li>Redis 可以持久化其数据</li></ul><h2 id="memcache-与-redis-的区别都有哪些" tabindex="-1"><a class="header-anchor" href="#memcache-与-redis-的区别都有哪些"><span>Memcache 与 Redis 的区别都有哪些？</span></a></h2><ul><li>存储方式 Memecache 把数据全部存在内存之中，断电后会挂掉，数据不能超过内存大小。 Redis 有部份存在硬盘上，这样能保证数据的持久性。</li><li>数据支持类型 Memcache 对数据类型支持相对简单。 Redis 有复杂的数据类型。</li><li>使用底层模型不同它们之间底层实现方式以及与客户端之间通信的应用协议不一样。 Redis 直接自己构建了 VM 机制，因为一般的系统调用系统函数的话，会浪费一定的时间去移动和请求。</li></ul><h2 id="redis-是单进程单线程的" tabindex="-1"><a class="header-anchor" href="#redis-是单进程单线程的"><span>Redis 是单进程单线程的？</span></a></h2><p>Redis 是单进程单线程的，redis 利用队列技术将并发访问变为串行访问，消除了传统数据库串行控制的开销。</p><h2 id="一个字符串类型的值能存储最大容量是多少" tabindex="-1"><a class="header-anchor" href="#一个字符串类型的值能存储最大容量是多少"><span>一个字符串类型的值能存储最大容量是多少？</span></a></h2><p>答：512M</p><h2 id="redis-集群最大节点个数是多少" tabindex="-1"><a class="header-anchor" href="#redis-集群最大节点个数是多少"><span>Redis 集群最大节点个数是多少？</span></a></h2><p>16384 个。</p><h2 id="reids-的特点" tabindex="-1"><a class="header-anchor" href="#reids-的特点"><span>Reids 的特点</span></a></h2><p>Redis 本质上是一个 Key-Value 类型的内存数据库，很像 数据库统统加载在内存当中进行操作，定期通过异步操作把数据库数据 硬盘上进行保存。</p><p>Memcached，整个</p><p>flush 到</p><p>因为是纯内存操作，Redis 的性能非常出色，每秒可以处理超过 10 万次读写操 作，是已知性能最快的 Key-Value DB。</p><p>Redis 的出色之处不仅仅是性能，Redis 最大的魅力是支持保存多种数据结构， 此外单个 value 的最大限制是 1GB，不像 Memcached 只能保存 1MB 的数据， 因此 Redis 可以用来实现很多有用的功能。</p><p>比方说用他的 List 来做 FIFO 双向链表，实现一个轻量级的高性 能消息队列服 务，用他的 Set 可以做高性能的 tag 系统等等。另外 Redis 也可以对存入的 Key- Value 设置 expire 时间，因此也可以被当作一 个功能加强版的 Memcached 来</p><p>用。</p><p>Redis 的主要缺点是数据库容量受到物理内存的限制，不能用作海量数据的高性 能读写，因此 Redis 适合的场景主要局限在较小数据量的高性能操作和运算上。</p><h2 id="使用-redis-有哪些好处-1" tabindex="-1"><a class="header-anchor" href="#使用-redis-有哪些好处-1"><span>使用 Redis 有哪些好处？</span></a></h2><ul><li>速度快，因为数据存在内存中，类似于 HashMap，HashMap 的优势就是</li></ul><p>查找和操作的时间复杂度都是 O(1)。</p><ul><li><p>支持丰富数据类型，支持 string，list，set，sorted set，hash。</p></li><li><p>支持事务，操作都是原子性，所谓的原子性就是对数据的更改要么全部执行， 要么全部不执行。</p></li><li><p>丰富的特性：可用于缓存，消息，按 key 设置过期时间，过期后将会自动删 除。</p></li></ul><h2 id="为什么-edis-需要把所有数据放到内存中" tabindex="-1"><a class="header-anchor" href="#为什么-edis-需要把所有数据放到内存中"><span>为什么 edis 需要把所有数据放到内存中？</span></a></h2><p>Redis 为了达到最快的读写速度将数据都读到内存中，并通过异步的方式将数据 写入磁盘。所以 Redis 具有快速和数据持久化的特征。如果不将数据放在内存 中，磁盘 I/O 速度为严重影响 Redis 的性能。在内存越来越便宜的今天，Redis 将会越来越受欢迎。如果设置了最大使用的内存，则数据已有记录数达到内存限 值后不能继续插入新值。</p><h2 id="redis-的内存用完了会发生什么" tabindex="-1"><a class="header-anchor" href="#redis-的内存用完了会发生什么"><span>Redis 的内存用完了会发生什么？</span></a></h2><p>如果达到设置的上限， 返回。）或者你可以将 限时会冲刷掉旧的内容。</p><p>Redis 的写命令会返回错误信息（但是读命令还可以正常 Redis 当缓存来使用配置淘汰机制，当 Redis 达到内存上</p><h2 id="redis-的回收策略-淘汰策略" tabindex="-1"><a class="header-anchor" href="#redis-的回收策略-淘汰策略"><span>Redis 的回收策略（淘汰策略）</span></a></h2><p>volatile-lru：从已设置过期时间的数据集（ server.db[i].expires）中挑选最近 最少使用的数据淘汰。</p><p>volatile-ttl： 从已设置过期时间的数据集（ server.db[i].expires） 中挑选将要 过期的数据淘汰。</p><p>volatile-random： 从已设置过期时间的数据集（ server.db[i].expires） 中任 意选择数据淘汰。</p><p>allkeys-lru： 从数据集（ server.db[i].dict） 中挑选最近最少使用的数据淘汰。 allkeys-random： 从数据集（ server.db[i].dict） 中任意选择数据淘汰。 no-enviction（ 驱逐） ： 禁止驱逐数据。</p><p>注意这里的 6 种机制，volatile 和 allkeys 规定了是对已设置过期时间的数据 集淘汰数据还是从全部数据集淘汰数据， 后面的 lru、tt- 以及 random 是三 种不同的淘汰策略， 再加上一种 no-enviction 永不回收的策略。 使用策略规则：</p><p>如果数据呈现幂律分布，也就是一部分数据访问频率高，一部分数据访问频 率 低， 则使用 allkeys-lru。</p><p>如果数据呈现平等分布， 也就是所有的数据访问频率都相同， 则使用 allkeys-random。</p><h2 id="redis-的持久化机制是什么-各自的优缺点" tabindex="-1"><a class="header-anchor" href="#redis-的持久化机制是什么-各自的优缺点"><span>Redis 的持久化机制是什么？各自的优缺点？</span></a></h2><p>Redis 提供两种持久化机制 RDB 和 AOF 机制： RDBRedis DataBase)持久化方式：</p><p>是指用数据集快照的方式半持久化模式)记录 redis 数据库的所有键值对,在某个时间点将数据写入一个临时文件，持久化结束后，用这个临时文件替换上次持久化的文件，达到数据恢复。</p><p>优点：</p><ul><li>只有一个文件 dump.rdb，方便持久化。</li><li>容灾性好，一个文件可以保存到安全的磁盘。</li><li>性能最大化，fork 子进程来完成写操作，让主进程继续处理命令，所以</li></ul><p>是 IO 最大化。使用单独子进程来进行持久化，主进程不会进行任何 IO 操作，保证了 redis 的高性能)</p><ul><li>相对于数据集大时，比 AOF 的启动效率更高。</li></ul><p>缺点：</p><p>数据安全性低。RDB 是间隔一段时间进行持久化，如果持久化之间 redis 发生故障，会发生数据丢失。所以这种方式更适合数据要求不严谨的时候。</p><p><strong>AOFAppend-only file)持久化方式：</strong></p><p>是指所有的命令行记录以 redis 命令请求协议的格式完全持久化存储)保存为 aof 文件。</p><p>优点：</p><ul><li>数据安全，aof 持久化可以配置 appendfsync 属性，有 always，每进行一次命令操作就记录到 aof 文件中一次。</li><li>通过 append 模式写文件，即使中途服务器宕机，可以通过 redis- check-aof 工具解决数据一致性问题。</li><li>AOF 机制的 rewrite 模式。AOF 文件没被 rewrite 之前（文件过大时会对命令进行合并重写），可以删除其中的某些命令（比如误操作的 flushall）)</li></ul><p>缺点：</p><ul><li>AOF 文件比 RDB 文件大，且恢复速度慢。</li><li>数据集大的时候，比 rdb 启动效率低。</li></ul><h2 id="redis-常见性能问题和解决方案" tabindex="-1"><a class="header-anchor" href="#redis-常见性能问题和解决方案"><span>Redis 常见性能问题和解决方案：</span></a></h2><ul><li>1）Master 最好不要写内存快照，如果 Master 写内存快照，save 命令调度 rdbSave 函数，会阻塞主线程的工作，当快照比较大时对性能影响是非常大的，会间断性暂停服务</li><li>2）如果数据比较重要，某个 Slave 开启 AOF 备份数据，策略设置为每秒同步一</li><li>3）为了主从复制的速度和连接的稳定性，Master 和 Slave 最好在同一个局域网</li><li>4）尽量避免在压力很大的主库上增加从</li><li>5）主从复制不要用图状结构，用单向链表结构更为稳定，即：Master &lt;- Slave1&lt;- Slave2 &lt;- Slave3…这样的结构方便解决单点故障问题，实现 Slave 对 Master 的替换。如果 Master 挂了，可以立刻启用 Slave1 做 Master，其他不变。</li></ul><h2 id="redis-过期键的删除策略" tabindex="-1"><a class="header-anchor" href="#redis-过期键的删除策略"><span>Redis 过期键的删除策略？</span></a></h2><ul><li>1）定时删除:在设置键的过期时间的同时，创建一个定时器 timer).让定时器在键的过期时间来临时，立即执行对键的删除操作。</li><li>2）惰性删除:放任键过期不管，但是每次从键空间中获取键时，都检查取得的键是否过期，如果过期的话，就删除该键;如果没有过期，就返回该键。</li><li>3）定期删除:每隔一段时间程序就对数据库进行一次检查，删除里面的过期键。至于要删除多少过期键，以及要检查多少个数据库，则由算法决定。</li></ul><h2 id="redis-的回收策略-淘汰策略-1" tabindex="-1"><a class="header-anchor" href="#redis-的回收策略-淘汰策略-1"><span>Redis 的回收策略（淘汰策略）?</span></a></h2><p>volatile-lru：从已设置过期时间的数据集（server.db[i].expires）中挑选最近最少使用的数据淘汰</p><p>volatile-ttl：从已设置过期时间的数据集（server.db[i].expires）中挑选将要过期的数据淘汰</p><p>volatile-random：从已设置过期时间的数据集（server.db[i].expires）中任意选择数据淘汰</p><p>allkeys-lru：从数据集（server.db[i].dict）中挑选最近最少使用的数据淘汰</p><p>allkeys-random：从数据集（server.db[i].dict）中任意选择数据淘汰</p><p>no-enviction（驱逐）：禁止驱逐数据</p><p>注意这里的6 种机制，volatile 和 allkeys 规定了是对已设置过期时间的数据集淘汰数据还是从全部数据集淘汰数据，后面的 lru、ttl 以及 random 是三种不同的淘汰策略，再加上一种 no-enviction 永不回收的策略。</p><p>使用策略规则：</p><ul><li>如果数据呈现幂律分布，也就是一部分数据访问频率高，一部分数据访问</li></ul><p>频率低，则使用 allkeys-lr</p><ul><li>如果数据呈现平等分布，也就是所有的数据访问频率都相同，则使用 allkeys-random</li></ul><h2 id="为什么-redis-需要把所有数据放到内存中" tabindex="-1"><a class="header-anchor" href="#为什么-redis-需要把所有数据放到内存中"><span>为什么 Redis 需要把所有数据放到内存中？</span></a></h2><p>Redis 为了达到最快的读写速度将数据都读到内存中，并通过异步的方式将数据写入磁盘。所以 redis 具有快速和数据持久化的特征。如果不将数据放在内存中，磁盘 I/O 速度为严重影响 redis 的性能。在内存越来越便宜的今天， redis 将会越来越受欢迎。如果设置了最大使用的内存，则数据已有记录数达到内存限值后不能继续插入新值。</p><h2 id="redis-的同步机制了解么" tabindex="-1"><a class="header-anchor" href="#redis-的同步机制了解么"><span>Redis 的同步机制了解么？</span></a></h2><p>Redis 可以使用主从同步，从从同步。第一次同步时，主节点做一次 bgsave，并同时将后续修改操作记录到内存 buffer，待完成后将 rdb 文件全量同步到复制节点，复制节点接受完成后将 rdb 镜像加载到内存。加载完成后，再通知主节点将期间修改的操作记录同步到复制节点进行重放就完成了同步过程。</p><h2 id="pipeline-有什么好处-为什么要用-pipeline" tabindex="-1"><a class="header-anchor" href="#pipeline-有什么好处-为什么要用-pipeline"><span>Pipeline 有什么好处，为什么要用 Pipeline？</span></a></h2><p>可以将多次 IO 往返的时间缩减为一次，前提是 pipeline 执行的指令之间没有因果相关性。使用 redis-benchmark 进行压测的时候可以发现影响 redis 的 QPS 峰值的一个重要因素是 pipeline 批次指令的数目。</p><h2 id="是否使用过-redis-集群-集群的原理是什么" tabindex="-1"><a class="header-anchor" href="#是否使用过-redis-集群-集群的原理是什么"><span>是否使用过 Redis 集群，集群的原理是什么？</span></a></h2><ul><li>Redis Sentinal 着眼于高可用，在 master 宕机时会自动将 slave 提升为 master，继续提供服务。</li><li>Redis Cluster 着眼于扩展性，在单个 redis 内存不足时，使用 Cluster 进行分片存储。</li></ul><h2 id="redis-集群方案什么情况下会导致整个集群不可用" tabindex="-1"><a class="header-anchor" href="#redis-集群方案什么情况下会导致整个集群不可用"><span>Redis 集群方案什么情况下会导致整个集群不可用？</span></a></h2><p>有 A，B，C 三个节点的集群,在没有复制模型的情况下,如果节点 B 失败了，那么整个集群就会以为缺少5501-11000 这个范围的槽而不可用。</p><h2 id="redis-支持的-java-客户端都有哪些-官方推荐用哪个" tabindex="-1"><a class="header-anchor" href="#redis-支持的-java-客户端都有哪些-官方推荐用哪个"><span>Redis 支持的 Java 客户端都有哪些？官方推荐用哪个？</span></a></h2><p>Redisson、Jedis、lettuce 等等，官方推荐使用 Redisson。</p><h2 id="jedis-与-redisson-对比有什么优缺点" tabindex="-1"><a class="header-anchor" href="#jedis-与-redisson-对比有什么优缺点"><span>Jedis 与 Redisson 对比有什么优缺点？</span></a></h2><p>Jedis 是 Redis 的 Java 实现的客户端，其 API 提供了比较全面的 Redis 命令的支持；Redisson 实现了分布式和可扩展的 Java 数据结构，和 Jedis 相比，功能较为简单，不支持字符串操作，不支持排序、事务、管道、分区等 Redis 特性。</p><p>Redisson 的宗旨是促进使用者对 Redis 的关注分离，从而让使用者能够将精力更集中地放在处理业务逻辑上。</p><h2 id="redis-如何设置密码及验证密码" tabindex="-1"><a class="header-anchor" href="#redis-如何设置密码及验证密码"><span>Redis 如何设置密码及验证密码？</span></a></h2><p>设置密码：config set requirepass 123456 授权密码：auth 123456</p><h2 id="说说-redis-哈希槽的概念" tabindex="-1"><a class="header-anchor" href="#说说-redis-哈希槽的概念"><span>说说 Redis 哈希槽的概念？</span></a></h2><p>Redis 集群没有使用一致性 hash,而是引入了哈希槽的概念，Redis 集群有16384 个哈希槽，每个 key 通过 CRC16 校验后对16384 取模来决定放置哪个槽，集群的每个节点负责一部分 hash 槽。</p><h2 id="redis-集群的主从复制模型是怎样的" tabindex="-1"><a class="header-anchor" href="#redis-集群的主从复制模型是怎样的"><span>Redis 集群的主从复制模型是怎样的？</span></a></h2><p>为了使在部分节点失败或者大部分节点无法通信的情况下集群仍然可用，所以集群使用了主从复制模型,每个节点都会有 N-1 个复制品。</p><h2 id="redis-集群会有写操作丢失吗-为什么" tabindex="-1"><a class="header-anchor" href="#redis-集群会有写操作丢失吗-为什么"><span>Redis 集群会有写操作丢失吗？为什么？</span></a></h2><p>Redis 并不能保证数据的强一致性，这意味这在实际中集群在特定的条件下可能会丢失写操作。</p><h2 id="redis-集群之间是如何复制的" tabindex="-1"><a class="header-anchor" href="#redis-集群之间是如何复制的"><span>Redis 集群之间是如何复制的？</span></a></h2><p>异步复制</p><h2 id="redis-集群最大节点个数是多少-1" tabindex="-1"><a class="header-anchor" href="#redis-集群最大节点个数是多少-1"><span>Redis 集群最大节点个数是多少？</span></a></h2><p>16384 个。</p><h2 id="redis-集群如何选择数据库" tabindex="-1"><a class="header-anchor" href="#redis-集群如何选择数据库"><span>Redis 集群如何选择数据库？</span></a></h2><p>Redis 集群目前无法做数据库选择，默认在0 数据库。</p><h2 id="怎么测试-redis-的连通性" tabindex="-1"><a class="header-anchor" href="#怎么测试-redis-的连通性"><span>怎么测试 Redis 的连通性</span></a></h2><p>使用 ping 命令。</p><h2 id="怎么理解-redis-事务" tabindex="-1"><a class="header-anchor" href="#怎么理解-redis-事务"><span>怎么理解 Redis 事务？</span></a></h2><ul><li>1）事务是一个单独的隔离操作：事务中的所有命令都会序列化、按顺序地执行。事务在执行的过程中，不会被其他客户端发送来的命令请求所打断。</li><li>2）事务是一个原子操作：事务中的命令要么全部被执行，要么全部都不执行。</li></ul><h2 id="redis-事务相关的命令有哪几个" tabindex="-1"><a class="header-anchor" href="#redis-事务相关的命令有哪几个"><span>Redis 事务相关的命令有哪几个？</span></a></h2><p>MULTI、 EXEC、 DISCARD、 WATCH</p><h2 id="redis-key-的过期时间和永久有效分别怎么设置" tabindex="-1"><a class="header-anchor" href="#redis-key-的过期时间和永久有效分别怎么设置"><span>Redis key 的过期时间和永久有效分别怎么设置？</span></a></h2><p>EXPIRE 和 PERSIST 命令。</p><h2 id="redis-如何做内存优化" tabindex="-1"><a class="header-anchor" href="#redis-如何做内存优化"><span>Redis 如何做内存优化？</span></a></h2><p>尽可能使用散列表（hashes），散列表（是说散列表里面存储的数少）使用的内存非常小，所以你应该尽可能的将你的数据模型抽象到一个散列表里面。比如你的 web 系统中有一个用户对象，不要为这个用户的名称，姓氏，邮箱，密码设置单独的 key,而是应该把这个用户的所有信息存储到一张散列表里面。</p><h2 id="redis-回收进程如何工作的" tabindex="-1"><a class="header-anchor" href="#redis-回收进程如何工作的"><span>Redis 回收进程如何工作的？</span></a></h2><p>一个客户端运行了新的命令，添加了新的数据。Redi 检查内存使用情况，如果大于 maxmemory 的限制,则根据设定好的策略进行回收。一个新的命令被执行，等等。所以我们不断地穿越内存限制的边界，通过不断达到边界然后不断地回收回到边界以下。如果一个命令的结果导致大量内存被使用（例如很大的集合的交集保存到一个新的键），不用多久内存限制就会被这个内存使用量超越。</p><h2 id="都有哪些办法可以降低-redis-的内存使用情况呢" tabindex="-1"><a class="header-anchor" href="#都有哪些办法可以降低-redis-的内存使用情况呢"><span>都有哪些办法可以降低 Redis 的内存使用情况呢？</span></a></h2><p>如果你使用的是32 位的 Redis 实例，可以好好利用 Hash,list,sorted set,set 等集合类型数据，因为通常情况下很多小的 Key-Value 可以用更紧凑的方式存放到一起。</p><h2 id="redis-的内存用完了会发生什么-1" tabindex="-1"><a class="header-anchor" href="#redis-的内存用完了会发生什么-1"><span>Redis 的内存用完了会发生什么？</span></a></h2><p>如果达到设置的上限，Redis 的写命令会返回错误信息（但是读命令还可以正常返回。）或者你可以将 Redis 当缓存来使用配置淘汰机制，当 Redis 达到内存上限时会冲刷掉旧的内容。</p><h2 id="一个-redis-实例最多能存放多少的-keys-list、set、-sorted-set-他们最多能存放多少元素" tabindex="-1"><a class="header-anchor" href="#一个-redis-实例最多能存放多少的-keys-list、set、-sorted-set-他们最多能存放多少元素"><span>一个 Redis 实例最多能存放多少的 keys？ List、Set、 Sorted Set 他们最多能存放多少元素？</span></a></h2><p>理论上 Redis 可以处理多达232 的 keys，并且在实际中进行了测试，每个实例至少存放了2 亿5 千万的 keys。我们正在测试一些较大的值。任何 list、 set、和 sorted set 都可以放232 个元素。换句话说，Redis 的存储极限是系统中的可用内存值。</p><h2 id="mysql-里有2000w-数据-redis-中只存20w-的数据-如何保证-redis-中的数据都是热点数据-redis-内存数据集大小上升到一定大小的时候-就会施行数据淘汰策略。" tabindex="-1"><a class="header-anchor" href="#mysql-里有2000w-数据-redis-中只存20w-的数据-如何保证-redis-中的数据都是热点数据-redis-内存数据集大小上升到一定大小的时候-就会施行数据淘汰策略。"><span>MySQL 里有2000w 数据，Redis 中只存20w 的数据，如何保证 redis 中的数据都是热点数据？Redis 内存数据集大小上升到一定大小的时候，就会施行数据淘汰策略。</span></a></h2><p><strong>相关知识：Redis 提供6 种数据淘汰策略：</strong></p><p>volatile-lru：从已设置过期时间的数据集（server.db[i].expires）中挑选</p><p>最近最少使用的数据淘汰</p><p>volatile-ttl：从已设置过期时间的数据集（server.db[i].expires）中挑选将要过期的数据淘汰</p><p>volatile-random：从已设置过期时间的数据集（server.db[i].expires）中任意选择数据淘汰</p><p>allkeys-lru：从数据集（server.db[i].dict）中挑选最近最少使用的数据淘汰</p><p>allkeys-random：从数据集（server.db[i].dict）中任意选择数据淘汰 no-enviction（驱逐）：禁止驱逐数据</p><h2 id="redis-最适合的场景" tabindex="-1"><a class="header-anchor" href="#redis-最适合的场景"><span>Redis 最适合的场景？</span></a></h2><p><strong>会话缓存（Session Cache）</strong></p><p>最常用的一种使用 Redis 的情景是会话缓存（session cache）。用 Redis 缓存会话比其他存储（如 Memcached）的优势在于：Redis 提供持久化。当维护一个不是严格要求一致性的缓存时，如果用户的购物车信息全部丢失，大部分人都会不高兴的，现在，他们还会这样吗？幸运的是，随着 Redis 这些年的改进，很容易找到怎么恰当的使用 Redis 来缓存会话的文档。甚至广为人知的商业平台 Magento 也提供 Redis 的插件。</p><p><strong>全页缓存（FPC）</strong></p><p>除基本的会话 token 之外，Redis 还提供很简便的 FPC 平台。回到一致性问题，即使重启了 Redis 实例，因为有磁盘的持久化，用户也不会看到页面加载速度的下降，这是一个极大改进，类似 PHP 本地 FPC。再次以 Magento 为例，Magento 提供一个插件来使用 Redis 作为全页缓存后端。此外，对 WordPress 的用户来说，Pantheon 有一个非常好的插件 wp-redis，这个插件能帮助你以最快速度加载你曾浏览过的页面。</p><p><strong>队列</strong></p><p>Reids 在内存存储引擎领域的一大优点是提供 list 和 set 操作，这使得 Redis 能作为一个很好的消息队列平台来使用。Redis 作为队列使用的操作，就类似于本地程序语言（如 Python）对 list 的 push/pop 操作。如果你快速的在 Google 中搜索“Redis queues”，你马上就能找到大量的开源项目，这些项目的目的就是利用 Redis 创建非常好的后端工具，以满足各种队列需求。例如，Celery 有一个后台就是使用 Redis 作为 broker，你可以从这里去查看。</p><p><strong>排行榜/计数器</strong></p><p>Redis 在内存中对数字进行递增或递减的操作实现的非常好。集合（Set）和有序集合（Sorted Set）也使得我们在执行这些操作的时候变的非常简单，Redis 只是正好提供了这两种数据结构。所以，我们要从排序集合中获取到排名最靠前的10 个用户–我们称之为“user_scores”，我们只需要像下面一样执行即可：当然，这是假定你是根据你用户的分数做递增的排序。如果你想返回用户及用户的分数，你需要这样执行： ZRANGE user_scores 0 10 WITHSCORES Agora Games 就是一个很好的例子，用 Ruby 实现的，它的排行榜就是使用 Redis 来存储数据的，你可以在这里看到。</p><p><strong>发布/订阅</strong></p><p>最后（但肯定不是最不重要的）是 Redis 的发布/订阅功能。发布/订阅的使用场景确实非常多。我已看见人们在社交网络连接中使用，还可作为基于发布/订阅的脚本触发器，甚至用 Redis 的发布/订阅功能来建立聊天系统！</p><h2 id="假如-redis-里面有1-亿个-key-其中有10w-个-key-是以某个固定的已知的前缀开头的-如果将它们全部找出来" tabindex="-1"><a class="header-anchor" href="#假如-redis-里面有1-亿个-key-其中有10w-个-key-是以某个固定的已知的前缀开头的-如果将它们全部找出来"><span>假如 Redis 里面有1 亿个 key，其中有10w 个 key 是以某个固定的已知的前缀开头的，如果将它们全部找出来？</span></a></h2><p>使用 keys 指令可以扫出指定模式的 key 列表。</p><p>对方接着追问：如果这个 redis 正在给线上的业务提供服务，那使用 keys 指令会有什么问题？</p><p>这个时候你要回答 redis 关键的一个特性：redis 的单线程的。keys 指令会导致线程阻塞一段时间，线上服务会停顿，直到指令执行完毕，服务才能恢复。这个时候可以使用 scan 指令，scan 指令可以无阻塞的提取出指定模式的key 列表，但是会有一定的重复概率，在客户端做一次去重就可以了，但是整体所花费的时间会比直接用 keys 指令长。</p><h2 id="如果有大量的-key-需要设置同一时间过期-一般需要注意什么" tabindex="-1"><a class="header-anchor" href="#如果有大量的-key-需要设置同一时间过期-一般需要注意什么"><span>如果有大量的 key 需要设置同一时间过期，一般需要注意什么？</span></a></h2><p>如果大量的 key 过期时间设置的过于集中，到过期的那个时间点，redis 可能会出现短暂的卡顿现象。一般需要在时间上加一个随机值，使得过期时间分散一些。</p><h2 id="使用过-redis-做异步队列么-你是怎么用的" tabindex="-1"><a class="header-anchor" href="#使用过-redis-做异步队列么-你是怎么用的"><span>使用过 Redis 做异步队列么，你是怎么用的？</span></a></h2><p>一般使用 list 结构作为队列，rpush 生产消息，lpop 消费消息。当 lpop 没有消息的时候，要适当 sleep 一会再重试。</p><p>如果对方追问可不可以不用 sleep 呢？</p><p>list 还有个指令叫 blpop，在没有消息的时候，它会阻塞住直到消息到来。</p><p>如果对方追问能不能生产一次消费多次呢？</p><p>使用 pub/sub 主题订阅者模式，可以实现1:N 的消息队列。</p><p>如果对方追问 pub/sub 有什么缺点？在消费者下线的情况下，生产的消息会丢失，得使用专业的消息队列如 RabbitMQ 等。</p><p>如果对方追问 redis 如何实现延时队列？我估计现在你很想把面试官一棒打死如果你手上有一根棒球棍的话，怎么问的这么详细。但是你很克制，然后神态自若的回答道：使用 sortedset，拿时间戳作为 score，消息内容作为 key 调用 zadd 来生产消息，消费者用 zrangebyscore 指令获取 N 秒之前的数据轮询进行处理。到这里，面试官暗地里已经对你竖起了大拇指。但是他不知道的是此刻你却竖起了中指，在椅子背后。</p><h2 id="使用过-redis-分布式锁么-它是什么回事" tabindex="-1"><a class="header-anchor" href="#使用过-redis-分布式锁么-它是什么回事"><span>使用过 Redis 分布式锁么，它是什么回事</span></a></h2><p>先拿 setnx 来争抢锁，抢到之后，再用 expire 给锁加一个过期时间防止锁忘记了释放。</p><p>这时候对方会告诉你说你回答得不错，然后接着问如果在 setnx 之后执行 expire 之前进程意外 crash 或者要重启维护了，那会怎么样？这时候你要给予惊讶的反馈：唉，是喔，这个锁就永远得不到释放了。紧接着你需要抓一抓自己得脑袋，故作思考片刻，好像接下来的结果是你主动思考出来的，然后回答：我记得 set 指令有非常复杂的参数，这个应该是可以同时把 setnx 和 expire 合成一条指令来用的！对方这时会显露笑容，心里开始默念：摁，这小子还不错。</p><h2 id="假如-redis-里面有-1-亿个-key-其中有-10w-个-key-是以某个固定的已知的前缀开头的-如果将它们全部找出来" tabindex="-1"><a class="header-anchor" href="#假如-redis-里面有-1-亿个-key-其中有-10w-个-key-是以某个固定的已知的前缀开头的-如果将它们全部找出来"><span>假如 Redis 里面有 1 亿个 key，其中有 10w 个 key 是以某个固定的已知的前缀开头的，如果将它们全部找出来？</span></a></h2><p>使用 keys 指令可以扫出指定模式的 key 列表。</p><p>对方接着追问：如果这个 Redis 正在给线上的业务提供服务，那使用 keys 指令 会有什么问题？</p><p>这个时候你要回答 Redis 关键的一个特性：Redis 的单线程的。keys 指令会导 致线程阻塞一段时间，线上服务会停顿，直到指令执行完毕，服务才能恢复。这 个时候可以使用 scan 指令，scan 指令可以无阻塞的提取出指定模式的 key 列 表，但是会有一定的重复概率，在客户端做一次去重就可以了，但是整体所花费 的时间会比直接用 keys 指令长。</p><h2 id="memcached-与-redis-的区别" tabindex="-1"><a class="header-anchor" href="#memcached-与-redis-的区别"><span>Memcached 与 Redis 的区别？</span></a></h2><ul><li><p>Redis 不仅仅支持简单的 k/v 类型的数据，同时还提供 list，set，zset， hash 等数据结构的存储。而 memcache 只支持简单数据类型，需要客户端自 己处理复杂对象。</p></li><li><p>Redis 支持数据的持久化， 可以将内存中的数据保持在磁盘中， 重启的时 候可以再次加载进行使用（ PS： 持久化在 rdb、aof）。</p></li></ul><h2 id="redis-常见性能问题和解决方案-1" tabindex="-1"><a class="header-anchor" href="#redis-常见性能问题和解决方案-1"><span>Redis 常见性能问题和解决方案：</span></a></h2><ul><li><p>Master 最好不要写内存快照，如果 Master 写内存快照，save 命令调度 rdbSave 函数， 会阻塞主线程的工作， 当快照比较大时对性能影响是非常大 的， 会间断性暂停服务。</p></li><li><p>如果数据比较重要， 某个 Slave 开启 AOF 备份数据， 策略设置为每秒 同步一。</p></li><li><p>为了主从复制的速度和连接的稳定性， Master 和 Slave 最好在同一个局 域网。</p></li><li><p>尽量避免在压力很大的主库上增加从。</p></li><li><p>主从复制不要用图状结构， 用单向链表结构更为稳定， 即：Master &lt;- Slave1&lt;- Slave2 &lt;- Slave3… 这样的结构方便解决单点故障问题，实现 Slave 对 Master 的替换。如果 Master 挂了， 可以立刻启用 Slave1 做 Master， 其他不变。</p></li></ul><h2 id="缓存如何实现高并发" tabindex="-1"><a class="header-anchor" href="#缓存如何实现高并发"><span>缓存如何实现高并发？<img src="/assets/image/docs/Aspose.Words.51b43265-f45e-4206-a945-0b7c10078cb5.035.jpeg" alt="" loading="lazy"></span></a></h2><figure><img src="/assets/image/docs/Aspose.Words.51b43265-f45e-4206-a945-0b7c10078cb5.036.jpeg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><h2 id="redis-和-memcached-的区别" tabindex="-1"><a class="header-anchor" href="#redis-和-memcached-的区别"><span>Redis 和 Memcached 的区别</span></a></h2><p>redis 拥有更多的数据结构和丰富的数据操作</p><p>redis 内存利用率高于 memcached</p><p>redis 是单线程，memcached是多线程，在存储大数据的情况下，redis 比 memcached稍有逊色</p><p>memcached没有原生的集群模式，redis 官方支持 redis cluster 集群模式</p><h2 id="用缓存可能出现的问题" tabindex="-1"><a class="header-anchor" href="#用缓存可能出现的问题"><span>用缓存可能出现的问题</span></a></h2><ul><li>数据不一致</li><li>缓存雪崩</li><li>缓存穿透</li><li>缓存并发竞争</li></ul><h2 id="当查询缓存报错-怎么提高可用性" tabindex="-1"><a class="header-anchor" href="#当查询缓存报错-怎么提高可用性"><span>当查询缓存报错，怎么提高可用性？</span></a></h2><p>缓存可以极大的提高查询性能，但是缓存数据丢失和缓存不可用不能影响应用的正常工作。因此，一般情况下，如果缓存出现异常，需要手动捕获这个异常，并且记录日志，并且从数据库查询数据返回给用户，而不应该导致业务不可用。</p><h2 id="如果避免缓存-穿透-的问题" tabindex="-1"><a class="header-anchor" href="#如果避免缓存-穿透-的问题"><span>如果避免缓存”穿透”的问题？</span></a></h2><p>缓存穿透，是指查询一个一定不存在的数据，由于缓存是不命中时被动写，并且处于容错考虑，如果从 DB 查不到数据则不写入缓存，这将导致这个不存在的数据每次请求都要到 DB 去查询，失去了缓存的意义。</p><p>如何解决</p><p>有两种方案可以解决：</p><p>方案一，缓存空对象。</p><p>当从 DB 查询数据为空，我们仍然将这个空结果进行缓存，具体的值需要使用特殊的标识，能和真正缓存的数据区分开。另外，需要设置较短的过期时间，一般建议不要超过5 分钟。</p><p>方案二，BloomFilter 布隆过滤器。</p><p>在缓存服务的基础上，构建 BloomFilter 数据结构，在 BloomFilter 中存储对应的 KEY 是否存在，如果存在，说明该 KEY 对应的值不为空。</p><h2 id="如何避免缓存-雪崩-的问题" tabindex="-1"><a class="header-anchor" href="#如何避免缓存-雪崩-的问题"><span>如何避免缓存“雪崩”的问题？</span></a></h2><p><strong>缓存雪崩</strong></p><p>缓存雪崩，是指缓存由于某些原因无法提供服务(例如，缓存挂掉了)，所有请求全部达到 DB 中，导致 DB 负荷大增，最终挂掉的情况。</p><p><strong>如何解决</strong></p><p>预防和解决缓存雪崩的问题，可以从以下多个方面进行共同着手。</p><p>1）缓存高可用：通过搭建缓存的高可用，避免缓存挂掉导致无法提供服务的情况，从而降低出现缓存雪崩的情况。假设我们使用 Redis 作为缓存，则可以使用 Redis Sentinel 或 Redis Cluster 实现高可用。</p><p>2）本地缓存：如果使用本地缓存时，即使分布式缓存挂了，也可以将 DB 查询到的结果缓存到本地，避免后续请求全部到达 DB 中。如果我们使用 JVM ，则可以使用 Ehcache、Guava Cache 实现本地缓存的功能。</p><h2 id="如果避免缓存-击穿-的问题" tabindex="-1"><a class="header-anchor" href="#如果避免缓存-击穿-的问题"><span>如果避免缓存“击穿”的问题？</span></a></h2><p><strong>缓存击穿</strong></p><p>缓存击穿，是指某个极度“热点”数据在某个时间点过期时，恰好在这个时间点对这个 KEY 有大量的并发请求过来，这些请求发现缓存过期一般都会从 DB 加载数据并回设到缓存，但是这个时候大并发的请求可能会瞬间 DB 压垮。</p><p>对于一些设置了过期时间的 KEY ，如果这些 KEY 可能会在某些时间点被超高并发地访问，是一种非常“热点”的数据。这个时候，需要考虑这个问题。区别：</p><ul><li>和缓存“雪崩“”的区别在于，前者针对某一 KEY 缓存，后者则是很多 KEY 。</li><li>和缓存“穿透“”的区别在于，这个 KEY 是真实存在对应的值的。</li></ul><p><strong>如何解决</strong></p><p>有两种方案可以解决：</p><p>1）方案一，使用互斥锁。请求发现缓存不存在后，去查询 DB 前，使用分布式锁，保证有且只有一个线程去查询 DB ，并更新到缓存。</p><p>2）方案二，手动过期。缓存上从不设置过期时间，功能上将过期时间存在 KEY 对应的 VALUE 里。流程如下：</p><ul><li>1、获取缓存。通过 VALUE 的过期时间，判断是否过期。如果未过期，则直接返回；如果已过期，继续往下执行。</li><li>2、通过一个后台的异步线程进行缓存的构建，也就是“手动”过期。通过后台的异步线程，保证有且只有一个线程去查询 DB。</li><li>3、同时，虽然 VALUE 已经过期，还是直接返回。通过这样的方式，保证服务的可用性，虽然损失了一定的时效性。</li></ul><h2 id="什么是缓存预热-如何实现缓存预热" tabindex="-1"><a class="header-anchor" href="#什么是缓存预热-如何实现缓存预热"><span>什么是缓存预热？如何实现缓存预热？</span></a></h2><p><strong>缓存预热</strong></p><p>在刚启动的缓存系统中，如果缓存中没有任何数据，如果依靠用户请求的方式重建缓存数据，那么对数据库的压力非常大，而且系统的性能开销也是巨大的。</p><p>此时，最好的策略是启动时就把热点数据加载好。这样，用户请求时，直接读取的就是缓存的数据，而无需去读取 DB 重建缓存数据。举个例子，热门的或者推荐的商品，需要提前预热到缓存中。</p><p><strong>如何实现</strong></p><p>一般来说，有如下几种方式来实现：</p><p>数据量不大时，项目启动时，自动进行初始化。</p><p>写个修复数据脚本，手动执行该脚本。</p><p>写个管理界面，可以手动点击，预热对应的数据到缓存中。</p><h2 id="缓存数据的淘汰策略有哪些" tabindex="-1"><a class="header-anchor" href="#缓存数据的淘汰策略有哪些"><span>缓存数据的淘汰策略有哪些？</span></a></h2><p>除了缓存服务器自带的缓存自动失效策略之外，我们还可以根据具体的业务需求进行自定义的“手动”缓存淘汰，常见的策略有两种：</p><p>1、定时去清理过期的缓存。</p><p>2、当有用户请求过来时，再判断这个请求所用到的缓存是否过期，过期的话就去底层系统得到新数据并更新缓存。</p><p>两者各有优劣，第一种的缺点是维护大量缓存的 key 是比较麻烦的，第二种的缺点就是每次用户请求过来都要判断缓存失效，逻辑相对比较复杂！</p><p>具体用哪种方案，大家可以根据自己的应用场景来权衡。</p></div><!--[--><!----><!--]--><footer class="page-meta"><div class="meta-item edit-link"><a href="https://github.com/xiaobaiTech/golang-full-stack/edit/main/src/中间件/redis/面试题.md" rel="noopener noreferrer" target="_blank" aria-label="在 GitHub 上编辑此页" class="nav-link label"><!--[--><svg xmlns="http://www.w3.org/2000/svg" class="icon edit-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="edit icon"><path d="M430.818 653.65a60.46 60.46 0 0 1-50.96-93.281l71.69-114.012 7.773-10.365L816.038 80.138A60.46 60.46 0 0 1 859.225 62a60.46 60.46 0 0 1 43.186 18.138l43.186 43.186a60.46 60.46 0 0 1 0 86.373L588.879 565.55l-8.637 8.637-117.466 68.234a60.46 60.46 0 0 1-31.958 11.229z"></path><path d="M728.802 962H252.891A190.883 190.883 0 0 1 62.008 771.98V296.934a190.883 190.883 0 0 1 190.883-192.61h267.754a60.46 60.46 0 0 1 0 120.92H252.891a69.962 69.962 0 0 0-69.098 69.099V771.98a69.962 69.962 0 0 0 69.098 69.098h475.911A69.962 69.962 0 0 0 797.9 771.98V503.363a60.46 60.46 0 1 1 120.922 0V771.98A190.883 190.883 0 0 1 728.802 962z"></path></svg><!--]-->在 GitHub 上编辑此页<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span><!----></a></div><div class="meta-item git-info"><div class="update-time"><span class="label">上次编辑于: </span><!----></div><div class="contributors"><span class="label">贡献者: </span><!--[--><!--[--><span class="contributor" title="email: xiaobaidebug@gmail.com">xiaobai</span><!--]--><!--]--></div></div></footer><!----><div id="comment" class="giscus-wrapper input-top" style="display:block;"><div class="loading-icon-wrapper" style="display:flex;align-items:center;justify-content:center;height:96px"><svg xmlns="http://www.w3.org/2000/svg" width="48" height="48" preserveAspectRatio="xMidYMid" viewBox="25 25 50 50"><animateTransform attributeName="transform" type="rotate" dur="2s" keyTimes="0;1" repeatCount="indefinite" values="0;360"></animateTransform><circle cx="50" cy="50" r="20" fill="none" stroke="currentColor" stroke-width="4" stroke-linecap="round"><animate attributeName="stroke-dasharray" dur="1.5s" keyTimes="0;0.5;1" repeatCount="indefinite" values="1,200;90,200;1,200"></animate><animate attributeName="stroke-dashoffset" dur="1.5s" keyTimes="0;0.5;1" repeatCount="indefinite" values="0;-35px;-125px"></animate></circle></svg></div></div><!--[--><!----><!--]--><!--]--></main><!--]--><footer class="vp-footer-wrapper"><div class="vp-footer">默认页脚</div><div class="vp-copyright">Copyright © 2024 小白debug </div></footer></div><!--]--><!--[--><!--[--><!--]--><!----><!--]--><!--]--></div>
    <script type="module" src="/assets/app-jCQZcvpD.js" defer></script>
  </body>
</html>
