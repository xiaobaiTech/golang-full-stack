<!doctype html>
<html lang="zh-CN" data-theme="light">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <meta name="generator" content="VuePress 2.0.0-rc.7" />
    <meta name="theme" content="VuePress Theme Hope 2.0.0-rc.23" />
    <style>
      html {
        background: var(--bg-color, #fff);
      }

      html[data-theme="dark"] {
        background: var(--bg-color, #1d1e1f);
      }

      body {
        background: var(--bg-color);
      }
    </style>
    <script>
      const userMode = localStorage.getItem("vuepress-theme-hope-scheme");
      const systemDarkMode =
        window.matchMedia &&
        window.matchMedia("(prefers-color-scheme: dark)").matches;

      if (userMode === "dark" || (userMode !== "light" && systemDarkMode)) {
        document.documentElement.setAttribute("data-theme", "dark");
      }
    </script>
    <meta property="og:url" content="https://golangguide.top/%E6%9E%B6%E6%9E%84/%E4%BA%91%E5%8E%9F%E7%94%9F/%E9%9D%A2%E8%AF%95%E9%A2%98.html"><meta property="og:site_name" content="golang全栈指南"><meta property="og:title" content="容器技术面试题"><meta property="og:description" content="容器技术面试题 为什么需要 DevOps 在微服务架构大背景下，原来的单体服务被越拆越小，每个服务都需要完整经历编译，构建，发布等流程，非常繁琐。 为了解决这个痛点，就需要用到DevOps。 DevOps 是一种软件开发和运维的文化和实践方法。落地到实践中，大概率就是一个基于k8s的服务管理平台。 程序员直接在界面上点点几下，就能完成服务的构建部署和扩..."><meta property="og:type" content="article"><meta property="og:image" content="https://cdn.xiaobaidebug.top/1711882143210.jpeg"><meta property="og:locale" content="zh-CN"><meta property="og:updated_time" content="2024-04-07T04:52:14.000Z"><meta name="twitter:card" content="summary_large_image"><meta name="twitter:image:alt" content="容器技术面试题"><meta property="article:author" content="小白debug"><meta property="article:modified_time" content="2024-04-07T04:52:14.000Z"><script type="application/ld+json">{"@context":"https://schema.org","@type":"Article","headline":"容器技术面试题","image":["https://cdn.xiaobaidebug.top/1711882143210.jpeg","https://cdn.xiaobaidebug.top/1711882187702.jpeg","https://cdn.xiaobaidebug.top/1711882476662.jpeg","https://cdn.jsdelivr.net/gh/xiaobaiTech/image/Aspose.Words.51b43265-f45e-4206-a945-0b7c10078cb5.028.jpeg","https://golangguide.top/assets/image/docs/Aspose.Words.51b43265-f45e-4206-a945-0b7c10078cb5.029.jpeg","https://golangguide.top/assets/image/docs/Aspose.Words.51b43265-f45e-4206-a945-0b7c10078cb5.030.jpeg","https://golangguide.top/assets/image/docs/Aspose.Words.51b43265-f45e-4206-a945-0b7c10078cb5.031.jpeg"],"dateModified":"2024-04-07T04:52:14.000Z","author":[{"@type":"Person","name":"小白debug","url":"https://xiaobaidebug.top/"}]}</script><link rel="canonical" href="https://golangguide.top/%E6%9E%B6%E6%9E%84/%E4%BA%91%E5%8E%9F%E7%94%9F/%E9%9D%A2%E8%AF%95%E9%A2%98.html"><script type="application/ld+json">{"@context":"https://schema.org","@type":"Article","headline":"容器技术面试题","image":[""],"dateModified":"2024-04-07T04:52:14.000Z","author":[]}</script><link rel="preconnect" href="https://fonts.googleapis.com"><link rel="preconnect" href="https://fonts.gstatic.com" crossorigin><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;700&display=swap"><meta name="keywords" content="Golang基础, Golang源码, 数据库原理, MySQL, ElasticSearch, 微服务架构, Kafka消息队列, Nginx服务器, Redis缓存, RocketMQ, Kubernetes, Docker容器化, k8s集群管理, CI/CD持续集成, Linux操作系统, DevOps文化, 分布式系统, 中间件技术, 开发工具集, Git版本控制, IDE集成开发环境, 源码阅读技巧, 读书笔记分享, 开源项目资源"><meta name="description" content="深入探索Golang全栈开发的世界，本网站提供了从基础到高级的全面学习资源，涵盖数据库、微服务、Kubernetes、Docker等关键技术，以及源码分析、开发工具和读书笔记等实用资料，旨在帮助开发者构建扎实的技术基础，掌握现代软件架构的核心原理。"><meta name="author" content="https://www.xiaobaidebug.top/"><meta name="og:image" content="https://golangguide.top/new_logo.png"><meta property="og:image" content="https://golangguide.top/new_logo.png"><meta name="og:image:secure_url" content="https://golangguide.top/new_logo.png"><meta name="og:url" content="https://golangguide.top/"><meta property="og:title" content="欢迎来到 golangguide - 你需要的关于 golang 全栈后端开发的所有信息，包括但不限于mysql, redis, elasticsearch，微服务，kafka等信息"><meta name="og:description" content="golangguide Docs bring you all information you need about our protocol, APIs, SDKs, ZK Stack, and hyperchains. Start with our guides and tutorials, or go deep into our architecture and protocol specification."><meta name="twitter:title" content="Welcome to our Docs - All information you need about golangguide and ZK Stack"><meta name="twitter:description" content="golangguide Docs bring you all information you need about our protocol, APIs, SDKs, ZK Stack, and hyperchains. Start with our guides and tutorials, or go deep into our architecture and protocol specification."><link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png"><link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png"><link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png"><link rel="manifest" href="/site.webmanifest"><link rel="mask-icon" href="/safari-pinned-tab.svg" color="#1E69FF"><link rel="shortcut icon" href="/favicon.ico"><meta name="msapplication-TileColor" content="#1E69FF"><meta name="msapplication-config" content="/browserconfig.xml"><meta name="theme-color" content="#1755F4"><script>
      window.addEventListener('load', function() {
        let contributors = document.querySelectorAll('.contributor');
        let contributorArr = Array.from(contributors);
        let topFive = contributorArr.slice(0, 5);
      
        topFive.forEach(function(contributor) {
          contributor.textContent = contributor.textContent.replace(',', '');
        });
      
        let lastComma = contributorArr[4];
        lastComma.textContent = lastComma.textContent.replace(',', '');
      
        let updatedList = topFive.map(function(contributor) {
          return contributor.textContent;
        }).join(', ');
          
        let contributorsDiv = document.querySelector('.contributors');
        contributorsDiv.innerHTML = '<span class="label">Contributors: </span>' + updatedList;
      
      });

      </script><title>容器技术面试题 | golang全栈指南</title>
    <link rel="preload" href="/assets/style-pUUM4cAF.css" as="style"><link rel="stylesheet" href="/assets/style-pUUM4cAF.css">
    <link rel="modulepreload" href="/assets/app-CRAuvUzn.js"><link rel="modulepreload" href="/assets/面试题.html-DKblxrdo.js"><link rel="modulepreload" href="/assets/plugin-vue_export-helper-DlAUqK2U.js">
    <link rel="prefetch" href="/assets/index.html-KfnWuv3p.js" as="script"><link rel="prefetch" href="/assets/学习路线.html-z9EpeIYu.js" as="script"><link rel="prefetch" href="/assets/常用包大全.html-noqfpw49.js" as="script"><link rel="prefetch" href="/assets/目录.html-Bi87-6aK.js" as="script"><link rel="prefetch" href="/assets/介绍.html-B--GOUO-.js" as="script"><link rel="prefetch" href="/assets/入营须知.html-DoWZAvhC.js" as="script"><link rel="prefetch" href="/assets/for select时，如果通道已经关闭会怎么样？如果只有一个case呢？.html-shQMW22I.js" as="script"><link rel="prefetch" href="/assets/golang 面试题：reflect（反射包）如何获取字段 tag？为什么 json 包不能导出私有变量的 tag？.html-BRneYYQI.js" as="script"><link rel="prefetch" href="/assets/golang并发题目测试.html-DJMtIoog.js" as="script"><link rel="prefetch" href="/assets/golang面试题：json包变量不加tag会怎么样？.html-CYKUF7rJ.js" as="script"><link rel="prefetch" href="/assets/golang面试题：字符串转成byte数组，会发生内存拷贝吗？.html-CznyfOVZ.js" as="script"><link rel="prefetch" href="/assets/golang面试题：对已经关闭的的chan进行读写，会怎么样？为什么？.html-C2R6RNCl.js" as="script"><link rel="prefetch" href="/assets/golang面试题：对未初始化的的chan进行读写，会怎么样？为什么？.html-Du0xNQ_V.js" as="script"><link rel="prefetch" href="/assets/golang面试题：怎么避免内存逃逸？.html-ByOQTia5.js" as="script"><link rel="prefetch" href="/assets/golang面试题：拷贝大切片一定比小切片代价大吗？.html-BVJV5f4g.js" as="script"><link rel="prefetch" href="/assets/golang面试题：简单聊聊内存逃逸？.html-C513Ua_e.js" as="script"><link rel="prefetch" href="/assets/golang面试题：翻转含有中文、数字、英文字母的字符串.html-DdKJygVh.js" as="script"><link rel="prefetch" href="/assets/golang高性能无GC的缓存库bigcache是怎么实现的.html-CLnZX7Co.js" as="script"><link rel="prefetch" href="/assets/io_timeout，希望你不要踩到这个http包的坑.html-x85nYJW-.js" as="script"><link rel="prefetch" href="/assets/为sync.WaitGroup中Wait函数支持WaitTimeout功能.html-DBRCvDl_.js" as="script"><link rel="prefetch" href="/assets/交替打印数字和字母.html-BKZGcyXy.js" as="script"><link rel="prefetch" href="/assets/写出以下逻辑，要求每秒钟调用一次proc并保证程序不退出.html-XMKz4UJa.js" as="script"><link rel="prefetch" href="/assets/判断两个给定的字符串排序后是否一致.html-DML8tN34.js" as="script"><link rel="prefetch" href="/assets/判断字符串中字符是否全都不同.html-lTQpxwgR.js" as="script"><link rel="prefetch" href="/assets/动图图解！怎么让goroutine跑一半就退出？.html-CHvlPsQK.js" as="script"><link rel="prefetch" href="/assets/动图图解，GMP里为什么要有P.html-CHsVw8OM.js" as="script"><link rel="prefetch" href="/assets/多协程查询切片问题.html-CqIOarra.js" as="script"><link rel="prefetch" href="/assets/如何调用一个只支持batch_call的服务？.html-kKznvdRD.js" as="script"><link rel="prefetch" href="/assets/字符串替换问题.html-Dy92y36H.js" as="script"><link rel="prefetch" href="/assets/实现阻塞读的并发安全Map.html-DeLm_w8d.js" as="script"><link rel="prefetch" href="/assets/常见语法题目一.html-Cab7DqBU.js" as="script"><link rel="prefetch" href="/assets/常见语法题目二.html-BFLDRmvc.js" as="script"><link rel="prefetch" href="/assets/昨天那个在for循环里append元素的同事，今天还在么？.html-DtVXT-Xz.js" as="script"><link rel="prefetch" href="/assets/机器人坐标问题.html-BvwC67Bh.js" as="script"><link rel="prefetch" href="/assets/给大家丢脸了，用了三年golang，我还是没答对这道内存泄漏题.html-4CszWLso.js" as="script"><link rel="prefetch" href="/assets/翻转字符串.html-v8EAvjb3.js" as="script"><link rel="prefetch" href="/assets/能说说uintptr和unsafe.Pointer的区别吗.html-BRUh-xl5.js" as="script"><link rel="prefetch" href="/assets/让golang协程和channel配合实现一个功能.html-Df2JJxiB.js" as="script"><link rel="prefetch" href="/assets/语法找错题.html-odG63Qbh.js" as="script"><link rel="prefetch" href="/assets/连nil切片和空切片一不一样都不清楚？那BAT面试官只好让你回去等通知了。.html-vjZ986PB.js" as="script"><link rel="prefetch" href="/assets/高并发下的锁与map读写问题.html-7MFNhpQF.js" as="script"><link rel="prefetch" href="/assets/1.Go入门.html-BuP7cCcU.js" as="script"><link rel="prefetch" href="/assets/2.Go进阶.html-CFIOff41.js" as="script"><link rel="prefetch" href="/assets/面试题.html-K6PmAtb8.js" as="script"><link rel="prefetch" href="/assets/面试题.html-DzQuVcfa.js" as="script"><link rel="prefetch" href="/assets/面试题.html-CrpIbKQM.js" as="script"><link rel="prefetch" href="/assets/面试题.html-_785FtoY.js" as="script"><link rel="prefetch" href="/assets/面试题.html-BH6eG-aA.js" as="script"><link rel="prefetch" href="/assets/面试题.html-Br87XiSJ.js" as="script"><link rel="prefetch" href="/assets/面试题.html-C6OBGn0L.js" as="script"><link rel="prefetch" href="/assets/面试题.html-Dl6-QWU8.js" as="script"><link rel="prefetch" href="/assets/面试题.html-ql2XTB2O.js" as="script"><link rel="prefetch" href="/assets/面试题.html-DVfIMKvO.js" as="script"><link rel="prefetch" href="/assets/面试题.html-D-Mv2Jt8.js" as="script"><link rel="prefetch" href="/assets/面试题.html-CghAWt_c.js" as="script"><link rel="prefetch" href="/assets/面试题.html-BwJBAB2M.js" as="script"><link rel="prefetch" href="/assets/面试题.html-DqGgvS4X.js" as="script"><link rel="prefetch" href="/assets/1. Python 的起源与发展.html-smeKPJlB.js" as="script"><link rel="prefetch" href="/assets/10. Python 标准库概览.html-f9oA2jgs.js" as="script"><link rel="prefetch" href="/assets/11. 字符串操作与正则表达式.html-DQiu3-uw.js" as="script"><link rel="prefetch" href="/assets/12. 列表、元组、字典与集合.html-s1rrQ3pL.js" as="script"><link rel="prefetch" href="/assets/13. 时间与日期处理.html-7HOpFshH.js" as="script"><link rel="prefetch" href="/assets/14. 常用内建函数.html-Q1m_r_03.js" as="script"><link rel="prefetch" href="/assets/15. 生成器与迭代器.html-XVo30MzV.js" as="script"><link rel="prefetch" href="/assets/2. 安装与环境配置.html-gp1tRH-T.js" as="script"><link rel="prefetch" href="/assets/3. 变量、数据类型与运算符.html-PX1cyoi9.js" as="script"><link rel="prefetch" href="/assets/4. 控制流程：条件与循环.html-BatFZffV.js" as="script"><link rel="prefetch" href="/assets/5. 函数与模块.html-cZCTBZ0n.js" as="script"><link rel="prefetch" href="/assets/6. 输入与输出.html-Dj43ImZ3.js" as="script"><link rel="prefetch" href="/assets/7. 异常处理.html-BKVrsgov.js" as="script"><link rel="prefetch" href="/assets/8. 面向对象编程基础.html-D-EwnzQT.js" as="script"><link rel="prefetch" href="/assets/9. 文件操作与管理.html-BkexeeqF.js" as="script"><link rel="prefetch" href="/assets/16. 线程与多线程编程.html-DM37ugZF.js" as="script"><link rel="prefetch" href="/assets/17. 进程与多进程编程.html-JXKtaOFk.js" as="script"><link rel="prefetch" href="/assets/18. 异步编程与协程.html-DQntBycv.js" as="script"><link rel="prefetch" href="/assets/19. 并发编程中的常见问题与解决方案.html-Dll51Whm.js" as="script"><link rel="prefetch" href="/assets/20. 线程安全与锁机制.html-BemAoApk.js" as="script"><link rel="prefetch" href="/assets/21. 进程间通信与共享资源.html-BJIJ_QT5.js" as="script"><link rel="prefetch" href="/assets/22. 异步编程框架比较.html-D8TAapWm.js" as="script"><link rel="prefetch" href="/assets/23. GIL 与 Python 多线程.html-DpP_DjvH.js" as="script"><link rel="prefetch" href="/assets/24. 多进程与多线程的选择.html-DTwYWTdK.js" as="script"><link rel="prefetch" href="/assets/25. asyncio 库与异步 IO 模型.html-BMMOp7BQ.js" as="script"><link rel="prefetch" href="/assets/26. 多进程池与线程池.html-CftmSVJa.js" as="script"><link rel="prefetch" href="/assets/27. 并行与并发的区别.html-Btn_L72Z.js" as="script"><link rel="prefetch" href="/assets/28. 异步编程中的回调地狱问题.html-C7ZaUW-J.js" as="script"><link rel="prefetch" href="/assets/29. 高并发与高性能的设计原则.html-Cva3G8-H.js" as="script"><link rel="prefetch" href="/assets/30. 分布式计算与任务调度.html-8Y71iai5.js" as="script"><link rel="prefetch" href="/assets/31. 迭代器与生成器.html-BncZuaZz.js" as="script"><link rel="prefetch" href="/assets/32. 装饰器与闭包.html-dQuA0c74.js" as="script"><link rel="prefetch" href="/assets/33. 元类与类装饰器.html-D2HXxiHe.js" as="script"><link rel="prefetch" href="/assets/34. 设计模式与最佳实践.html-C3bunBfZ.js" as="script"><link rel="prefetch" href="/assets/35. 函数式编程风格.html-Bc8hy5UU.js" as="script"><link rel="prefetch" href="/assets/36. Python 代码优化与性能提升.html-DE8g7YbK.js" as="script"><link rel="prefetch" href="/assets/37. 高级函数与 Lambda 表达式.html-Cy85cHXA.js" as="script"><link rel="prefetch" href="/assets/38. 魔术方法与元编程.html-D-4B4pCO.js" as="script"><link rel="prefetch" href="/assets/39. 动态类型与静态类型语言对比.html-DjA_2whJ.js" as="script"><link rel="prefetch" href="/assets/40. 高级模块与扩展.html-BDyNsnyf.js" as="script"><link rel="prefetch" href="/assets/41. 编码规范与文档.html-DEF01fmD.js" as="script"><link rel="prefetch" href="/assets/42. 版本控制与 Git.html-KmbIuhx-.js" as="script"><link rel="prefetch" href="/assets/43. 虚拟环境与依赖管理.html-1ZSxO1fF.js" as="script"><link rel="prefetch" href="/assets/44. IDE 与编辑器推荐.html-BMCtGoND.js" as="script"><link rel="prefetch" href="/assets/45. 调试工具与技巧.html-BX3_ZbJF.js" as="script"><link rel="prefetch" href="/assets/46. 单元测试与集成测试.html-Rvqd6JIV.js" as="script"><link rel="prefetch" href="/assets/47. 静态代码分析与 Lint 工具.html-BALIHvER.js" as="script"><link rel="prefetch" href="/assets/48. 代码重构与优化工具.html-DGjXp3vh.js" as="script"><link rel="prefetch" href="/assets/49. CI-CD 与持续集成.html-etMXv7M0.js" as="script"><link rel="prefetch" href="/assets/50. 文档生成与自动化部署.html-DxmRKMkO.js" as="script"><link rel="prefetch" href="/assets/51. 常见算法概述.html-B88Gxou6.js" as="script"><link rel="prefetch" href="/assets/52. 排序与搜索算法.html-CQMEMBes.js" as="script"><link rel="prefetch" href="/assets/53. 数据结构与算法设计.html-B__S401u.js" as="script"><link rel="prefetch" href="/assets/54. 动态规划与贪心算法.html-CRjYwFio.js" as="script"><link rel="prefetch" href="/assets/55. 图论与网络流算法.html-R-rBPFjn.js" as="script"><link rel="prefetch" href="/assets/56. 字符串匹配与处理算法.html-Dddk6oO_.js" as="script"><link rel="prefetch" href="/assets/57. 数论与组合数学.html-BCesiB-7.js" as="script"><link rel="prefetch" href="/assets/58. 复杂度分析与算法评估.html-CKKPpDlX.js" as="script"><link rel="prefetch" href="/assets/59. 算法实现与优化技巧.html-NJvm-AEs.js" as="script"><link rel="prefetch" href="/assets/60. 常用数据结构实现.html-CbqYwMY-.js" as="script"><link rel="prefetch" href="/assets/61. 数据获取与清洗.html-BwIJlG4B.js" as="script"><link rel="prefetch" href="/assets/62. 数据处理与分析.html-YgbrJojB.js" as="script"><link rel="prefetch" href="/assets/63. 数据可视化.html-mlvhTfJr.js" as="script"><link rel="prefetch" href="/assets/64. 机器学习入门.html-DaWnwC2u.js" as="script"><link rel="prefetch" href="/assets/65. 数据挖掘与预测建模.html-C9QG1qtC.js" as="script"><link rel="prefetch" href="/assets/66. 数据库与数据仓库.html-BYoB2ScK.js" as="script"><link rel="prefetch" href="/assets/67. 大数据与分布式计算.html-BRFI5kej.js" as="script"><link rel="prefetch" href="/assets/68. 自然语言处理基础.html-CBj-eD8T.js" as="script"><link rel="prefetch" href="/assets/69. 图像处理与计算机视觉.html-ZvFk7D7k.js" as="script"><link rel="prefetch" href="/assets/70. 时间序列分析与预测.html-D-I2kwbM.js" as="script"><link rel="prefetch" href="/assets/71. Linux 基础与常用命令.html-DwQKJ20Y.js" as="script"><link rel="prefetch" href="/assets/72. 网络基础与常用协议.html-CRi_pz3z.js" as="script"><link rel="prefetch" href="/assets/73. Web 服务器与部署.html-BLNnFeZz.js" as="script"><link rel="prefetch" href="/assets/74. 数据库基础与管理.html-CfbV953d.js" as="script"><link rel="prefetch" href="/assets/75. 容器化与 Docker.html-0SaXEnrZ.js" as="script"><link rel="prefetch" href="/assets/76. 自动化运维与配置管理.html-vMmdWVQp.js" as="script"><link rel="prefetch" href="/assets/77. 负载均衡与高可用性.html-BihH0-0M.js" as="script"><link rel="prefetch" href="/assets/78. 日志与监控系统.html-B_bfjNQj.js" as="script"><link rel="prefetch" href="/assets/79. 安全与漏洞管理.html-DXGZoOkg.js" as="script"><link rel="prefetch" href="/assets/80. 云计算与云服务.html-9mOCEGAR.js" as="script"><link rel="prefetch" href="/assets/81. NumPy 与 SciPy.html-BDFEmNjC.js" as="script"><link rel="prefetch" href="/assets/82. Pandas.html-Bte3YuGK.js" as="script"><link rel="prefetch" href="/assets/83. Matplotlib 与 Seaborn.html-nSFoRu1S.js" as="script"><link rel="prefetch" href="/assets/84. Requests 与 Beautiful Soup.html-Dkq6x5gl.js" as="script"><link rel="prefetch" href="/assets/85. Django 与 Flask.html-C0O7wmm7.js" as="script"><link rel="prefetch" href="/assets/86. SQLAlchemy 与 ORM.html-JARKQlX1.js" as="script"><link rel="prefetch" href="/assets/87. Celery 与任务队列.html-CY0rro7e.js" as="script"><link rel="prefetch" href="/assets/88. TensorFlow 与机器学习库.html-BGdJVQZ-.js" as="script"><link rel="prefetch" href="/assets/89. PyQT 与 GUI 开发.html-Bi8CdRrB.js" as="script"><link rel="prefetch" href="/assets/90. GIS 与地理信息处理.html-sZMOGmL3.js" as="script"><link rel="prefetch" href="/assets/100.  项目总结与回顾.html-BYe5FMwa.js" as="script"><link rel="prefetch" href="/assets/91. 项目介绍与需求分析.html-CVuu3lt3.js" as="script"><link rel="prefetch" href="/assets/92. 项目架构与设计.html-VSlxwsIB.js" as="script"><link rel="prefetch" href="/assets/93. 代码实现与测试.html-DBrX-R8e.js" as="script"><link rel="prefetch" href="/assets/94. 项目部署与维护.html-Ds1QLA2G.js" as="script"><link rel="prefetch" href="/assets/95. 用户反馈与迭代优化.html-CeKzBEp-.js" as="script"><link rel="prefetch" href="/assets/96. 项目文档与知识分享.html-Co-Pzmzt.js" as="script"><link rel="prefetch" href="/assets/97. 团队协作与版本控制.html-DgoYfmW5.js" as="script"><link rel="prefetch" href="/assets/98. 项目上线与发布.html-D9yKcepr.js" as="script"><link rel="prefetch" href="/assets/99. 故障处理与紧急修复.html-oKMDgpDk.js" as="script"><link rel="prefetch" href="/assets/elasticSearch架构是怎么样的.html-DKJa8Kcy.js" as="script"><link rel="prefetch" href="/assets/kafka是什么？架构是怎么样的？.html-CwolA6q5.js" as="script"><link rel="prefetch" href="/assets/Mysql并发写数据，怎么保证唯一性？.html-CoceppyT.js" as="script"><link rel="prefetch" href="/assets/Mysql数据库查询好慢，除了索引，还能因为什么？.html-CUt7fg7s.js" as="script"><link rel="prefetch" href="/assets/Mysql的索引为什么使用B_树而不使用跳表？.html-BTrXdL-x.js" as="script"><link rel="prefetch" href="/assets/mysql主库更新后，从库读到最新值了，主库还有可能读到旧值吗？.html-DGOtPsBo.js" as="script"><link rel="prefetch" href="/assets/mysql查询 limit 1000_10 和limit 10 速度一样快吗？.html-DZ6ppNXS.js" as="script"><link rel="prefetch" href="/assets/mysql的varchar字段最大长度真的是65535吗？.html-3QJD4mec.js" as="script"><link rel="prefetch" href="/assets/为什么mysql写数据会丢失数据？.html-s9lVlc54.js" as="script"><link rel="prefetch" href="/assets/为什么mysql插入不存在的数据会产生死锁？.html-Ctv64CAh.js" as="script"><link rel="prefetch" href="/assets/为什么mysql的count()方法这么慢？.html-CuvAHtEB.js" as="script"><link rel="prefetch" href="/assets/为什么大家说mysql数据库单表最大两千万？.html-BU-yLKV3.js" as="script"><link rel="prefetch" href="/assets/分库分表带来的读扩散问题，怎么解决？.html-CYHnU2Qd.js" as="script"><link rel="prefetch" href="/assets/数据库主键一定要自增的吗？不自增行不行？有哪些场景下不建议自增？.html-CGrP-UqJ.js" as="script"><link rel="prefetch" href="/assets/都是select语句，为什么读到的内容不一样？.html-_YH5-E7v.js" as="script"><link rel="prefetch" href="/assets/RocketMQ为什么性能不如Kafka.html-Db1tkx2h.js" as="script"><link rel="prefetch" href="/assets/RocketMQ是什么.html-D_ZFOZVJ.js" as="script"><link rel="prefetch" href="/assets/docker和传统虚拟机有什么区别.html-ClTuMBcU.js" as="script"><link rel="prefetch" href="/assets/docker是什么docker和kubernetes(k8s)之间是什么关系有什么区别.html-C6Rkuudr.js" as="script"><link rel="prefetch" href="/assets/k8s到底是什么.html-CmAqMP8Z.js" as="script"><link rel="prefetch" href="/assets/QPS的计算是怎么实现的.html-DKgcpcbr.js" as="script"><link rel="prefetch" href="/assets/docker和传统虚拟机有什么区别.html-B1h5L4Iw.js" as="script"><link rel="prefetch" href="/assets/k8s到底是什么.html-DJK7kWUK.js" as="script"><link rel="prefetch" href="/assets/服务发现有哪些要素.html-DV-iE9aw.js" as="script"><link rel="prefetch" href="/assets/服务熔断和服务降级是指什么.html-Cv2ZJKAE.js" as="script"><link rel="prefetch" href="/assets/给32位系统装8g内存条能用吗？为什么？.html-CKX6vkoZ.js" as="script"><link rel="prefetch" href="/assets/TCP四次挥手中如果服务端没收到第四次挥手请求，服务端会一直等待吗？.html-B9MlcFNR.js" as="script"><link rel="prefetch" href="/assets/TCP粘包！数据包：我只是犯了每个数据包都会犯的错，硬核图解.html-C4H-7Ggg.js" as="script"><link rel="prefetch" href="/assets/UDP就一定比TCP快吗.html-DzdBuolg.js" as="script"><link rel="prefetch" href="/assets/socket到底是什么？.html-CpQFcB-H.js" as="script"><link rel="prefetch" href="/assets/不是我不回你消息，是因为网络会丢包.html-Bb_VxI5A.js" as="script"><link rel="prefetch" href="/assets/为什么我们的IP都是192.168开头的？.html-DSm2uRlX.js" as="script"><link rel="prefetch" href="/assets/为什么我在公司里访问不了家里的电脑？.html-D3_TCRMi.js" as="script"><link rel="prefetch" href="/assets/为什么有HTTP协议，还要有websocket协议.html-6CcGAGxx.js" as="script"><link rel="prefetch" href="/assets/动图图解！代码执行send成功后，数据就发出去了吗？.html-D5OSWcs7.js" as="script"><link rel="prefetch" href="/assets/动图图解！收到RST，就一定会断开TCP连接吗？.html-DJTxhLT0.js" as="script"><link rel="prefetch" href="/assets/动图图解！既然IP层会分片，为什么TCP层也还要分段？.html-Bezl0-hk.js" as="script"><link rel="prefetch" href="/assets/原神的游戏服务器架构是怎么样的.html-Cthmuvu1.js" as="script"><link rel="prefetch" href="/assets/既然有HTTP协议，为什么还要有RPC协议？.html-4aIK3snv.js" as="script"><link rel="prefetch" href="/assets/没有accept能建立TCP连接吗.html-CL80QLUl.js" as="script"><link rel="prefetch" href="/assets/活久见！TCP两次挥手，你见过吗？那四次握手呢？.html-BXDc4kZg.js" as="script"><link rel="prefetch" href="/assets/硬核图解！30张图带你搞懂！路由器，集线器，交换机，网桥，光猫有啥区别？.html-Dibx92kB.js" as="script"><link rel="prefetch" href="/assets/硬核图解！断网了，还能ping通回环地址吗？为什么.html-D83H86fE.js" as="script"><link rel="prefetch" href="/assets/硬核！漫画图解HTTP知识点_面试题.html-C_YX2F3J.js" as="script"><link rel="prefetch" href="/assets/能ping通，就代表TCP一定能连通吗？.html-v03Yi-64.js" as="script"><link rel="prefetch" href="/assets/连接一个IP不存在的主机时，握手过程是怎样的.html-B61QQRAE.js" as="script"><link rel="prefetch" href="/assets/404.html-B82fum0R.js" as="script"><link rel="prefetch" href="/assets/index.html-C8jFpyUl.js" as="script"><link rel="prefetch" href="/assets/index.html-CsHuf2wy.js" as="script"><link rel="prefetch" href="/assets/index.html-B5iUYcR1.js" as="script"><link rel="prefetch" href="/assets/index.html-Jj-GwyBv.js" as="script"><link rel="prefetch" href="/assets/index.html-CC20obap.js" as="script"><link rel="prefetch" href="/assets/index.html-CKFuoGd_.js" as="script"><link rel="prefetch" href="/assets/index.html-DAmuwMdH.js" as="script"><link rel="prefetch" href="/assets/index.html-DRYw1NOY.js" as="script"><link rel="prefetch" href="/assets/index.html-BjhXtfF7.js" as="script"><link rel="prefetch" href="/assets/index.html-CtimCAAq.js" as="script"><link rel="prefetch" href="/assets/index.html-B38SGTDd.js" as="script"><link rel="prefetch" href="/assets/index.html-D8GTI3kU.js" as="script"><link rel="prefetch" href="/assets/index.html-vORhOxLC.js" as="script"><link rel="prefetch" href="/assets/index.html-BfRv0_6A.js" as="script"><link rel="prefetch" href="/assets/index.html-CX7ckhn7.js" as="script"><link rel="prefetch" href="/assets/index.html-MnvQD531.js" as="script"><link rel="prefetch" href="/assets/index.html-CPCkuIJO.js" as="script"><link rel="prefetch" href="/assets/index.html-C2WzEdbj.js" as="script"><link rel="prefetch" href="/assets/index.html-buYFVYxA.js" as="script"><link rel="prefetch" href="/assets/index.html-C9pI8l0C.js" as="script"><link rel="prefetch" href="/assets/index.html-BR1XvVO1.js" as="script"><link rel="prefetch" href="/assets/index.html-DTDtXKs7.js" as="script"><link rel="prefetch" href="/assets/index.html-BvscxXAk.js" as="script"><link rel="prefetch" href="/assets/index.html-BePgI42g.js" as="script"><link rel="prefetch" href="/assets/index.html-B1cGtAG0.js" as="script"><link rel="prefetch" href="/assets/index.html-Fk2WVDLA.js" as="script"><link rel="prefetch" href="/assets/index.html-LIhhv6ZN.js" as="script"><link rel="prefetch" href="/assets/index.html-rqPYVQi3.js" as="script"><link rel="prefetch" href="/assets/index.html-B5aRt_NH.js" as="script"><link rel="prefetch" href="/assets/index.html-BV_Ho0Ln.js" as="script"><link rel="prefetch" href="/assets/index.html-DKwVmEXq.js" as="script"><link rel="prefetch" href="/assets/index.html-SD6iygks.js" as="script"><link rel="prefetch" href="/assets/index.html-MYG83zaJ.js" as="script"><link rel="prefetch" href="/assets/index.html-DeZWs-FZ.js" as="script"><link rel="prefetch" href="/assets/index.html-umPLacbD.js" as="script"><link rel="prefetch" href="/assets/index.html-DHDLwWbR.js" as="script"><link rel="prefetch" href="/assets/index.html-Cwo0JP3v.js" as="script"><link rel="prefetch" href="/assets/index.html-Db77OtAK.js" as="script"><link rel="prefetch" href="/assets/index.html-T4T-PSZi.js" as="script"><link rel="prefetch" href="/assets/index.html-CuqQg7Kq.js" as="script"><link rel="prefetch" href="/assets/index.html-BLFQXGko.js" as="script"><link rel="prefetch" href="/assets/index.html-CUesHVjD.js" as="script"><link rel="prefetch" href="/assets/giscus-7BMGhbDA.js" as="script"><link rel="prefetch" href="/assets/auto-C0MMSKEI.js" as="script"><link rel="prefetch" href="/assets/index-DA4axBLK.js" as="script"><link rel="prefetch" href="/assets/flowchart-966sEcGG.js" as="script"><link rel="prefetch" href="/assets/mermaid.core-BHUL23CN.js" as="script"><link rel="prefetch" href="/assets/reveal.esm-9nNZbZvi.js" as="script"><link rel="prefetch" href="/assets/markdown.esm-BG2Xu2Hd.js" as="script"><link rel="prefetch" href="/assets/vue-repl-CmbTnm-b.js" as="script"><link rel="prefetch" href="/assets/codemirror-editor-C_S4IeSi.js" as="script"><link rel="prefetch" href="/assets/photoswipe.esm-SzV8tJDW.js" as="script">
  </head>
  <body>
    <div id="app"><!--[--><!--[--><!--[--><span tabindex="-1"></span><a href="#main-content" class="vp-skip-link sr-only">跳至主要內容</a><!--]--><div class="theme-container has-toc"><!--[--><header id="navbar" class="vp-navbar"><div class="vp-navbar-start"><button type="button" class="vp-toggle-sidebar-button" title="Toggle Sidebar"><span class="icon"></span></button><!--[--><!----><!--]--><!--[--><a class="route-link vp-brand" href="/"><img class="vp-nav-logo" src="/new_logo.png" alt><!----><span class="vp-site-name hide-in-pad">golang全栈指南</span></a><!--]--><!--[--><!----><!--]--></div><div class="vp-navbar-center"><!--[--><!----><!--]--><!--[--><nav class="vp-nav-links"><div class="nav-item hide-in-mobile"><a class="route-link nav-link" href="/" aria-label="主页"><span class="font-icon icon fa-fw fa-sm fas fa-home" style=""></span>主页<!----></a></div><div class="nav-item hide-in-mobile"><div class="dropdown-wrapper"><button type="button" class="dropdown-title" aria-label="训练营"><span class="title"><span class="font-icon icon fa-fw fa-sm fas fa-campground" style=""></span>训练营</span><span class="arrow"></span><ul class="nav-dropdown"><li class="dropdown-item"><a class="route-link nav-link" href="/%E8%AE%AD%E7%BB%83%E8%90%A5/%E4%BB%8B%E7%BB%8D.html" aria-label="介绍"><span class="font-icon icon fa-fw fa-sm fas fa-address-card" style=""></span>介绍<!----></a></li><li class="dropdown-item"><a class="route-link nav-link" href="/%E8%AE%AD%E7%BB%83%E8%90%A5/%E5%85%A5%E8%90%A5%E9%A1%BB%E7%9F%A5.html" aria-label="入营须知"><span class="font-icon icon fa-fw fa-sm fas fa-brain" style=""></span>入营须知<!----></a></li></ul></button></div></div><div class="nav-item hide-in-mobile"><div class="dropdown-wrapper"><button type="button" class="dropdown-title" aria-label="计算机基础"><span class="title"><span class="font-icon icon fa-fw fa-sm fas fa-computer" style=""></span>计算机基础</span><span class="arrow"></span><ul class="nav-dropdown"><li class="dropdown-item"><a class="route-link nav-link" href="/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" aria-label="操作系统"><span class="font-icon icon fa-fw fa-sm fas fa-server" style=""></span>操作系统<!----></a></li><li class="dropdown-item"><a class="route-link nav-link" href="/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/" aria-label="网络基础"><span class="font-icon icon fa-fw fa-sm fas fa-wifi" style=""></span>网络基础<!----></a></li></ul></button></div></div><div class="nav-item hide-in-mobile"><div class="dropdown-wrapper"><button type="button" class="dropdown-title" aria-label="架构"><span class="title"><span class="font-icon icon fa-fw fa-sm fas fa-folder-tree" style=""></span>架构</span><span class="arrow"></span><ul class="nav-dropdown"><li class="dropdown-item"><a class="route-link nav-link active" href="/%E6%9E%B6%E6%9E%84/%E4%BA%91%E5%8E%9F%E7%94%9F/" aria-label="云原生"><span class="font-icon icon fa-fw fa-sm fas fa-box" style=""></span>云原生<!----></a></li><li class="dropdown-item"><a class="route-link nav-link" href="/%E6%9E%B6%E6%9E%84/%E5%88%86%E5%B8%83%E5%BC%8F/" aria-label="分布式"><span class="font-icon icon fa-fw fa-sm fas fa-manat-sign" style=""></span>分布式<!----></a></li><li class="dropdown-item"><a class="route-link nav-link" href="/%E6%9E%B6%E6%9E%84/%E5%BE%AE%E6%9C%8D%E5%8A%A1/" aria-label="微服务"><span class="font-icon icon fa-fw fa-sm fas fa-microchip" style=""></span>微服务<!----></a></li><li class="dropdown-item"><a class="route-link nav-link" href="/%E6%9E%B6%E6%9E%84/%E8%BF%90%E7%BB%B4/" aria-label="运维"><span class="font-icon icon fa-fw fa-sm fas fa-folder-open" style=""></span>运维<!----></a></li></ul></button></div></div><div class="nav-item hide-in-mobile"><div class="dropdown-wrapper"><button type="button" class="dropdown-title" aria-label="中间件"><span class="title"><span class="font-icon icon fa-fw fa-sm fas fa-align-center" style=""></span>中间件</span><span class="arrow"></span><ul class="nav-dropdown"><li class="dropdown-item"><a class="route-link nav-link" href="/%E4%B8%AD%E9%97%B4%E4%BB%B6/es/" aria-label="ES"><span class="font-icon icon fa-fw fa-sm fas fa-magnifying-glass" style=""></span>ES<!----></a></li><li class="dropdown-item"><a class="route-link nav-link" href="/%E4%B8%AD%E9%97%B4%E4%BB%B6/kafka/" aria-label="Kafka"><span class="font-icon icon fa-fw fa-sm fas fa-chess-queen" style=""></span>Kafka<!----></a></li><li class="dropdown-item"><a class="route-link nav-link" href="/%E4%B8%AD%E9%97%B4%E4%BB%B6/Memcached/" aria-label="Memcached"><span class="font-icon icon fa-fw fa-sm fas fa-suitcase" style=""></span>Memcached<!----></a></li><li class="dropdown-item"><a class="route-link nav-link" href="/%E4%B8%AD%E9%97%B4%E4%BB%B6/ClickHouse/" aria-label="ClickHouse"><span class="font-icon icon fa-fw fa-sm fas fa-house-laptop" style=""></span>ClickHouse<!----></a></li><li class="dropdown-item"><a class="route-link nav-link" href="/%E4%B8%AD%E9%97%B4%E4%BB%B6/mongodb/" aria-label="Mongodb"><span class="font-icon icon fa-fw fa-sm fas fa-vr-cardboard" style=""></span>Mongodb<!----></a></li><li class="dropdown-item"><a class="route-link nav-link" href="/%E4%B8%AD%E9%97%B4%E4%BB%B6/mysql/" aria-label="Mysql"><span class="font-icon icon fa-fw fa-sm fas fa-database" style=""></span>Mysql<!----></a></li><li class="dropdown-item"><a class="route-link nav-link" href="/%E4%B8%AD%E9%97%B4%E4%BB%B6/nginx/" aria-label="Nginx"><span class="font-icon icon fa-fw fa-sm fas fa-network-wired" style=""></span>Nginx<!----></a></li><li class="dropdown-item"><a class="route-link nav-link" href="/%E4%B8%AD%E9%97%B4%E4%BB%B6/rabbitmq/" aria-label="RabbitMQ"><span class="font-icon icon fa-fw fa-sm fas fa-frog" style=""></span>RabbitMQ<!----></a></li><li class="dropdown-item"><a class="route-link nav-link" href="/%E4%B8%AD%E9%97%B4%E4%BB%B6/redis/" aria-label="Redis"><span class="font-icon icon fa-fw fa-sm fas fa-registered" style=""></span>Redis<!----></a></li><li class="dropdown-item"><a class="route-link nav-link" href="/%E4%B8%AD%E9%97%B4%E4%BB%B6/rocketmq/" aria-label="RocketMQ"><span class="font-icon icon fa-fw fa-sm fas fa-rocket" style=""></span>RocketMQ<!----></a></li></ul></button></div></div><div class="nav-item hide-in-mobile"><div class="dropdown-wrapper"><button type="button" class="dropdown-title" aria-label="Golang"><span class="title"><span class="font-icon icon fa-fw fa-sm fas fa-lightbulb" style=""></span>Golang</span><span class="arrow"></span><ul class="nav-dropdown"><li class="dropdown-item"><a class="route-link nav-link" href="/golang/%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF.html" aria-label="学习路线"><span class="font-icon icon fa-fw fa-sm fas fa-map-location-dot" style=""></span>学习路线<!----></a></li><li class="dropdown-item"><a class="route-link nav-link" href="/golang/%E5%B8%B8%E7%94%A8%E5%8C%85%E5%A4%A7%E5%85%A8.html" aria-label="常用包大全"><span class="font-icon icon fa-fw fa-sm fas fa-book" style=""></span>常用包大全<!----></a></li><li class="dropdown-item"><a class="route-link nav-link" href="/golang/%E6%A0%B8%E5%BF%83%E7%9F%A5%E8%AF%86%E7%82%B9/" aria-label="核心知识点"><span class="font-icon icon fa-fw fa-sm fas fa-house-laptop" style=""></span>核心知识点<!----></a></li><li class="dropdown-item"><a class="route-link nav-link" href="/golang/%E9%9D%A2%E8%AF%95%E9%A2%98/1.Go%E5%85%A5%E9%97%A8.html" aria-label="基础面试题"><span class="font-icon icon fa-fw fa-sm fas fa-disease" style=""></span>基础面试题<!----></a></li><li class="dropdown-item"><a class="route-link nav-link" href="/golang/%E9%9D%A2%E8%AF%95%E9%A2%98/2.Go%E8%BF%9B%E9%98%B6.html" aria-label="进阶面试题"><span class="font-icon icon fa-fw fa-sm fas fa-clipboard-question" style=""></span>进阶面试题<!----></a></li></ul></button></div></div><div class="nav-item hide-in-mobile"><a href="https://xiaobaidebug.top/" rel="noopener noreferrer" target="_blank" aria-label="blog" class="nav-link"><span class="font-icon icon fa-fw fa-sm fas fa-book" style=""></span>blog<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span><!----></a></div><div class="nav-item hide-in-mobile"><a href="https://golangguide.top/sitemap.xml" rel="noopener noreferrer" target="_blank" aria-label="sitemap" class="nav-link"><span class="font-icon icon fa-fw fa-sm fas fa-blog" style=""></span>sitemap<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span><!----></a></div></nav><!--]--><!--[--><!----><!--]--></div><div class="vp-navbar-end"><!--[--><!----><!--]--><!--[--><!----><div class="nav-item vp-repo"><a class="vp-repo-link" href="https://github.com/xiaobaiTech/golang-full-stack" target="_blank" rel="noopener noreferrer" aria-label="GitHub"><svg xmlns="http://www.w3.org/2000/svg" class="icon github-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="github icon" style="width:1.25rem;height:1.25rem;vertical-align:middle;"><path d="M511.957 21.333C241.024 21.333 21.333 240.981 21.333 512c0 216.832 140.544 400.725 335.574 465.664 24.49 4.395 32.256-10.07 32.256-23.083 0-11.69.256-44.245 0-85.205-136.448 29.61-164.736-64.64-164.736-64.64-22.315-56.704-54.4-71.765-54.4-71.765-44.587-30.464 3.285-29.824 3.285-29.824 49.195 3.413 75.179 50.517 75.179 50.517 43.776 75.008 114.816 53.333 142.762 40.79 4.523-31.66 17.152-53.377 31.19-65.537-108.971-12.458-223.488-54.485-223.488-242.602 0-53.547 19.114-97.323 50.517-131.67-5.035-12.33-21.93-62.293 4.779-129.834 0 0 41.258-13.184 134.912 50.346a469.803 469.803 0 0 1 122.88-16.554c41.642.213 83.626 5.632 122.88 16.554 93.653-63.488 134.784-50.346 134.784-50.346 26.752 67.541 9.898 117.504 4.864 129.834 31.402 34.347 50.474 78.123 50.474 131.67 0 188.586-114.73 230.016-224.042 242.09 17.578 15.232 33.578 44.672 33.578 90.454v135.85c0 13.142 7.936 27.606 32.854 22.87C862.25 912.597 1002.667 728.747 1002.667 512c0-271.019-219.648-490.667-490.71-490.667z"></path></svg></a></div><div class="nav-item hide-in-mobile"><button type="button" id="appearance-switch"><svg xmlns="http://www.w3.org/2000/svg" class="icon auto-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="auto icon" style="display:block;"><path d="M512 992C246.92 992 32 777.08 32 512S246.92 32 512 32s480 214.92 480 480-214.92 480-480 480zm0-840c-198.78 0-360 161.22-360 360 0 198.84 161.22 360 360 360s360-161.16 360-360c0-198.78-161.22-360-360-360zm0 660V212c165.72 0 300 134.34 300 300 0 165.72-134.28 300-300 300z"></path></svg><svg xmlns="http://www.w3.org/2000/svg" class="icon dark-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="dark icon" style="display:none;"><path d="M524.8 938.667h-4.267a439.893 439.893 0 0 1-313.173-134.4 446.293 446.293 0 0 1-11.093-597.334A432.213 432.213 0 0 1 366.933 90.027a42.667 42.667 0 0 1 45.227 9.386 42.667 42.667 0 0 1 10.24 42.667 358.4 358.4 0 0 0 82.773 375.893 361.387 361.387 0 0 0 376.747 82.774 42.667 42.667 0 0 1 54.187 55.04 433.493 433.493 0 0 1-99.84 154.88 438.613 438.613 0 0 1-311.467 128z"></path></svg><svg xmlns="http://www.w3.org/2000/svg" class="icon light-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="light icon" style="display:none;"><path d="M952 552h-80a40 40 0 0 1 0-80h80a40 40 0 0 1 0 80zM801.88 280.08a41 41 0 0 1-57.96-57.96l57.96-58a41.04 41.04 0 0 1 58 58l-58 57.96zM512 752a240 240 0 1 1 0-480 240 240 0 0 1 0 480zm0-560a40 40 0 0 1-40-40V72a40 40 0 0 1 80 0v80a40 40 0 0 1-40 40zm-289.88 88.08-58-57.96a41.04 41.04 0 0 1 58-58l57.96 58a41 41 0 0 1-57.96 57.96zM192 512a40 40 0 0 1-40 40H72a40 40 0 0 1 0-80h80a40 40 0 0 1 40 40zm30.12 231.92a41 41 0 0 1 57.96 57.96l-57.96 58a41.04 41.04 0 0 1-58-58l58-57.96zM512 832a40 40 0 0 1 40 40v80a40 40 0 0 1-80 0v-80a40 40 0 0 1 40-40zm289.88-88.08 58 57.96a41.04 41.04 0 0 1-58 58l-57.96-58a41 41 0 0 1 57.96-57.96z"></path></svg></button></div><!----><!--]--><!--[--><!----><!--]--><button type="button" class="vp-toggle-navbar-button" aria-label="Toggle Navbar" aria-expanded="false" aria-controls="nav-screen"><span><span class="vp-top"></span><span class="vp-middle"></span><span class="vp-bottom"></span></span></button></div></header><!----><!--]--><!----><div class="toggle-sidebar-wrapper"><span class="arrow start"></span></div><aside id="sidebar" class="vp-sidebar"><!--[--><!----><!--]--><ul class="vp-sidebar-links"><li><section class="vp-sidebar-group"><p class="vp-sidebar-heading clickable active"><span class="font-icon icon fa-fw fa-sm fas fa-laptop-code" style=""></span><a class="route-link nav-link vp-sidebar-title" href="/架构/架构/" aria-label="架构"><!---->架构<!----></a><!----></p><ul class="vp-sidebar-links"><li><section class="vp-sidebar-group"><button class="vp-sidebar-heading clickable active" type="button"><!----><span class="vp-sidebar-title">云原生</span><span class="vp-arrow down"></span></button><ul class="vp-sidebar-links"><li><!--[--><a class="route-link nav-link active vp-sidebar-link vp-sidebar-page active" href="/%E6%9E%B6%E6%9E%84/%E4%BA%91%E5%8E%9F%E7%94%9F/%E9%9D%A2%E8%AF%95%E9%A2%98.html" aria-label="容器技术面试题"><!---->容器技术面试题<!----></a><ul class="vp-sidebar-sub-headers"><li class="vp-sidebar-sub-header"><a class="route-link nav-link vp-sidebar-link vp-heading" href="/%E6%9E%B6%E6%9E%84/%E4%BA%91%E5%8E%9F%E7%94%9F/%E9%9D%A2%E8%AF%95%E9%A2%98.html#为什么需要-devops" aria-label="为什么需要 DevOps"><!---->为什么需要 DevOps<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a class="route-link nav-link vp-sidebar-link vp-heading" href="/%E6%9E%B6%E6%9E%84/%E4%BA%91%E5%8E%9F%E7%94%9F/%E9%9D%A2%E8%AF%95%E9%A2%98.html#docker-是什么" aria-label="Docker 是什么？"><!---->Docker 是什么？<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a class="route-link nav-link vp-sidebar-link vp-heading" href="/%E6%9E%B6%E6%9E%84/%E4%BA%91%E5%8E%9F%E7%94%9F/%E9%9D%A2%E8%AF%95%E9%A2%98.html#docker-与虚拟机有何不同" aria-label="Docker 与虚拟机有何不同？"><!---->Docker 与虚拟机有何不同？<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a class="route-link nav-link vp-sidebar-link vp-heading" href="/%E6%9E%B6%E6%9E%84/%E4%BA%91%E5%8E%9F%E7%94%9F/%E9%9D%A2%E8%AF%95%E9%A2%98.html#什么是-docker-镜像" aria-label="什么是 Docker 镜像？"><!---->什么是 Docker 镜像？<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a class="route-link nav-link vp-sidebar-link vp-heading" href="/%E6%9E%B6%E6%9E%84/%E4%BA%91%E5%8E%9F%E7%94%9F/%E9%9D%A2%E8%AF%95%E9%A2%98.html#什么是-docker-容器" aria-label="什么是 Docker 容器？"><!---->什么是 Docker 容器？<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a class="route-link nav-link vp-sidebar-link vp-heading" href="/%E6%9E%B6%E6%9E%84/%E4%BA%91%E5%8E%9F%E7%94%9F/%E9%9D%A2%E8%AF%95%E9%A2%98.html#docker-容器有几种状态" aria-label="Docker 容器有几种状态？"><!---->Docker 容器有几种状态？<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a class="route-link nav-link vp-sidebar-link vp-heading" href="/%E6%9E%B6%E6%9E%84/%E4%BA%91%E5%8E%9F%E7%94%9F/%E9%9D%A2%E8%AF%95%E9%A2%98.html#dockerfile-中最常见的指令是什么" aria-label="Dockerfile 中最常见的指令是什么？"><!---->Dockerfile 中最常见的指令是什么？<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a class="route-link nav-link vp-sidebar-link vp-heading" href="/%E6%9E%B6%E6%9E%84/%E4%BA%91%E5%8E%9F%E7%94%9F/%E9%9D%A2%E8%AF%95%E9%A2%98.html#dockerfile-中的命令-copy-和-add-命令有什么区别" aria-label="Dockerfile 中的命令 COPY 和 ADD 命令有什么区别？"><!---->Dockerfile 中的命令 COPY 和 ADD 命令有什么区别？<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a class="route-link nav-link vp-sidebar-link vp-heading" href="/%E6%9E%B6%E6%9E%84/%E4%BA%91%E5%8E%9F%E7%94%9F/%E9%9D%A2%E8%AF%95%E9%A2%98.html#解释一下-dockerfile-的-onbuild-指令" aria-label="解释一下 Dockerfile 的 ONBUILD 指令？"><!---->解释一下 Dockerfile 的 ONBUILD 指令？<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a class="route-link nav-link vp-sidebar-link vp-heading" href="/%E6%9E%B6%E6%9E%84/%E4%BA%91%E5%8E%9F%E7%94%9F/%E9%9D%A2%E8%AF%95%E9%A2%98.html#什么是-docker-swarm" aria-label="什么是 Docker Swarm？"><!---->什么是 Docker Swarm？<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a class="route-link nav-link vp-sidebar-link vp-heading" href="/%E6%9E%B6%E6%9E%84/%E4%BA%91%E5%8E%9F%E7%94%9F/%E9%9D%A2%E8%AF%95%E9%A2%98.html#如何在生产中监控-docker" aria-label="如何在生产中监控 Docker？"><!---->如何在生产中监控 Docker？<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a class="route-link nav-link vp-sidebar-link vp-heading" href="/%E6%9E%B6%E6%9E%84/%E4%BA%91%E5%8E%9F%E7%94%9F/%E9%9D%A2%E8%AF%95%E9%A2%98.html#devops-有哪些优势" aria-label="DevOps 有哪些优势？"><!---->DevOps 有哪些优势？<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a class="route-link nav-link vp-sidebar-link vp-heading" href="/%E6%9E%B6%E6%9E%84/%E4%BA%91%E5%8E%9F%E7%94%9F/%E9%9D%A2%E8%AF%95%E9%A2%98.html#ci-服务有什么用途" aria-label="CI 服务有什么用途？"><!---->CI 服务有什么用途？<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a class="route-link nav-link vp-sidebar-link vp-heading" href="/%E6%9E%B6%E6%9E%84/%E4%BA%91%E5%8E%9F%E7%94%9F/%E9%9D%A2%E8%AF%95%E9%A2%98.html#如何使用-docker-技术创建与环境无关的容器系统" aria-label="如何使用 Docker 技术创建与环境无关的容器系统？"><!---->如何使用 Docker 技术创建与环境无关的容器系统？<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a class="route-link nav-link vp-sidebar-link vp-heading" href="/%E6%9E%B6%E6%9E%84/%E4%BA%91%E5%8E%9F%E7%94%9F/%E9%9D%A2%E8%AF%95%E9%A2%98.html#dockerfile-配置文件中的-copy-和-add-指令有什么不同" aria-label="Dockerfile 配置文件中的 COPY 和 ADD 指令有什么不同？"><!---->Dockerfile 配置文件中的 COPY 和 ADD 指令有什么不同？<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a class="route-link nav-link vp-sidebar-link vp-heading" href="/%E6%9E%B6%E6%9E%84/%E4%BA%91%E5%8E%9F%E7%94%9F/%E9%9D%A2%E8%AF%95%E9%A2%98.html#docker-映像-image-是什么" aria-label="Docker 映像（image）是什么？"><!---->Docker 映像（image）是什么？<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a class="route-link nav-link vp-sidebar-link vp-heading" href="/%E6%9E%B6%E6%9E%84/%E4%BA%91%E5%8E%9F%E7%94%9F/%E9%9D%A2%E8%AF%95%E9%A2%98.html#docker-容器-container-是什么" aria-label="Docker 容器（container）是什么？"><!---->Docker 容器（container）是什么？<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a class="route-link nav-link vp-sidebar-link vp-heading" href="/%E6%9E%B6%E6%9E%84/%E4%BA%91%E5%8E%9F%E7%94%9F/%E9%9D%A2%E8%AF%95%E9%A2%98.html#docker-hub-是什么" aria-label="Docker hub 是什么？"><!---->Docker hub 是什么？<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a class="route-link nav-link vp-sidebar-link vp-heading" href="/%E6%9E%B6%E6%9E%84/%E4%BA%91%E5%8E%9F%E7%94%9F/%E9%9D%A2%E8%AF%95%E9%A2%98.html#在任意给定时间点指出一个-docker-容器可能存在的运行阶段" aria-label="在任意给定时间点指出一个 Docker 容器可能存在的运行阶段？"><!---->在任意给定时间点指出一个 Docker 容器可能存在的运行阶段？<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a class="route-link nav-link vp-sidebar-link vp-heading" href="/%E6%9E%B6%E6%9E%84/%E4%BA%91%E5%8E%9F%E7%94%9F/%E9%9D%A2%E8%AF%95%E9%A2%98.html#怎么获取一个-docker-容器运行状态" aria-label="怎么获取一个 Docker 容器运行状态？"><!---->怎么获取一个 Docker 容器运行状态？<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a class="route-link nav-link vp-sidebar-link vp-heading" href="/%E6%9E%B6%E6%9E%84/%E4%BA%91%E5%8E%9F%E7%94%9F/%E9%9D%A2%E8%AF%95%E9%A2%98.html#在-dockerfile-配置文件中最常用的指令有哪些" aria-label="在 Dockerfile 配置文件中最常用的指令有哪些？"><!---->在 Dockerfile 配置文件中最常用的指令有哪些？<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a class="route-link nav-link vp-sidebar-link vp-heading" href="/%E6%9E%B6%E6%9E%84/%E4%BA%91%E5%8E%9F%E7%94%9F/%E9%9D%A2%E8%AF%95%E9%A2%98.html#什么类型的应用-无状态性或有状态性-更适合-docker-容器技术" aria-label="什么类型的应用（无状态性或有状态性）更适合 Docker 容器技术？"><!---->什么类型的应用（无状态性或有状态性）更适合 Docker 容器技术？<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a class="route-link nav-link vp-sidebar-link vp-heading" href="/%E6%9E%B6%E6%9E%84/%E4%BA%91%E5%8E%9F%E7%94%9F/%E9%9D%A2%E8%AF%95%E9%A2%98.html#docker-应用流程概述" aria-label="Docker 应用流程概述"><!---->Docker 应用流程概述<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a class="route-link nav-link vp-sidebar-link vp-heading" href="/%E6%9E%B6%E6%9E%84/%E4%BA%91%E5%8E%9F%E7%94%9F/%E9%9D%A2%E8%AF%95%E9%A2%98.html#docker-image-和-docker-layer-层-有什么不同" aria-label="Docker Image 和 Docker Layer (层)有什么不同？"><!---->Docker Image 和 Docker Layer (层)有什么不同？<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a class="route-link nav-link vp-sidebar-link vp-heading" href="/%E6%9E%B6%E6%9E%84/%E4%BA%91%E5%8E%9F%E7%94%9F/%E9%9D%A2%E8%AF%95%E9%A2%98.html#虚拟化技术是什么" aria-label="虚拟化技术是什么？"><!---->虚拟化技术是什么？<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a class="route-link nav-link vp-sidebar-link vp-heading" href="/%E6%9E%B6%E6%9E%84/%E4%BA%91%E5%8E%9F%E7%94%9F/%E9%9D%A2%E8%AF%95%E9%A2%98.html#虚拟管理层-程序-是什么" aria-label="虚拟管理层（程序）是什么？"><!---->虚拟管理层（程序）是什么？<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a class="route-link nav-link vp-sidebar-link vp-heading" href="/%E6%9E%B6%E6%9E%84/%E4%BA%91%E5%8E%9F%E7%94%9F/%E9%9D%A2%E8%AF%95%E9%A2%98.html#docker-swarm是什么" aria-label="Docker Swarm是什么？"><!---->Docker Swarm是什么？<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a class="route-link nav-link vp-sidebar-link vp-heading" href="/%E6%9E%B6%E6%9E%84/%E4%BA%91%E5%8E%9F%E7%94%9F/%E9%9D%A2%E8%AF%95%E9%A2%98.html#监控-docker-应用的运行状态" aria-label="监控 Docker 应用的运行状态"><!---->监控 Docker 应用的运行状态<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a class="route-link nav-link vp-sidebar-link vp-heading" href="/%E6%9E%B6%E6%9E%84/%E4%BA%91%E5%8E%9F%E7%94%9F/%E9%9D%A2%E8%AF%95%E9%A2%98.html#什么是孤儿卷及如何删除它" aria-label="什么是孤儿卷及如何删除它？"><!---->什么是孤儿卷及如何删除它？<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a class="route-link nav-link vp-sidebar-link vp-heading" href="/%E6%9E%B6%E6%9E%84/%E4%BA%91%E5%8E%9F%E7%94%9F/%E9%9D%A2%E8%AF%95%E9%A2%98.html#什么是半虚拟化-paravirtualization" aria-label="什么是半虚拟化（Paravirtualization）？"><!---->什么是半虚拟化（Paravirtualization）？<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a class="route-link nav-link vp-sidebar-link vp-heading" href="/%E6%9E%B6%E6%9E%84/%E4%BA%91%E5%8E%9F%E7%94%9F/%E9%9D%A2%E8%AF%95%E9%A2%98.html#半虚拟化和全虚拟化的区别是什么-xen和kvm属于哪种" aria-label="半虚拟化和全虚拟化的区别是什么？ Xen和KVM属于哪种？"><!---->半虚拟化和全虚拟化的区别是什么？ Xen和KVM属于哪种？<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a class="route-link nav-link vp-sidebar-link vp-heading" href="/%E6%9E%B6%E6%9E%84/%E4%BA%91%E5%8E%9F%E7%94%9F/%E9%9D%A2%E8%AF%95%E9%A2%98.html#docker-技术与虚拟机技术有何不同" aria-label="Docker 技术与虚拟机技术有何不同？"><!---->Docker 技术与虚拟机技术有何不同？<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a class="route-link nav-link vp-sidebar-link vp-heading" href="/%E6%9E%B6%E6%9E%84/%E4%BA%91%E5%8E%9F%E7%94%9F/%E9%9D%A2%E8%AF%95%E9%A2%98.html#请解释一下-docerfile-配置文件中的-onbuild-指令的用途含义" aria-label="请解释一下 docerfile 配置文件中的 ONBUILD 指令的用途含义？"><!---->请解释一下 docerfile 配置文件中的 ONBUILD 指令的用途含义？<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a class="route-link nav-link vp-sidebar-link vp-heading" href="/%E6%9E%B6%E6%9E%84/%E4%BA%91%E5%8E%9F%E7%94%9F/%E9%9D%A2%E8%AF%95%E9%A2%98.html#有否在创建有状态性的-docker-应用的较好实践-最适合的场景有什么" aria-label="有否在创建有状态性的 Docker 应用的较好实践？最适合的场景有什么？"><!---->有否在创建有状态性的 Docker 应用的较好实践？最适合的场景有什么？<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a class="route-link nav-link vp-sidebar-link vp-heading" href="/%E6%9E%B6%E6%9E%84/%E4%BA%91%E5%8E%9F%E7%94%9F/%E9%9D%A2%E8%AF%95%E9%A2%98.html#在-windows-系统上可以运行原生的-docker-容器吗" aria-label="在 Windows 系统上可以运行原生的 Docker 容器吗？"><!---->在 Windows 系统上可以运行原生的 Docker 容器吗？<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a class="route-link nav-link vp-sidebar-link vp-heading" href="/%E6%9E%B6%E6%9E%84/%E4%BA%91%E5%8E%9F%E7%94%9F/%E9%9D%A2%E8%AF%95%E9%A2%98.html#在非-linux-操作系统平台上如何运行-docker" aria-label="在非 Linux 操作系统平台上如何运行 Docker ?"><!---->在非 Linux 操作系统平台上如何运行 Docker ?<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a class="route-link nav-link vp-sidebar-link vp-heading" href="/%E6%9E%B6%E6%9E%84/%E4%BA%91%E5%8E%9F%E7%94%9F/%E9%9D%A2%E8%AF%95%E9%A2%98.html#容器化技术在底层的运行原理" aria-label="容器化技术在底层的运行原理？"><!---->容器化技术在底层的运行原理？<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a class="route-link nav-link vp-sidebar-link vp-heading" href="/%E6%9E%B6%E6%9E%84/%E4%BA%91%E5%8E%9F%E7%94%9F/%E9%9D%A2%E8%AF%95%E9%A2%98.html#说说容器化技术与虚拟化技术的优缺点" aria-label="说说容器化技术与虚拟化技术的优缺点"><!---->说说容器化技术与虚拟化技术的优缺点<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a class="route-link nav-link vp-sidebar-link vp-heading" href="/%E6%9E%B6%E6%9E%84/%E4%BA%91%E5%8E%9F%E7%94%9F/%E9%9D%A2%E8%AF%95%E9%A2%98.html#如何使-docker-适应多种运行环境" aria-label="如何使 Docker 适应多种运行环境？"><!---->如何使 Docker 适应多种运行环境？<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a class="route-link nav-link vp-sidebar-link vp-heading" href="/%E6%9E%B6%E6%9E%84/%E4%BA%91%E5%8E%9F%E7%94%9F/%E9%9D%A2%E8%AF%95%E9%A2%98.html#为什么-docker-compose-采取的是并不等待前面依赖服务项的容器启动就绪后再启动的组合容器启动策略" aria-label="为什么 Docker compose 采取的是并不等待前面依赖服务项的容器启动就绪后再启动的组合容器启动策略？"><!---->为什么 Docker compose 采取的是并不等待前面依赖服务项的容器启动就绪后再启动的组合容器启动策略？<!----></a><ul class="vp-sidebar-sub-headers"></ul></li></ul><!--]--></li><li><section class="vp-sidebar-group"><button class="vp-sidebar-heading clickable" type="button"><!----><span class="vp-sidebar-title">核心知识点</span><span class="vp-arrow end"></span></button><!----></section></li></ul></section></li><li><section class="vp-sidebar-group"><button class="vp-sidebar-heading clickable" type="button"><!----><span class="vp-sidebar-title">分布式</span><span class="vp-arrow end"></span></button><!----></section></li><li><section class="vp-sidebar-group"><button class="vp-sidebar-heading clickable" type="button"><!----><span class="vp-sidebar-title">微服务</span><span class="vp-arrow end"></span></button><!----></section></li><li><section class="vp-sidebar-group"><button class="vp-sidebar-heading clickable" type="button"><!----><span class="vp-sidebar-title">运维</span><span class="vp-arrow end"></span></button><!----></section></li></ul></section></li></ul><!--[--><!----><!--]--></aside><!--[--><main id="main-content" class="vp-page"><!--[--><!--[--><!----><!--]--><!----><nav class="vp-breadcrumb disable"></nav><div class="vp-page-title"><h1><!---->容器技术面试题</h1><div class="page-info"><span class="page-author-info" aria-label="作者🖊" data-balloon-pos="down"><svg xmlns="http://www.w3.org/2000/svg" class="icon author-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="author icon"><path d="M649.6 633.6c86.4-48 147.2-144 147.2-249.6 0-160-128-288-288-288s-288 128-288 288c0 108.8 57.6 201.6 147.2 249.6-121.6 48-214.4 153.6-240 288-3.2 9.6 0 19.2 6.4 25.6 3.2 9.6 12.8 12.8 22.4 12.8h704c9.6 0 19.2-3.2 25.6-12.8 6.4-6.4 9.6-16 6.4-25.6-25.6-134.4-121.6-240-243.2-288z"></path></svg><span><a class="page-author-item" href="https://xiaobaidebug.top/" target="_blank" rel="noopener noreferrer">小白debug</a></span><span property="author" content="小白debug"></span></span><!----><span class="page-date-info" aria-label="写作日期📅" data-balloon-pos="down"><svg xmlns="http://www.w3.org/2000/svg" class="icon calendar-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="calendar icon"><path d="M716.4 110.137c0-18.753-14.72-33.473-33.472-33.473-18.753 0-33.473 14.72-33.473 33.473v33.473h66.993v-33.473zm-334.87 0c0-18.753-14.72-33.473-33.473-33.473s-33.52 14.72-33.52 33.473v33.473h66.993v-33.473zm468.81 33.52H716.4v100.465c0 18.753-14.72 33.473-33.472 33.473a33.145 33.145 0 01-33.473-33.473V143.657H381.53v100.465c0 18.753-14.72 33.473-33.473 33.473a33.145 33.145 0 01-33.473-33.473V143.657H180.6A134.314 134.314 0 0046.66 277.595v535.756A134.314 134.314 0 00180.6 947.289h669.74a134.36 134.36 0 00133.94-133.938V277.595a134.314 134.314 0 00-133.94-133.938zm33.473 267.877H147.126a33.145 33.145 0 01-33.473-33.473c0-18.752 14.72-33.473 33.473-33.473h736.687c18.752 0 33.472 14.72 33.472 33.473a33.145 33.145 0 01-33.472 33.473z"></path></svg><span><!----></span><meta property="datePublished" content="2024-04-02T01:07:51.000Z"></span><!----><span class="page-reading-time-info" aria-label="阅读时间⌛" data-balloon-pos="down"><svg xmlns="http://www.w3.org/2000/svg" class="icon timer-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="timer icon"><path d="M799.387 122.15c4.402-2.978 7.38-7.897 7.38-13.463v-1.165c0-8.933-7.38-16.312-16.312-16.312H256.33c-8.933 0-16.311 7.38-16.311 16.312v1.165c0 5.825 2.977 10.874 7.637 13.592 4.143 194.44 97.22 354.963 220.201 392.763-122.204 37.542-214.893 196.511-220.2 389.397-4.661 5.049-7.638 11.651-7.638 19.03v5.825h566.49v-5.825c0-7.379-2.849-13.981-7.509-18.9-5.049-193.016-97.867-351.985-220.2-389.527 123.24-37.67 216.446-198.453 220.588-392.892zM531.16 450.445v352.632c117.674 1.553 211.787 40.778 211.787 88.676H304.097c0-48.286 95.149-87.382 213.728-88.676V450.445c-93.077-3.107-167.901-81.297-167.901-177.093 0-8.803 6.99-15.793 15.793-15.793 8.803 0 15.794 6.99 15.794 15.793 0 80.261 63.69 145.635 142.01 145.635s142.011-65.374 142.011-145.635c0-8.803 6.99-15.793 15.794-15.793s15.793 6.99 15.793 15.793c0 95.019-73.789 172.82-165.96 177.093z"></path></svg><span>大约 26 分钟</span><meta property="timeRequired" content="PT26M"></span><!----><!----></div><hr></div><div class="toc-place-holder"><aside id="toc"><!--[--><!----><!--]--><div class="toc-header">此页内容<button type="button" class="print-button" title="打印"><svg xmlns="http://www.w3.org/2000/svg" class="icon print-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="print icon"><path d="M819.2 364.8h-44.8V128c0-17.067-14.933-32-32-32H281.6c-17.067 0-32 14.933-32 32v236.8h-44.8C145.067 364.8 96 413.867 96 473.6v192c0 59.733 49.067 108.8 108.8 108.8h44.8V896c0 17.067 14.933 32 32 32h460.8c17.067 0 32-14.933 32-32V774.4h44.8c59.733 0 108.8-49.067 108.8-108.8v-192c0-59.733-49.067-108.8-108.8-108.8zM313.6 160h396.8v204.8H313.6V160zm396.8 704H313.6V620.8h396.8V864zM864 665.6c0 25.6-19.2 44.8-44.8 44.8h-44.8V588.8c0-17.067-14.933-32-32-32H281.6c-17.067 0-32 14.933-32 32v121.6h-44.8c-25.6 0-44.8-19.2-44.8-44.8v-192c0-25.6 19.2-44.8 44.8-44.8h614.4c25.6 0 44.8 19.2 44.8 44.8v192z"></path></svg></button></div><div class="toc-wrapper"><ul class="toc-list"><!--[--><li class="toc-item"><a class="route-link toc-link level2" href="/#为什么需要-devops">为什么需要 DevOps</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="route-link toc-link level2" href="/#docker-是什么">Docker 是什么？</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="route-link toc-link level2" href="/#docker-与虚拟机有何不同">Docker 与虚拟机有何不同？</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="route-link toc-link level2" href="/#什么是-docker-镜像">什么是 Docker 镜像？</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="route-link toc-link level2" href="/#什么是-docker-容器">什么是 Docker 容器？</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="route-link toc-link level2" href="/#docker-容器有几种状态">Docker 容器有几种状态？</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="route-link toc-link level2" href="/#dockerfile-中最常见的指令是什么">Dockerfile 中最常见的指令是什么？</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="route-link toc-link level2" href="/#dockerfile-中的命令-copy-和-add-命令有什么区别">Dockerfile 中的命令 COPY 和 ADD 命令有什么区别？</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="route-link toc-link level2" href="/#解释一下-dockerfile-的-onbuild-指令">解释一下 Dockerfile 的 ONBUILD 指令？</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="route-link toc-link level2" href="/#什么是-docker-swarm">什么是 Docker Swarm？</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="route-link toc-link level2" href="/#如何在生产中监控-docker">如何在生产中监控 Docker？</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="route-link toc-link level2" href="/#devops-有哪些优势">DevOps 有哪些优势？</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="route-link toc-link level2" href="/#ci-服务有什么用途">CI 服务有什么用途？</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="route-link toc-link level2" href="/#如何使用-docker-技术创建与环境无关的容器系统">如何使用 Docker 技术创建与环境无关的容器系统？</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="route-link toc-link level2" href="/#dockerfile-配置文件中的-copy-和-add-指令有什么不同">Dockerfile 配置文件中的 COPY 和 ADD 指令有什么不同？</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="route-link toc-link level2" href="/#docker-映像-image-是什么">Docker 映像（image）是什么？</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="route-link toc-link level2" href="/#docker-容器-container-是什么">Docker 容器（container）是什么？</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="route-link toc-link level2" href="/#docker-hub-是什么">Docker hub 是什么？</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="route-link toc-link level2" href="/#在任意给定时间点指出一个-docker-容器可能存在的运行阶段">在任意给定时间点指出一个 Docker 容器可能存在的运行阶段？</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="route-link toc-link level2" href="/#怎么获取一个-docker-容器运行状态">怎么获取一个 Docker 容器运行状态？</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="route-link toc-link level2" href="/#在-dockerfile-配置文件中最常用的指令有哪些">在 Dockerfile 配置文件中最常用的指令有哪些？</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="route-link toc-link level2" href="/#什么类型的应用-无状态性或有状态性-更适合-docker-容器技术">什么类型的应用（无状态性或有状态性）更适合 Docker 容器技术？</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="route-link toc-link level2" href="/#docker-应用流程概述">Docker 应用流程概述</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="route-link toc-link level2" href="/#docker-image-和-docker-layer-层-有什么不同">Docker Image 和 Docker Layer (层)有什么不同？</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="route-link toc-link level2" href="/#虚拟化技术是什么">虚拟化技术是什么？</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="route-link toc-link level2" href="/#虚拟管理层-程序-是什么">虚拟管理层（程序）是什么？</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="route-link toc-link level2" href="/#docker-swarm是什么">Docker Swarm是什么？</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="route-link toc-link level2" href="/#监控-docker-应用的运行状态">监控 Docker 应用的运行状态</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="route-link toc-link level2" href="/#什么是孤儿卷及如何删除它">什么是孤儿卷及如何删除它？</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="route-link toc-link level2" href="/#什么是半虚拟化-paravirtualization">什么是半虚拟化（Paravirtualization）？</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="route-link toc-link level2" href="/#半虚拟化和全虚拟化的区别是什么-xen和kvm属于哪种">半虚拟化和全虚拟化的区别是什么？ Xen和KVM属于哪种？</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="route-link toc-link level2" href="/#docker-技术与虚拟机技术有何不同">Docker 技术与虚拟机技术有何不同？</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="route-link toc-link level2" href="/#请解释一下-docerfile-配置文件中的-onbuild-指令的用途含义">请解释一下 docerfile 配置文件中的 ONBUILD 指令的用途含义？</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="route-link toc-link level2" href="/#有否在创建有状态性的-docker-应用的较好实践-最适合的场景有什么">有否在创建有状态性的 Docker 应用的较好实践？最适合的场景有什么？</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="route-link toc-link level2" href="/#在-windows-系统上可以运行原生的-docker-容器吗">在 Windows 系统上可以运行原生的 Docker 容器吗？</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="route-link toc-link level2" href="/#在非-linux-操作系统平台上如何运行-docker">在非 Linux 操作系统平台上如何运行 Docker ?</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="route-link toc-link level2" href="/#容器化技术在底层的运行原理">容器化技术在底层的运行原理？</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="route-link toc-link level2" href="/#说说容器化技术与虚拟化技术的优缺点">说说容器化技术与虚拟化技术的优缺点</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="route-link toc-link level2" href="/#如何使-docker-适应多种运行环境">如何使 Docker 适应多种运行环境？</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="route-link toc-link level2" href="/#为什么-docker-compose-采取的是并不等待前面依赖服务项的容器启动就绪后再启动的组合容器启动策略">为什么 Docker compose 采取的是并不等待前面依赖服务项的容器启动就绪后再启动的组合容器启动策略？</a></li><!----><!--]--></ul><div class="toc-marker" style="top:-1.7rem;"></div></div><!--[--><!----><!--]--></aside></div><!--[--><!----><!--]--><div class="theme-hope-content"><h1 id="容器技术面试题" tabindex="-1"><a class="header-anchor" href="#容器技术面试题"><span><strong>容器技术面试题</strong></span></a></h1><h2 id="为什么需要-devops" tabindex="-1"><a class="header-anchor" href="#为什么需要-devops"><span>为什么需要 DevOps</span></a></h2><p>在微服务架构大背景下，原来的单体服务被越拆越小，每个服务都需要完整经历编译，构建，发布等流程，非常繁琐。<br> 为了解决这个痛点，就需要用到DevOps。<br> DevOps 是一种软件开发和运维的文化和实践方法。落地到实践中，大概率就是一个基于k8s的服务管理平台。<br> 程序员直接在界面上点点几下，就能完成服务的构建部署和扩容等操作。</p><p>具体来说，DevOps有以下几个优点：</p><ul><li><p>增加软件布署的频率</p></li><li><p>降低新发布版本的失败率</p></li><li><p>缩短修复缺陷的交付时间</p></li><li><p>加快解决版本冲突的问题</p></li></ul><p>从更高维度来说，DevOps 可以降低运维的成本，增加开发自个部署运维服务的效率，同时也能保证较高的服务质量。真降本增效神器。</p><h2 id="docker-是什么" tabindex="-1"><a class="header-anchor" href="#docker-是什么"><span>Docker 是什么？</span></a></h2><p>Docker 本质上就是一个将<strong>程序和环境打包并运行</strong>的工具软件。具体点来说就是，它通过 Dockerfile 描述环境和应用程序的依赖关系， docker build 构建镜像， docker pull/push 跟 Docker Registry 交互实现存储和分发镜像，docker run 命令基于镜像启动容器，基于容器技术运行程序和它对应的环境，从而解决环境依赖导致的各种问题。<br><a href="/%E6%9E%B6%E6%9E%84/%E4%BA%91%E5%8E%9F%E7%94%9F/%E6%A0%B8%E5%BF%83%E7%9F%A5%E8%AF%86%E7%82%B9/docker%E6%98%AF%E4%BB%80%E4%B9%88docker%E5%92%8Ckubernetes(k8s)%E4%B9%8B%E9%97%B4%E6%98%AF%E4%BB%80%E4%B9%88%E5%85%B3%E7%B3%BB%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB">Docker 是什么</a></p><h2 id="docker-与虚拟机有何不同" tabindex="-1"><a class="header-anchor" href="#docker-与虚拟机有何不同"><span>Docker 与虚拟机有何不同？</span></a></h2><p><strong>Docker容器</strong>是不是很像我们用 vmware 或 kvm 整出来的<strong>传统虚拟机</strong>？<br> 但不同的是，传统虚拟机自带一个完整操作系统，而容器本身不带完整操作系统，容器的基础镜像实际上只包含了操作系统的核心依赖库和配置文件等必要组件。<br> 它利用一个叫 <strong>Namespace</strong> 的能力让它看起来就像是一个独立操作系统一样。再利用一个叫 <strong>Cgroup</strong> 的能力限制它能使用的计算资源。</p><figure><img src="https://cdn.xiaobaidebug.top/1711882143210.jpeg" alt="Docker和虚拟机的区别" tabindex="0" loading="lazy"><figcaption>Docker和虚拟机的区别</figcaption></figure><p>所以说，容器本质上只是个自带独立运行环境的<strong>特殊进程</strong>，底层用的其实是<strong>宿主机的操作系统内核</strong>。</p><figure><img src="https://cdn.xiaobaidebug.top/1711882187702.jpeg" alt="容器本质是一个特殊进程" tabindex="0" loading="lazy"><figcaption>容器本质是一个特殊进程</figcaption></figure><p>参考：<a href="/%E6%9E%B6%E6%9E%84/%E4%BA%91%E5%8E%9F%E7%94%9F/%E6%A0%B8%E5%BF%83%E7%9F%A5%E8%AF%86%E7%82%B9/docker%E6%98%AF%E4%BB%80%E4%B9%88docker%E5%92%8Ckubernetes(k8s)%E4%B9%8B%E9%97%B4%E6%98%AF%E4%BB%80%E4%B9%88%E5%85%B3%E7%B3%BB%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB">Docker 是什么</a></p><h2 id="什么是-docker-镜像" tabindex="-1"><a class="header-anchor" href="#什么是-docker-镜像"><span>什么是 Docker 镜像？</span></a></h2><p>Docker 镜像是 Docker 容器的源代码，Docker 镜像用于创建容器。使用build 命令创建镜像。</p><h2 id="什么是-docker-容器" tabindex="-1"><a class="header-anchor" href="#什么是-docker-容器"><span>什么是 Docker 容器？</span></a></h2><p>Docker 容器包括应用程序及其所有依赖项，作为操作系统的独立进程运行。</p><h2 id="docker-容器有几种状态" tabindex="-1"><a class="header-anchor" href="#docker-容器有几种状态"><span>Docker 容器有几种状态？</span></a></h2><p>四种状态：运行、已暂停、重新启动、已退出。</p><h2 id="dockerfile-中最常见的指令是什么" tabindex="-1"><a class="header-anchor" href="#dockerfile-中最常见的指令是什么"><span>Dockerfile 中最常见的指令是什么？</span></a></h2><p>FROM：指定基础镜像</p><p>LABEL：功能是为镜像指定标签</p><p>RUN：运行指定的命令CMD：容器启动时要运行的命令</p><h2 id="dockerfile-中的命令-copy-和-add-命令有什么区别" tabindex="-1"><a class="header-anchor" href="#dockerfile-中的命令-copy-和-add-命令有什么区别"><span>Dockerfile 中的命令 COPY 和 ADD 命令有什么区别？</span></a></h2><p>COPY 与 ADD 的区别： COPY 的 SRC 只能是本地文件，其他用法一致。</p><h2 id="解释一下-dockerfile-的-onbuild-指令" tabindex="-1"><a class="header-anchor" href="#解释一下-dockerfile-的-onbuild-指令"><span>解释一下 Dockerfile 的 ONBUILD 指令？</span></a></h2><p>当镜像用作另一个镜像构建的基础时，ONBUILD 指令向镜像添加将在稍后执行的触发指令。如果要构建将用作构建其他镜像的基础的镜像（例如，可以使用特定于用户的配置自定义的应用程序构建环境或守护程序），这将非常有用。</p><h2 id="什么是-docker-swarm" tabindex="-1"><a class="header-anchor" href="#什么是-docker-swarm"><span>什么是 Docker Swarm？</span></a></h2><p>Docker Swarm 是 Docker 的本机群集。它将 Docker 主机池转变为单个虚拟Docker 主机。Docker Swarm 提供标准的 Docker API，任何已经与 Docker守护进程通信的工具都可以使用 Swarm 透明地扩展到多个主机。</p><h2 id="如何在生产中监控-docker" tabindex="-1"><a class="header-anchor" href="#如何在生产中监控-docker"><span>如何在生产中监控 Docker？</span></a></h2><p>Docker 提供 docker stats 和 docker 事件等工具来监控生产中的 Docker。我们可以使用这些命令获取重要统计数据的报告。</p><p>Docker 统计数据：当我们使用容器 ID 调用 docker stats 时，我们获得容器的CPU，内存使用情况等。它类似于 Linux 中的 top 命令。</p><p>Docker 事件：Docker 事件是一个命令，用于查看 Docker 守护程序中正在进</p><p>行的活动流。</p><p>一些常见的 Docker 事件：attach，commit，die，detach，rename，</p><p>destroy 等。我们还可以使用各种选项来限制或过滤我们感兴趣的事件。</p><h2 id="devops-有哪些优势" tabindex="-1"><a class="header-anchor" href="#devops-有哪些优势"><span>DevOps 有哪些优势？</span></a></h2><p>技术优势: 持续的软件交付能力修复问题变得简单更快得解决问题</p><p>商业优势: 更快交付的特性，更稳定的操作系统环境更多时间可用于创造价值(而不是修复/维护)</p><h2 id="ci-服务有什么用途" tabindex="-1"><a class="header-anchor" href="#ci-服务有什么用途"><span>CI 服务有什么用途？</span></a></h2><p>CI （Continuous Integration）--持续集成服务--主要用于整合团队开发中不同开发者提交到开发仓库中的项目代码变化，并即时整合编译，检查整合编译错误的服务。它需要一天中多次整合编译代码的能力，若出现整合错误，可以优异地准确定位提交错误源。</p><h2 id="如何使用-docker-技术创建与环境无关的容器系统" tabindex="-1"><a class="header-anchor" href="#如何使用-docker-技术创建与环境无关的容器系统"><span>如何使用 Docker 技术创建与环境无关的容器系统？</span></a></h2><p>Docker 技术有三中主要的技术途径辅助完成此需求：存储卷（Volumes）</p><p>环境变量（Environment variable）注入</p><p>只读（Read-only）文件系统</p><h2 id="dockerfile-配置文件中的-copy-和-add-指令有什么不同" tabindex="-1"><a class="header-anchor" href="#dockerfile-配置文件中的-copy-和-add-指令有什么不同"><span>Dockerfile 配置文件中的 COPY 和 ADD 指令有什么不同？</span></a></h2><p>虽然 ADD 和 COPY 功能相似，推荐 COPY 。</p><p>那是因为 COPY 比 ADD 更直观易懂。 COPY 只是将本地文件拷入容器这么简单，而 ADD 有一些其它特性功能（诸如，本地归档解压和支持远程网址访问等），这些特性在指令本身体现并不明显。因此，有必要使用 ADD 指令的最好例子是需要在本地自动解压归档文件到容器中的情况，如 ADD rootfs.tar.xz 。</p><h2 id="docker-映像-image-是什么" tabindex="-1"><a class="header-anchor" href="#docker-映像-image-是什么"><span>Docker 映像（image）是什么？</span></a></h2><p>Docker image 是 Docker 容器的源。换言之，Docker images 用于创建 Docker 容器（containers）。映像（Images）通过 Docker build 命令创建，当 run 映像时，它启动成一个容器（container）进程。做好的映像由于可能非常庞大，常注册存储在诸如 <a href="http://registry.hub.docker.com" target="_blank" rel="noopener noreferrer">registry.hub.docker.com<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a> 这样的公共平台上。映像常被分层设计，每层可单独成为一个小映像，由多层小映像再构成大映像，这样碎片化的设计为了使映像在互联网上共享时，最小化传输数据需求。</p><h2 id="docker-容器-container-是什么" tabindex="-1"><a class="header-anchor" href="#docker-容器-container-是什么"><span>Docker 容器（container）是什么？</span></a></h2><p>Docker containers -- Docker 容器--是包含其所有运行依赖环境，但与其它容器共享操作系统内核的应用，它运行在独立的主机操作系统用户空间进程中。Docker 容器并不紧密依赖特定的基础平台：可运行在任何配置的计算机，任何平台以及任何云平台上。</p><h2 id="docker-hub-是什么" tabindex="-1"><a class="header-anchor" href="#docker-hub-是什么"><span>Docker hub 是什么？</span></a></h2><p>Docker hub 是云基础的 Docker 注册服务平台，它允许用户进行访问 Docker 中心资源库，创建自己的 Docker 映像并测试，推送并存储创建好的 Docker 映像，连接 Docker 云平台将已创建好的指定 Docker 映像布署到本地主机等任务。它提供了一个查找发现 Docker 映像，发布 Docker 映像及控制变化升级的资源中心，成为用户组或团队协作开发中保证自动化开发流程的有效技术途径。</p><h2 id="在任意给定时间点指出一个-docker-容器可能存在的运行阶段" tabindex="-1"><a class="header-anchor" href="#在任意给定时间点指出一个-docker-容器可能存在的运行阶段"><span>在任意给定时间点指出一个 Docker 容器可能存在的运行阶段？</span></a></h2><p>在任意时间点，一个 Docker 容器可能存在以下运行阶段：</p><p>运行中（Running）已暂停（Paused）重启中（Restarting）</p><p>已退出（Exited）</p><h2 id="怎么获取一个-docker-容器运行状态" tabindex="-1"><a class="header-anchor" href="#怎么获取一个-docker-容器运行状态"><span>怎么获取一个 Docker 容器运行状态？</span></a></h2><p>使用如下命令行命令确定一个 Docker 容器的运行状态</p><div class="language-text line-numbers-mode" data-ext="text" data-title="text"><pre class="language-text"><code>$ docker ps –a 
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>这将列表形式输出运行在主机上的所有 Docker 容器及其运行状态。从这个列表中很容易找到想要的容器及其运行状态。</p><h2 id="在-dockerfile-配置文件中最常用的指令有哪些" tabindex="-1"><a class="header-anchor" href="#在-dockerfile-配置文件中最常用的指令有哪些"><span>在 Dockerfile 配置文件中最常用的指令有哪些？</span></a></h2><p>一些最常用的指令如下：</p><p>FROM：使用 FROM 为后续的指令建立基础映像。在所有有效的 Dockerfile 中， FROM 是第一条指令。</p><p>LABEL：LABEL 指令用于组织项目映像，模块，许可等。在自动化布署方面 LABEL 也有很大用途。在 LABEL 中指定一组键值对，可用于程序化配置或布署 Docker 。</p><p>RUN：RUN 指令可在映像当前层执行任何命令并创建一个新层，用于在映像层中添加功能层，也许最来的层会依赖它。</p><p>CMD：使用 CMD 指令为执行的容器提供默认值。在 Dockerfile 文件中，若添加多个 CMD 指令，只有最后的 CMD 指令运行。</p><h2 id="什么类型的应用-无状态性或有状态性-更适合-docker-容器技术" tabindex="-1"><a class="header-anchor" href="#什么类型的应用-无状态性或有状态性-更适合-docker-容器技术"><span>什么类型的应用（无状态性或有状态性）更适合 Docker 容器技术？</span></a></h2><p>对于 Docker 容器创建无状态性（Stateless）的应用更可取。通过从应用项目中将与状态相关的信息及配置提取掉，我们可以在项目环境外建立不依赖项目环境的 Docker 容器。这样，我们可以在任意产品中运行同一容器，只需根据产品需要像问&amp;答（QA）一样给其配置环境即可。这帮助我们在不同场景重用相同的 Docker 映像。另外，使用无状态性（Stateless）容器应用相比有状态性（Stateful）容器应用更具伸缩性，也容易创建。</p><h2 id="docker-应用流程概述" tabindex="-1"><a class="header-anchor" href="#docker-应用流程概述"><span>Docker 应用流程概述</span></a></h2><p>Docker 应用的构建始于 Dockerfile，这是一个脚本文本，定义了如何构建 Docker 镜像。Dockerfile 相当于 Docker 镜像的构建蓝图。</p><p>准备好 Dockerfile 后，我们可以通过构建过程来生成 Docker 镜像。镜像是 Dockerfile 内容的编译结果，它包含了运行应用所需的所有内容。构建完成后，镜像可以被推送到镜像仓库（registry），这是一个集中存放和分发镜像的服务，类似于代码版本控制系统中的 Git 仓库。</p><p>有了镜像之后，就可以从中启动容器（containers）。容器是镜像的运行实例，它们提供了与虚拟机类似的隔离环境，但更加轻量级，因为它们直接运行在宿主机的操作系统上，无需额外的虚拟机管理程序。这样，容器能够在保持应用隔离性的同时，提高资源的利用效率。</p><h2 id="docker-image-和-docker-layer-层-有什么不同" tabindex="-1"><a class="header-anchor" href="#docker-image-和-docker-layer-层-有什么不同"><span>Docker Image 和 Docker Layer (层)有什么不同？</span></a></h2><p>Image：一个 Docker Image 是由一系列 Docker 只读层（read-only Layer）创建出来的。</p><p>Layer：在 Dockerfile 配置文件中完成的一条配置指令，即表示一个 Docker 层（Layer）。</p><p>如下 Dockerfile 文件包含4 条指令，每条指令创建一个层（Layer）。</p><div class="language-text line-numbers-mode" data-ext="text" data-title="text"><pre class="language-text"><code>FROM ubuntu:15.04 

COPY ./app 

RUN make /app 

CMD python /app/app.py
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>重点，每层只对其前一层进行一（某）些进化。</p><h2 id="虚拟化技术是什么" tabindex="-1"><a class="header-anchor" href="#虚拟化技术是什么"><span>虚拟化技术是什么？</span></a></h2><p>最初的构想，virtualisation（虚拟化）被认为是逻辑划分大型主机使得多个应用可以并行运行的一种技术方案。然而，随着技术公司及开源社区的推进，现实发生了戏剧性的转变，以致产生了以一种或某种方式操作特权指令可以在单台基于 x86 硬件的系统上同时运行多个（种）操作系统的技术。</p><p>实质的效果是，虚拟化技术允许你在一个硬件平台下运行2 个完全不同的操作系统。每个客户操作系统可完成像系统自检、启动、载入系统内核等像在独立硬件上的一切动作。同时也具备坚实的安全基础，例如，客户操作系统不能获取完全访问主机或其它客户系统的权限，及其它涉及安全，可能把系统搞坏的操作。</p><p>基于对客户操作系统虚拟硬件、运行环境模拟方法的不同，对虚拟化技术进行分类，主要的有如下3 种虚拟化技术种类：</p><ul><li>全模拟（Emulation）</li><li>半虚拟（Paravirtualization）</li><li>基于容器的虚拟化（Container-based virtualization）</li></ul><h2 id="虚拟管理层-程序-是什么" tabindex="-1"><a class="header-anchor" href="#虚拟管理层-程序-是什么"><span>虚拟管理层（程序）是什么？</span></a></h2><p>hypervisor --虚拟管理层（程序）--负责创建客户虚拟机系统运行所需虚拟硬件环境。它监管客户虚拟操作系统的运行，并为客户系统提供必要的运行资源，保证客户虚拟系统的运行。虚拟管理层（程序）驻留在物理主机系统和虚拟客户系统之间，为虚拟客户系统提供必要的虚拟服务。如何理解它，它侦听运行在虚拟机中的客户操作系统的操作并在主机操作系统中模拟客户操作系统所需硬件资源请求。满足客户机的运行需求。</p><p>虚拟化技术的快速发展，主要在云平台，由于在虚拟管理程序的帮助下，可允许在单台物理服务器上生成多个虚拟服务器，驱动着虚拟化技术快速发展及广泛应用。诸如， Xen，VMware，KVM 等，以及商业化的处理器硬件生产厂商也加入在硬件层面支持虚拟化技术的支持。诸如，Intel 的 VT 和 AMD-V 。</p><h2 id="docker-swarm是什么" tabindex="-1"><a class="header-anchor" href="#docker-swarm是什么"><span>Docker Swarm是什么？</span></a></h2><p>Docker Swarm 是 Docker 的内置集群管理功能，它允许用户将多台 Docker 主机整合成一个单一的虚拟主机。通过 Docker Swarm，用户可以利用标准的 Docker API 和通信工具，轻松地扩展 Docker 主机到多个物理或虚拟主机上，实现服务的高可用性和扩展性。</p><p>Docker 解决的是<strong>一个容器</strong>的部署。<br> Docker Compose 解决的是<strong>多个容器组成的一整套服务</strong>的部署。<br> 那 Docker Swarm 就更高维度了，它解决的其实是这一整套服务<strong>在多台服务器上的集群部署</strong>问题。<br> 比如在 A 服务器坏了，就将服务在 B 服务器上重新部署一套，实现迁移，还能根据需要对服务做扩缩容。</p><figure><img src="https://cdn.xiaobaidebug.top/1711882476662.jpeg" alt="Docker swarm是什么" tabindex="0" loading="lazy"><figcaption>Docker swarm是什么</figcaption></figure><h2 id="监控-docker-应用的运行状态" tabindex="-1"><a class="header-anchor" href="#监控-docker-应用的运行状态"><span>监控 Docker 应用的运行状态</span></a></h2><p>Docker 提供了一系列工具，帮助用户监控和了解容器的运行状况。这些工具可以通过命令行界面获取容器的性能指标和事件日志，从而对 Docker 容器进行有效的监控和管理。</p><ul><li>Docker Stats：这个命令可以实时显示指定容器的性能数据，如 CPU 和内存使用情况，类似于 Linux 系统中的 <code>top</code> 命令，帮助用户了解容器的资源消耗。</li><li>Docker Events：此命令用于实时查看 Docker 容器的活动事件流。用户可以通过它来监控容器的各种状态变化，如创建、启动、停止等。</li></ul><p>Docker 事件包括但不限于以下类型：</p><ul><li><code>attach</code>：容器被关联。</li><li><code>commit</code>：容器配置被提交为新的镜像。</li><li><code>die</code>：容器异常退出。</li><li><code>detach</code>：容器被取消关联。</li><li><code>rename</code>：容器名称被更改。</li><li><code>destroy</code>：容器被销毁。</li></ul><p>用户还可以通过添加不同的选项来过滤和查找特定的事件信息，以便更精确地监控 Docker 容器的行为。</p><h2 id="什么是孤儿卷及如何删除它" tabindex="-1"><a class="header-anchor" href="#什么是孤儿卷及如何删除它"><span>什么是孤儿卷及如何删除它？</span></a></h2><p>孤儿卷是未与任何容器关联的卷。在 Docker v。1.9 之前的版本中，删除这些孤儿卷存在很大问题。</p><h2 id="什么是半虚拟化-paravirtualization" tabindex="-1"><a class="header-anchor" href="#什么是半虚拟化-paravirtualization"><span>什么是半虚拟化（Paravirtualization）？</span></a></h2><p>半虚拟化（Paravirtualization）是一种高效的虚拟化技术，它并不直接运行在物理硬件或裸机之上，而是运行在虚拟机监控器（hypervisor）之上。这种技术通过修改客户操作系统的内核，使其能够与虚拟化层进行协作，从而实现高效的虚拟化性能。这种技术的一个显著特点是其对系统资源的占用相对较低，因为它旨在高效地利用资源，而不是消耗大量系统能力。</p><p>半虚拟化技术的主要优势在于，由于对客户操作系统进行了修改，使其能够与虚拟层进行协作，因此可以实现对硬件资源的更有效的访问和管理。这种方法避免了全虚拟化技术中常见的性能开销，因为它减少了对硬件模拟的依赖。</p><p>在半虚拟化环境中，一些知名的实现包括 Xen。Xen 通过提供接近原生的性能，使得半虚拟化成为了对性能要求较高的应用场景的理想选择。</p><blockquote><p>需要注意的是，KVM（Kernel-based Virtual Machine）实际上是一种基于硬件辅助的全虚拟化技术，而不是半虚拟化技术。</p></blockquote><figure><img src="https://cdn.jsdelivr.net/gh/xiaobaiTech/image/Aspose.Words.51b43265-f45e-4206-a945-0b7c10078cb5.028.jpeg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><h2 id="半虚拟化和全虚拟化的区别是什么-xen和kvm属于哪种" tabindex="-1"><a class="header-anchor" href="#半虚拟化和全虚拟化的区别是什么-xen和kvm属于哪种"><span>半虚拟化和全虚拟化的区别是什么？ Xen和KVM属于哪种？</span></a></h2><p>半虚拟化（Paravirtualization）和全虚拟化（Full Virtualization）是虚拟化技术的两种主要类型。这两种类型的主要区别在于它们如何处理操作系统和底层硬件之间的交互。</p><ul><li><p>全虚拟化：在全虚拟化中，虚拟机监视器（Hypervisor）提供一个完全模拟的硬件环境给每个虚拟机，每个虚拟机都认为自己是唯一控制硬件的系统。这使得虚拟机可以运行没有经过修改的操作系统。全虚拟化的优点是可以支持更广泛的操作系统，但缺点是性能可能会受到影响，因为需要对硬件访问进行模拟。</p></li><li><p>半虚拟化：在半虚拟化中，虚拟机和虚拟机监视器之间有一种更紧密的合作关系。虚拟机知道自己是在虚拟环境中运行，因此，操作系统需要进行一些修改以适应这种环境。这种方式可以提高性能，因为它可以避免一些模拟硬件的开销。然而，这种方法的缺点是它需要对操作系统进行修改，这可能限制了它能够支持的操作系统的种类。</p></li></ul><p>至于 Xen 和 KVM，它们都是虚拟化技术，但属于不同的类型。</p><p>Xen：Xen 是一种半虚拟化和全虚拟化技术的混合。它最初是作为半虚拟化技术开发的，意味着它需要操作系统进行一些修改才能在 Xen 上运行。然而，随着硬件支持的增加，Xen 也可以提供全虚拟化。</p><p>KVM：KVM（Kernel-based Virtual Machine）是一种全虚拟化技术。它是 Linux 内核的一部分，可以让 Linux 内核充当虚拟机监视器。KVM 可以运行多种未经修改的操作系统，包括 Windows 和各种 Linux 发行版。</p><h2 id="docker-技术与虚拟机技术有何不同" tabindex="-1"><a class="header-anchor" href="#docker-技术与虚拟机技术有何不同"><span>Docker 技术与虚拟机技术有何不同？</span></a></h2><p>Docker 不是严格意义上的虚拟化硬件的技术。它依赖 container-based virtualization（基于容器的虚拟化）的技术实现工具，或可以认为它是操作系统用户运行级别的虚拟化。因此， Docker 最初使用 LXC 驱动它，后来移至由 libcontainer 基础库驱动它，现已更名为 runc 。 Docker 主要致力于应用容器内的应用程序的自动化部署。应用容器设计用于包装和运行单一服务，而操作系统设计用于运行多进程任务，提供多种运算服务的能力。如虚拟机中等同完全操作系统的能力。因此，Docker 被认为是容器化系统上管理容器及应用容器化的布署工具。</p><figure><img src="/assets/image/docs/Aspose.Words.51b43265-f45e-4206-a945-0b7c10078cb5.029.jpeg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><ul><li>与虚拟机不同，容器无需启动操作系统内核，因此，容器可在不到1 秒钟时间内运行起来。这个特性，使得容器化技术比其它虚拟化技术更具有独特性及可取性。</li><li>由于容器化技术很少或几乎不给主机系统增加负载，因此，基于容器的虚拟化技术具有近乎原生的性能表现。</li><li>基于容器的虚拟化，与其他硬件虚拟化不同，运行时不需要其他额外的虚拟管理层软件。</li><li>主机上的所有容器共享主机操作系统上的进程调度，从而节省了额外的资源的需求。</li><li>与虚拟机 image 相比，容器（Docker 或 LXC images）映像较小，因此，容器映像易于分发。</li><li>容器中的资源分配由 Cgroups 实现。 Cgroup 不会让容器占用比给它们分配的更多的资源。但是，现在其它的虚拟化技术，对于虚拟机，主机的所有资源都可见，但无法使用。这可以通过在容器和主机上同时运行 top 或 htop 来观察到。在两个环境中的输出看起来相同。</li></ul><h2 id="请解释一下-docerfile-配置文件中的-onbuild-指令的用途含义" tabindex="-1"><a class="header-anchor" href="#请解释一下-docerfile-配置文件中的-onbuild-指令的用途含义"><span>请解释一下 docerfile 配置文件中的 ONBUILD 指令的用途含义？</span></a></h2><p>配置文件中的 ONBUILD 指令为创建的 Docker image （映像）加入在将来执行的指令（译注：在当前配置文件生成的映像中并不执行），用于在以这个创建的映像为基础的创建的子映像（image）中执行或定制。举例，以基映像创建自己的映像时，可定制创建特有的用户化的配置环境。</p><ul><li>译注：由于原文较短，关于这个问题容易迷惑。译者认为，总体来说关键理解--以基础映像创建自有的映像过程中，基础映像中所有的创建层或指令是以整体或固化的方式导入自有映像中的，自有映像是不能对这个过程进行自有定制。而 ONBUILD 指令提供了将某些层从基础映像中剥离出来提供给之后以自有映像为基础映像派生新的映像的可定制途径。这对发布映像而普适在不同的运行环境定制非常有用。不当之处，请指正！）</li></ul><h2 id="有否在创建有状态性的-docker-应用的较好实践-最适合的场景有什么" tabindex="-1"><a class="header-anchor" href="#有否在创建有状态性的-docker-应用的较好实践-最适合的场景有什么"><span>有否在创建有状态性的 Docker 应用的较好实践？最适合的场景有什么？</span></a></h2><p>有状态性 Docker 应用的问题关键在于状态数据保存在哪儿的问题。若所有数据保存在容器内，当更新软件版本或想将 Docker 容器移到其它机器上时，找回这些在运行中产生的状态数据将非常困难。</p><p>您需要做的是将这些表达运行状态的数据保存在永久卷中。参考如下3 种模式。</p><figure><img src="/assets/image/docs/Aspose.Words.51b43265-f45e-4206-a945-0b7c10078cb5.030.jpeg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>译注：</p><p>1 图中文字：数据保存在容器中，当容器停止运行时，运行状态数据丢失！</p><p>2 图中文字：数据保存在主机卷（Host Volume）中，当主机停机时，运行状态数据将无法访问</p><p>3 图中文字：数据保存在网络文件系统卷中，数据访问不依赖容器的运行与主机的运行</p><p>若您使用：docker run -v hostFolder:/containerfolder 命令运行您的容器，容器运行中任何对/containerfolder 目录下数据的改变，将永久保存在主机的 hostfolder 目录下。使用网络文件系统（nfs）与此类似。那样您就可以运行您的容器在任何主机上且其运行状态数据被保存在网络文件系统上。</p><h2 id="在-windows-系统上可以运行原生的-docker-容器吗" tabindex="-1"><a class="header-anchor" href="#在-windows-系统上可以运行原生的-docker-容器吗"><span>在 Windows 系统上可以运行原生的 Docker 容器吗？</span></a></h2><p>在&#39;Windows Server 2016&#39;系统上，你可以运行 Windows 的原生容器，微软推出其映像是&#39;Windows Nano Server&#39;，一个轻量级的运行在容器中的 Windows 原生系统。<a href="http://xn--fiq0i9is4gn7dqpgcsbe2z6xfg13g.NET" target="_blank" rel="noopener noreferrer">您可以在其中布署基于.NET<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a> 的应用。</p><p>译注：结合 Docker 的基本技术原理，参考后面的问题26 和问题27，可推测，微软在系统内核上开发了对 Docker 的支持，支持其闭源系统的容器化虚拟技术。但译者认为， Windows 系统本就是闭源紧耦合的系统，<a href="http://xn--fhqg92h63bgwpjsdy26ahdv626a.NET" target="_blank" rel="noopener noreferrer">好像你在本机上不装.NET<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a> 组件，各应用能很好运行似的。何必再弄个容器，浪费资源。这只是译者自己之孔见，想喷就喷！另： Windows Server 2016 版本之后的都可支持这种原生 Docker 技术，如 Windows Server 2018 版。</p><h2 id="在非-linux-操作系统平台上如何运行-docker" tabindex="-1"><a class="header-anchor" href="#在非-linux-操作系统平台上如何运行-docker"><span>在非 Linux 操作系统平台上如何运行 Docker ?</span></a></h2><p>容器化虚拟技术概念可能来源于，在 Linux 内核版本2.6.24 上加入的对命名空间（ namespace）的技术支持特性。容器化进程加入其进程 ID 到其创建的每个进程上并且对每个进程中的系统级调用进行访问控制及审查。其本身是由系统级调用 clone ()克隆出来的进程，允许其创建属于自己命名空间的进程实例，而区别于之前的，归属与整个本机系统的进程实例。</p><p>如果上述在 Linux 系统内核上的技术实现成为可能，那么明显的问题是如何在非 Linux 系统上运行容器化的 Docker 。过去， Mac 和 Windows 系统上运行 Docker 容器都使用 Linux 虚拟机（VMs）技术， Docker 工具箱使用的容器运行在 Virtual Box 虚拟机上。现在，最新的情况是， Windows 平台上使用的是 Hyper-V 产品技术，Mac 平台上使用的是 Hypervisor.framework （框架）产品技术。</p><h2 id="容器化技术在底层的运行原理" tabindex="-1"><a class="header-anchor" href="#容器化技术在底层的运行原理"><span>容器化技术在底层的运行原理？</span></a></h2><p>2006 年前后，人们，包括一些谷歌的雇员，在 Linux 内核级别上实现了一种新的名为命名空间（namespace）的技术（实际上这种概念在 FreeBSD 系统上由来已久）。我们知道，操作系统的一个功能就是进程共享公共资源，诸如，网络和硬盘空间等。但是，如果一些公共资源被包装在一个命名空间中，只允许属于这个命名空间中的进程访问又如何呢？也就是说，可以分配一大块硬盘空间给命名空间 X 供其使用，但是，命名空间 Y 中的进程无法看到或访问这部分资源。同样地，命名空间 Y 中分配的资源，命名空间 X 中的进程也无法访问。当然， X 中的进程无法与 Y 中的进程进行交互。这提供了某种对公共资源的虚拟化和隔离的技术。</p><p>这就是 Docker 技术的底层工作原理：每个容器运行在它自己的命名空间中，但是，确实与其它运行中的容器共用相同的系统内核。隔离的产生是由于系统内核清楚地知道命名空间及其中的进程，且这些进程调用系统 API 时，内核保证进程只能访问属于其命名空间中的资源。</p><figure><img src="/assets/image/docs/Aspose.Words.51b43265-f45e-4206-a945-0b7c10078cb5.031.jpeg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>图上文字说明：运行中的容器是隔离的。准确地说，各容器共享操作系统内核及操作系统 API。</p><h2 id="说说容器化技术与虚拟化技术的优缺点" tabindex="-1"><a class="header-anchor" href="#说说容器化技术与虚拟化技术的优缺点"><span>说说容器化技术与虚拟化技术的优缺点</span></a></h2><p>仅有下面的一些对比：</p><p>不能像虚拟机那样在容器上运行与主机完全不同的操作系统。然而，可以在容器上运行不同的 Linux 发布版，由于容器共享系统内核的缘故。容器的隔离性没有虚拟机那么健壮。事实上，在早期容器化技术实现上，存在某种方法使客户容器可接管整个主机系统。也可看到，载入新容器并运行，并不会像虚拟机那样装载一个新的操作系统进来。</p><p>所有的容器共享同一系统内核，这也就是容器被认为非常轻量化的原因。同样的原因，不像虚拟机，你不须为容器预分配大量的内存空间，因为它不是运行新的整个的操作系统。这使得在一个操作系统主机上，可以同时运行成百上千个容器应用，在运行完整操作系统的虚拟机上，进行这么多的并行沙箱实验是不可能的。</p><h2 id="如何使-docker-适应多种运行环境" tabindex="-1"><a class="header-anchor" href="#如何使-docker-适应多种运行环境"><span>如何使 Docker 适应多种运行环境？</span></a></h2><p>您必然想改变您的 Docker 应用配置以更适应现实运行环境的变化。下面包含一些修改建议：</p><p>移除应用代码中对任何固定存储卷的绑定，由于代码驻留在容器内部，而不能从外部进行修正。</p><p>绑定应用端口到主机上的不同端口</p><p>差异化设置环境变量（例如：减少日志冗余或者使能发电子邮件）设定重启策略（例如： restart: always ），避免长时间宕机加入额外的服务（例如： log aggregator）</p><p>由于以上原因，您更需要一个 Compose 配置文件，大概叫</p><p>production.yml ，它配置了恰当的产品整合服务。这个配置文件只需包含您选择的合适的原始 Compose 配置文件中，你改动的部分。</p><p>docker-compose -f docker-com</p><h2 id="为什么-docker-compose-采取的是并不等待前面依赖服务项的容器启动就绪后再启动的组合容器启动策略" tabindex="-1"><a class="header-anchor" href="#为什么-docker-compose-采取的是并不等待前面依赖服务项的容器启动就绪后再启动的组合容器启动策略"><span>为什么 Docker compose 采取的是并不等待前面依赖服务项的容器启动就绪后再启动的组合容器启动策略？</span></a></h2><p>Docker 的 Compose 配置总是以依赖启动序列来启动或停止 Compose 中的服务容器，依赖启动序列是由 Compose 配置文件中的 depends_on ， links ， volumes_from 和 network_mode: &quot;service : ...&quot;等这些配置指令所确定的。</p><p>然而， Compose 启动中，各容器的启动并不等待其依赖容器（这必定是你整个应用中的某个依赖的服务或应用）启动就绪后才启动。使用这种策略较好的理由如下：</p><p>等待一个数据库服务（举例）就绪这样的问题，在大型分布式系统中仅是相比其它大问题的某些小问题。在实际发布产品运维中，您的数据库服务会由于各种原因，或者迁移宿主机导致其不可访问。您发布的产品需要有应对这样状况的弹性。</p><p>掌控这些，开发设计您的应用，使其在访问数据库失效的情况下，能够试图重连数据库，直至其连接到数据库为止。最佳的解决方案是在您的应用代码中检查是否有应对意外的发生，无论是任何原因导致的启动或连接失效都应考虑在内。</p></div><!--[--><!----><!--]--><footer class="page-meta"><div class="meta-item edit-link"><a href="https://github.com/xiaobaiTech/golang-full-stack/edit/main/src/架构/云原生/面试题.md" rel="noopener noreferrer" target="_blank" aria-label="在 GitHub 上编辑此页" class="nav-link label"><!--[--><svg xmlns="http://www.w3.org/2000/svg" class="icon edit-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="edit icon"><path d="M430.818 653.65a60.46 60.46 0 0 1-50.96-93.281l71.69-114.012 7.773-10.365L816.038 80.138A60.46 60.46 0 0 1 859.225 62a60.46 60.46 0 0 1 43.186 18.138l43.186 43.186a60.46 60.46 0 0 1 0 86.373L588.879 565.55l-8.637 8.637-117.466 68.234a60.46 60.46 0 0 1-31.958 11.229z"></path><path d="M728.802 962H252.891A190.883 190.883 0 0 1 62.008 771.98V296.934a190.883 190.883 0 0 1 190.883-192.61h267.754a60.46 60.46 0 0 1 0 120.92H252.891a69.962 69.962 0 0 0-69.098 69.099V771.98a69.962 69.962 0 0 0 69.098 69.098h475.911A69.962 69.962 0 0 0 797.9 771.98V503.363a60.46 60.46 0 1 1 120.922 0V771.98A190.883 190.883 0 0 1 728.802 962z"></path></svg><!--]-->在 GitHub 上编辑此页<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span><!----></a></div><div class="meta-item git-info"><div class="update-time"><span class="label">上次编辑于: </span><!----></div><div class="contributors"><span class="label">贡献者: </span><!--[--><!--[--><span class="contributor" title="email: xiaobaidebug@gmail.com">xiaobai</span>,<!--]--><!--[--><span class="contributor" title="email: 948485496@qq.com">xiaobai-tech</span><!--]--><!--]--></div></div></footer><!----><div id="comment" class="giscus-wrapper input-top" style="display:block;"><div class="loading-icon-wrapper" style="display:flex;align-items:center;justify-content:center;height:96px"><svg xmlns="http://www.w3.org/2000/svg" width="48" height="48" preserveAspectRatio="xMidYMid" viewBox="25 25 50 50"><animateTransform attributeName="transform" type="rotate" dur="2s" keyTimes="0;1" repeatCount="indefinite" values="0;360"></animateTransform><circle cx="50" cy="50" r="20" fill="none" stroke="currentColor" stroke-width="4" stroke-linecap="round"><animate attributeName="stroke-dasharray" dur="1.5s" keyTimes="0;0.5;1" repeatCount="indefinite" values="1,200;90,200;1,200"></animate><animate attributeName="stroke-dashoffset" dur="1.5s" keyTimes="0;0.5;1" repeatCount="indefinite" values="0;-35px;-125px"></animate></circle></svg></div></div><!--[--><!----><!--]--><!--]--></main><!--]--><footer class="vp-footer-wrapper"><div class="vp-footer">关注公众号「小白debug」,回复「面试」获面试题集pdf</div><div class="vp-copyright">Copyright © 2024 小白debug </div></footer></div><!--]--><!--[--><!--[--><!--]--><!----><!--]--><!--]--></div>
    <script type="module" src="/assets/app-CRAuvUzn.js" defer></script>
  </body>
</html>
